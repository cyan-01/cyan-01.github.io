{"meta":{"title":"听风的博客","subtitle":"","description":"","author":"听风","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2025-01-25T09:32:33.000Z","updated":"2025-01-25T09:34:16.956Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2025-01-25T09:30:32.000Z","updated":"2025-01-25T09:34:39.972Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"link","date":"2025-01-25T09:31:31.000Z","updated":"2025-01-25T09:34:31.711Z","comments":true,"path":"link/index.html","permalink":"http://example.com/link/index.html","excerpt":"","text":""},{"title":"tags","date":"2025-01-25T09:27:43.000Z","updated":"2025-01-25T09:35:44.869Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"力扣hot100python题解","slug":"力扣hot100python题解","date":"2025-03-04T01:25:44.000Z","updated":"2025-03-08T10:10:59.162Z","comments":true,"path":"2025/03/04/力扣hot100python题解/","permalink":"http://example.com/2025/03/04/%E5%8A%9B%E6%89%A3hot100python%E9%A2%98%E8%A7%A3/","excerpt":"","text":"哈希 两数之和 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。 你可以按任意顺序返回答案。 1234567class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: hashtable = &#123;&#125; for index, num in enumerate(nums): if (target-num) in hashtable: return [index, hashtable[target-num]] hashtable[num] = index 字母异位词分组 给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。 字母异位词 是由重新排列源单词的所有字母得到的一个新单词。 12345678910class Solution: def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]: ans = &#123;&#125; for s in strs: key = &#x27;&#x27;.join(sorted(s)) if key not in ans: ans[key] = [s] else: ans[key].append(s) return list(ans.values()) 最长连续序列 给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。 请你设计并实现时间复杂度为 O(n) 的算法解决此问题。 123456789101112class Solution: def longestConsecutive(self, nums: List[int]) -&gt; int: ans = 0 st = set(nums) for x in st: if x-1 in st: continue y = x+1 while y in st: y = y + 1 ans = max(ans,y -x) return ans 双指针 移动0 1234567891011class Solution: def moveZeroes(self, nums: List[int]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify nums in-place instead. &quot;&quot;&quot; left = right = 0 while right &lt; len(nums): if nums[right]!=0: nums[left],nums[right]=nums[right],nums[left] left += 1 right += 1 盛水最多容器 给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 返回容器可以储存的最大水量。 **说明：**你不能倾斜容器。 12345678910111213class Solution: def maxArea(self, height: List[int]) -&gt; int: left = ans = 0 right = len(height) - 1 while left &lt; right : if height[left] &lt; height[right]: ans = max(ans,height[left]*(right-left)) left += 1 else: ans = max(ans,height[right]*(right-left)) right -= 1 return ans 三数之和 给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。 **注意：**答案中不可以包含重复的三元组。 123456789101112131415161718192021222324252627282930class Solution: def threeSum(self, nums: List[int]) -&gt; List[List[int]]: nums.sort() ans = [] n = len(nums) for i in range(n - 2): x = nums[i] if i &gt; 0 and x == nums[i - 1]: # 跳过重复数字 continue if x + nums[i + 1] + nums[i + 2] &gt; 0: # 优化一 break if x + nums[-2] + nums[-1] &lt; 0: # 优化二 continue j = i + 1 k = n - 1 while j &lt; k: s = x + nums[j] + nums[k] if s &gt; 0: k -= 1 elif s &lt; 0: j += 1 else: # 三数之和为 0 ans.append([x, nums[j], nums[k]]) j += 1 while j &lt; k and nums[j] == nums[j - 1]: # 跳过重复数字 j += 1 k -= 1 while k &gt; j and nums[k] == nums[k + 1]: # 跳过重复数字 k -= 1 return ans 接雨水 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 123456789101112131415161718192021222324class Solution: def trap(self, height: List[int]) -&gt; int: if not height: return 0 left, right = 0, len(height) - 1 # 两个指针 left_max, right_max = height[left], height[right] # 左右最大边界 ans = 0 # 结果累加器 while left &lt; right: if height[left] &lt; height[right]: left += 1 if height[left] &gt; left_max: left_max = height[left] else: ans += left_max - height[left] else: right -= 1 if height[right] &gt; right_max: right_max = height[right] else: ans += right_max - height[right] return ans 滑动窗口 无重复字符的最长字串 给定一个字符串 s ，请你找出其中不含有重复字符的 最长 子串 的长度。 123456789101112131415class Solution: def lengthOfLongestSubstring(self, s: str) -&gt; int: d = &#123;&#125; res = 0 start = -1 for index, c in enumerate(s): if c not in d: res = max(res, index-start) else: if d[c] &gt; start: start = d[c] else: res = max(res, index-start) d[c] = index return res 找到字符串中所有字母异位词 给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。 示例 1: 12345输入: s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;输出: [0,6]解释:起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的异位词。起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的异位词。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution: def findAnagrams(self, s: str, p: str) -&gt; List[int]: # 获取字符串 s 和 p 的长度 s_len, p_len = len(s), len(p) # 如果 s 的长度小于 p 的长度，直接返回空列表，因为无法形成异位词子串 if s_len &lt; p_len: return [] # 初始化结果列表，用于存储异位词子串的起始索引 ans = [] # 初始化两个长度为 26 的数组，用于统计字符频率 # s_count 用于统计当前窗口内的字符频率 # p_count 用于统计字符串 p 的字符频率 s_count = [0] * 26 p_count = [0] * 26 # 遍历 p 的前 p_len 个字符，初始化 s_count 和 p_count for i in range(p_len): # 统计 s 的前 p_len 个字符的频率 s_count[ord(s[i]) - 97] += 1 # 统计 p 的前 p_len 个字符的频率 p_count[ord(p[i]) - 97] += 1 # 如果初始窗口的字符频率与 p 的字符频率相等，说明第一个窗口就是异位词 # 将起始索引 0 加入结果列表 if s_count == p_count: ans.append(0) # 滑动窗口遍历 s 的剩余部分 for i in range(s_len - p_len): # 窗口滑动时，移除窗口左侧的字符，将其频率减 1 s_count[ord(s[i]) - 97] -= 1 # 添加窗口右侧的新字符，将其频率加 1 s_count[ord(s[i + p_len]) - 97] += 1 # 检查当前窗口的字符频率是否与 p 的字符频率相等 # 如果相等，说明当前窗口是异位词，将起始索引（i + 1）加入结果列表 if s_count == p_count: ans.append(i + 1) # 返回结果列表 return ans 子串 和为 k的子数组 给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。 子数组是数组中元素的连续非空序列。 12345678910111213141516class Solution: def subarraySum(self, nums: List[int], k: int) -&gt; int: count, pre = 0, 0 hashmap = dict(&#123;0:1&#125;) for num in nums: pre += num if pre - k in hashmap: count += hashmap[pre - k] if pre in hashmap: hashmap[pre] += 1 else: hashmap[pre] = 1 return count 滑动窗口最大值 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。 返回 滑动窗口中的最大值 12345678910111213141516171819202122232425262728293031323334353637383940class Solution: def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]: # 如果数组为空或窗口大小为0，直接返回空列表 if not nums or k == 0: return [] # 使用双端队列来存储当前窗口中的元素索引 deque = collections.deque() # 未形成窗口时的处理 for i in range(k): # 如果队列不为空且队列末尾的元素小于当前元素，则弹出队列末尾的元素 # 这样可以保证队列中的元素是递减的 while deque and deque[-1] &lt; nums[i]: deque.pop() # 将当前元素加入队列 deque.append(nums[i]) # 将当前窗口的最大值（即队列的第一个元素）加入结果列表 res = [deque[0]] # 形成窗口后的处理 for i in range(k, len(nums)): # 如果队列的第一个元素是窗口最左边的元素，则将其从队列中移除 # 因为这个元素即将离开窗口 if deque[0] == nums[i - k]: deque.popleft() # 如果队列不为空且队列末尾的元素小于当前元素，则弹出队列末尾的元素 # 这样可以保证队列中的元素是递减的 while deque and deque[-1] &lt; nums[i]: deque.pop() # 将当前元素加入队列 deque.append(nums[i]) # 将当前窗口的最大值（即队列的第一个元素）加入结果列表 res.append(deque[0]) # 返回结果列表 return res 最小覆盖字串 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 &quot;&quot; 。 1234567891011121314151617181920212223class Solution: def minWindow(self, s: str, t: str) -&gt; str: ans_left, ans_right = -1, len(s) cnt = defaultdict(int) # 比 Counter 更快 for c in t: cnt[c] += 1 less = len(cnt) left = 0 for right, c in enumerate(s): cnt[c] -= 1 if cnt[c] == 0: less -= 1 while less == 0: if right - left &lt; ans_right - ans_left: ans_left, ans_right = left, right x = s[left] if cnt[x] == 0: less += 1 cnt[x] += 1 left += 1 return &quot;&quot; if ans_left &lt; 0 else s[ans_left: ans_right + 1] 普通数组 最大子数组和 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 子数组是数组中的一个连续部分。 123456789101112class Solution: def maxSubArray(self, nums: List[int]) -&gt; int: count = 0 result = -99999 for i in nums: count += i if count &gt; result: result = count if count &lt; 0: count = 0 return result 合并区间 以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。 1234567891011121314class Solution: def merge(self, intervals: List[List[int]]) -&gt; List[List[int]]: intervals.sort(key=lambda x: x[0]) merged = [] for interval in intervals: # 如果列表为空，或者当前区间与上一区间不重合，直接添加 if not merged or merged[-1][1] &lt; interval[0]: merged.append(interval) else: # 否则的话，我们就可以与上一区间进行合并 merged[-1][1] = max(merged[-1][1], interval[1]) return merged 轮转数组 给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。 1234567891011121314class Solution: def rotate(self, nums: List[int], k: int) -&gt; None: def reverse(i: int, j: int) -&gt; None: while i &lt; j: nums[i], nums[j] = nums[j], nums[i] i += 1 j -= 1 n = len(nums) k %= n # 轮转 k 次等于轮转 k % n 次 reverse(0, n - 1) reverse(0, k - 1) reverse(k, n - 1) 除自身以外数组的乘积 给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。 题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在 32 位 整数范围内。 请 **不要使用除法，**且在 O(n) 时间复杂度内完成此题。 12345678910111213import mathclass Solution: def productExceptSelf(self, nums: List[int]) -&gt; List[int]: # 如果有0，可以简化运算 total = math.prod(nums) ans = [] for i, num in enumerate(nums): if num != 0: ans.append(total // num) else: ans.append(math.prod(nums[:i] + nums[i+1:])) return ans 缺失的第一个正数 给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。 请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。 12345678910111213class Solution: def firstMissingPositive(self, nums: List[int]) -&gt; int: N = len(nums) num_list = [0]*(N+1) for num in nums: if num&gt;N or num&lt;=0: continue num_list[num] = 1 for i in range(1,N+1): if num_list[i] == 0: return i return N+1 矩阵 矩阵置零 给定一个 *m* x *n* 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法**。** 123456789101112131415161718class Solution: def setZeroes(self, matrix: List[List[int]]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify matrix in-place instead. &quot;&quot;&quot; m, n = len(matrix), len(matrix[0]) row = [False] * m col = [False] * n for i in range(m): for j in range(n): if matrix[i][j] == 0: row[i], col[j] = True, True for i in range(m): for j in range(n): if row[i] or col[j]: matrix[i][j] = 0 螺旋矩阵 给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。 1234567891011121314151617class Solution: def spiralOrder(self, matrix: List[List[int]]) -&gt; List[int]: result = [] while matrix : result.extend(matrix.pop(0)) if matrix : if matrix[0]: for i in range(len(matrix)): result.append(matrix[i].pop()) if matrix : k = matrix.pop() result.extend(k[::-1]) if matrix : if matrix[0]: for i in range(len(matrix)-1,-1,-1): result.append(matrix[i].pop(0)) return result 旋转图像 给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。 你必须在** 原地** 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。 12345678910class Solution: def rotate(self, matrix: List[List[int]]) -&gt; None: n = len(matrix) # 深拷贝 matrix -&gt; tmp tmp = copy.deepcopy(matrix) # 根据元素旋转公式，遍历修改原矩阵 matrix 的各元素 for i in range(n): for j in range(n): matrix[j][n - 1 - i] = tmp[i][j] 链表 相交链表 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。 1234567class Solution: def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode: A, B = headA, headB while A != B: A = A.next if A else headB B = B.next if B else headA return A 反转链表 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 1234567891011121314# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]: cur ,pre = head, None while cur: temp = cur.next cur.next = pre pre = cur cur = temp return pre 二叉树 二叉树的中序遍历 给定一个二叉树的根节点 root ，返回 它的 中序 遍历 1234567891011121314151617181920class Solution: def inorderTraversal(self, root: TreeNode) -&gt; List[int]: # 初始化栈和结果列表 stack, rst = [root], [] # stack 用于模拟递归调用栈，rst 用于存储遍历结果 # 开始遍历 while stack: # 当栈不为空时，继续遍历 i = stack.pop() # 弹出栈顶元素 # 如果当前元素是 TreeNode 类型 if isinstance(i, TreeNode): # 将右子树、当前节点的值、左子树按顺序压入栈 stack.extend([i.right, i.val, i.left]) # 注意顺序：右 -&gt; 值 -&gt; 左 # 如果当前元素是整数类型（节点的值） elif isinstance(i, int): rst.append(i) # 将节点的值加入结果列表 # 返回结果列表 return rst 二叉树的最大深度 给定一个二叉树 root ，返回其最大深度。二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。 1234class Solution: def maxDepth(self, root: Optional[TreeNode]) -&gt; int: if not root: return 0 return max(self.maxDepth(root.left),self.maxDepth(root.right))+1 图论 岛屿数量 给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。此外，你可以假设该网格的四条边均被水包围。 1234567输入：grid = [ [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]]输出：3 1234567891011121314151617181920212223242526272829303132333435class Solution: def numIslands(self, grid: List[List[str]]) -&gt; int: n_l = 0 # 初始化岛屿数量为 0 # 遍历整个网格 for i in range(len(grid)): for j in range(len(grid[0])): # 如果当前单元格是陆地（&#x27;1&#x27;），则开始 DFS 遍历 if grid[i][j] == &#x27;1&#x27;: self.landpaint(grid, i, j) # 标记当前岛屿的所有陆地 n_l += 1 # 岛屿数量加 1 # 返回岛屿数量 return n_l # DFS 函数：标记当前岛屿的所有陆地 def landpaint(self, grid, x, y): # 将当前陆地标记为已访问（&#x27;2&#x27;） grid[x][y] = &#x27;2&#x27; # 检查下方单元格 if x + 1 &lt; len(grid) and grid[x + 1][y] == &#x27;1&#x27;: self.landpaint(grid, x + 1, y) # 检查右方单元格 if y + 1 &lt; len(grid[0]) and grid[x][y + 1] == &#x27;1&#x27;: self.landpaint(grid, x, y + 1) # 检查上方单元格 if x - 1 &gt;= 0 and grid[x - 1][y] == &#x27;1&#x27;: self.landpaint(grid, x - 1, y) # 检查左方单元格 if y - 1 &gt;= 0 and grid[x][y - 1] == &#x27;1&#x27;: self.landpaint(grid, x, y - 1) 腐烂的橘子 在给定的 m x n 网格 grid 中，每个单元格可以有以下三个值之一：值 0 代表空单元格；值 1 代表新鲜橘子；值 2 代表腐烂的橘子。 每分钟，腐烂的橘子 周围 4 个方向上相邻 的新鲜橘子都会腐烂。返回 直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1 。 123456789101112131415161718192021222324class Solution: def orangesRotting(self, grid: List[List[int]]) -&gt; int: m,n=len(grid),len(grid[0]) fresh=0 q=[] for i,row in enumerate(grid): for j,x in enumerate(row): if x==1: fresh+=1 elif x==2: q.append((i,j)) ans=0 while q and fresh: ans+=1 tmp=q q=[] for x,y in tmp: for i, j in (x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1): # 四方向 if 0 &lt;= i &lt; m and 0 &lt;= j &lt; n and grid[i][j] == 1: # 新鲜橘子 fresh -= 1 grid[i][j] = 2 # 变成腐烂橘子 q.append((i, j)) return -1 if fresh else ans 回溯 全排列 给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。 1234567891011121314151617181920212223242526272829303132333435363738class Solution: def permute(self, nums: List[int]) -&gt; List[List[int]]: # 定义 DFS 函数 def dfs(nums, size, depth, path, used, res): # 如果当前深度等于数组大小，说明找到一个完整排列 if depth == size: res.append(path[:]) # 将当前排列加入结果列表 return # 遍历数组中的每个元素 for i in range(size): # 检查当前元素是否已经被使用过 if not used[i]: # 标记当前元素为已使用 used[i] = True # 将当前元素加入路径 path.append(nums[i]) # 递归调用 DFS，继续生成下一个位置的元素 dfs(nums, size, depth + 1, path, used, res) # 回溯：移除当前元素，恢复状态 path.pop() used[i] = False # 获取数组的长度 size = len(nums) # 如果数组为空，直接返回空列表 if size == 0: return [] # 初始化 used 数组和结果列表 used = [False] * size # 记录元素是否被使用 res = [] # 结果列表，用于存储所有排列 # 调用 DFS 函数，开始生成排列 dfs(nums, size, 0, [], used, res) # 返回结果列表 return res 子集 给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。 1234567891011121314151617181920class Solution: def subsets(self, nums: List[int]) -&gt; List[List[int]]: # 初始化结果列表 res = [] # 获取数组的长度 n = len(nums) # 定义回溯函数 def helper(i, tmp): # 将当前子集加入结果列表 res.append(tmp) # 遍历数组，生成新的子集 for j in range(i, n): # 递归调用，更新子集 helper(j + 1, tmp + [nums[j]]) # 调用回溯函数，从索引 0 和空子集开始 helper(0, []) # 返回结果列表 return res 二分查找 搜索插入位置 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 1234567891011121314class Solution: def searchInsert(self, nums: List[int], target: int) -&gt; int: left, right = 0, len(nums) - 1 while left &lt;= right: mid = (left + right) // 2 if nums[mid] == target: return mid elif nums[mid] &lt; target: left = mid + 1 else: right = mid - 1 return left # left 位置即为插入位置 搜索二维矩阵 给你一个满足下述两条属性的 m x n 整数矩阵：每行中的整数从左到右按非严格递增顺序排列。每行的第一个整数大于前一行的最后一个整数。给你一个整数 target ，如果 target 在矩阵中，返回 true ；否则，返回 false 。 12345678910111213141516171819202122232425class Solution: def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool: # 获取矩阵的行数和列数 m, n = len(matrix), len(matrix[0]) # 初始化二分查找的左右边界 l, r = 0, m * n # 将二维矩阵视为一维数组 # 开始二分查找 while l &lt; r: # 计算中间位置 mid = (l + r) &gt;&gt; 1 # 等价于 (l + r) // 2 # 将一维索引 mid 转换为二维索引 x = matrix[mid // n][mid % n] # 判断中间元素与目标值的关系 if x == target: return True # 找到目标值，返回 True if x &lt; target: l = mid + 1 # 目标值在右半部分 else: r = mid # 目标值在左半部分 # 未找到目标值，返回 False return False 栈 有效的括号 给定一个只包括 '('，')'，'&#123;'，'&#125;'，'['，']' 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 每个右括号都有一个对应的相同类型的左括号。 1234567891011class Solution: def isValid(self, s: str) -&gt; bool: dic = &#123;&#x27;)&#x27;:&#x27;(&#x27;,&#x27;]&#x27;:&#x27;[&#x27;,&#x27;&#125;&#x27;:&#x27;&#123;&#x27;&#125; stack = [] for i in s: if stack and i in dic: if stack[-1] == dic[i]: stack.pop() else: return False else: stack.append(i) return not stack 最小栈 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。实现 MinStack 类: 12345- `MinStack()` 初始化堆栈对象。- `void push(int val)` 将元素val推入堆栈。- `void pop()` 删除堆栈顶部的元素。- `int top()` 获取堆栈顶部的元素。- `int getMin()` 获取堆栈中的最小元素。 12345678910111213141516171819class MinStack: def __init__(self): self.stack = [] self.min_stack = [math.inf] def push(self, val: int) -&gt; None: self.stack.append(val) self.min_stack.append(min(val,self.min_stack[-1])) def pop(self) -&gt; None: self.stack.pop() self.min_stack.pop() def top(self) -&gt; int: return self.stack[-1] def getMin(self) -&gt; int: return self.min_stack[-1] 堆 数组中的第k个最大元素 给定整数数组 nums 和整数 k，请返回数组中第 **k** 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。 1234567891011121314151617181920212223242526272829303132333435class Solution: def findKthLargest(self, nums: List[int], k: int) -&gt; int: # 定义快速选择函数 def quick_select(nums, k): # 随机选择一个基准元素（pivot） pivot = random.choice(nums) # 初始化三个列表/变量： # - big：存储比 pivot 大的元素 # - equal：记录与 pivot 相等的元素个数 # - small：存储比 pivot 小的元素 big, equal, small = [], 0, [] # 遍历数组，将元素分类 for num in nums: if num &gt; pivot: big.append(num) # 比 pivot 大的元素放入 big elif num &lt; pivot: small.append(num) # 比 pivot 小的元素放入 small else: equal += 1 # 与 pivot 相等的元素计数 # 如果 k 小于等于 big 的长度，说明第 k 个最大元素在 big 中 if k &lt;= len(big): return quick_select(big, k) # 递归在 big 中查找 # 如果 k 大于 big 和 equal 的总长度，说明第 k 个最大元素在 small 中 if len(big) + equal &lt; k: return quick_select(small, k - len(big) - equal) # 递归在 small 中查找 # 如果以上条件都不满足，说明第 k 个最大元素就是 pivot return pivot # 调用快速选择函数，返回第 k 个最大元素 return quick_select(nums, k) 前k个高频元素 给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。 1234class Solution: def topKFrequent(self, nums: List[int], k: int) -&gt; List[int]: count = collections.Counter(nums) return [item[0] for item in count.most_common(k)] 贪心算法 买卖股票的最佳时期 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。 123456789101112class Solution: def maxProfit(self, prices: List[int]) -&gt; int: profit = 0 low=high=prices[0] for p in prices: if p &lt; low: #对每个新的最低点来说，之前的最高点不再有效，需要结利 profit = max(profit, high-low) low=high=p elif p &gt; high: high=p profit = max(profit, high-low) return profit 跳跃游戏 给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。 123456789class Solution: def canJump(self, nums: List[int]) -&gt; bool: if not nums :return False maxlong,n= 0,len(nums) for i in range(n): if i&gt;maxlong: return False maxlong= max(i+nums[i],maxlong) return True 动态规划 爬楼梯 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 123456class Solution: def climbStairs(self, n: int) -&gt; int: a, b = 1, 1 for _ in range(n - 1): a, b = b, a + b return b 杨辉三角 给定一个非负整数 *numRows，*生成「杨辉三角」的前 numRows 行。 12345678class Solution: def generate(self, numRows: int) -&gt; List[List[int]]: c = [[1] * (i + 1) for i in range(numRows)] for i in range(2, numRows): for j in range(1, i): # 左上方的数 + 正上方的数 c[i][j] = c[i - 1][j - 1] + c[i - 1][j] return c 多维动态规划 不同路径 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。问总共有多少条不同的路径？ 1234567class Solution: def uniquePaths(self, m: int, n: int) -&gt; int: f = [1] * n for i in range(1, m): for j in range(1, n): f[j] += f[j - 1] return f[n - 1] 最小路径和 给定一个包含非负整数的 *m* x *n* 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。**说明：**每次只能向下或者向右移动一步。 12345678910111213141516171819202122232425262728293031class Solution: def minPathSum(self, grid: List[List[int]]) -&gt; int: # 如果网格为空，返回 0 if not grid or not grid[0]: return 0 # 获取网格的行数和列数 rows, columns = len(grid), len(grid[0]) # 初始化动态规划数组 dp dp = [[0] * columns for _ in range(rows)] # 起点的最小路径和就是 grid[0][0] dp[0][0] = grid[0][0] # 初始化第一列的最小路径和 for i in range(1, rows): dp[i][0] = dp[i - 1][0] + grid[i][0] # 初始化第一行的最小路径和 for j in range(1, columns): dp[0][j] = dp[0][j - 1] + grid[0][j] # 填充 dp 数组的其余部分 for i in range(1, rows): for j in range(1, columns): # 当前点的最小路径和等于上方或左方的最小路径和加上当前点的值 dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] # 返回右下角的最小路径和 return dp[rows - 1][columns - 1]","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"Python 基础","slug":"Python-基础","date":"2025-02-04T08:29:02.000Z","updated":"2025-02-04T09:51:57.109Z","comments":true,"path":"2025/02/04/Python-基础/","permalink":"http://example.com/2025/02/04/Python-%E5%9F%BA%E7%A1%80/","excerpt":"","text":"关键字 yield yield 是 Python 中的一个关键字，用于定义生成器函数（generator function）。生成器函数是一种特殊的函数，它可以逐步产生值，而不是一次性返回所有结果。yield 的作用是将函数变成一个生成器，每次调用生成器的 __next__() 方法时，函数会执行到 yield 语句并返回一个值，然后暂停执行，直到下一次调用。 yield 的基本用法 示例 1：简单的生成器函数 12345678910def simple_generator(): yield 1 yield 2 yield 3# 使用生成器gen = simple_generator()print(next(gen)) # 输出: 1print(next(gen)) # 输出: 2print(next(gen)) # 输出: 3 每次调用 next(gen)，函数会从上次暂停的地方继续执行，直到遇到下一个 yield。 当没有更多的值可以生成时，会抛出 StopIteration 异常。 示例 2：使用 for 循环遍历生成器 12345678def simple_generator(): yield 1 yield 2 yield 3# 使用 for 循环遍历生成器for value in simple_generator(): print(value) 输出： 123123 for 循环会自动处理 StopIteration 异常，因此不需要手动调用 next()。 yield 的优势 惰性求值： 生成器不会一次性生成所有值，而是按需生成，节省内存。 适合处理大量数据或无限序列。 代码简洁： 使用 yield 可以避免手动实现迭代器协议（__iter__ 和 __next__）。 状态保持： 生成器函数会记住上次执行的状态，下次调用时从上次暂停的地方继续。 yield 的高级用法 示例 3：生成无限序列 123456789101112def infinite_sequence(): num = 0 while True: yield num num += 1# 使用生成器gen = infinite_sequence()print(next(gen)) # 输出: 0print(next(gen)) # 输出: 1print(next(gen)) # 输出: 2# 可以无限调用 next(gen) 这个生成器会无限生成递增的整数。 示例 4：使用 yield 实现斐波那契数列 12345678910def fibonacci(): a, b = 0, 1 while True: yield a a, b = b, a + b# 使用生成器gen = fibonacci()for _ in range(10): print(next(gen)) 输出： 123456789100112358132134 这个生成器会无限生成斐波那契数列的值。 示例 5：yield from（委托生成器） yield from 用于将生成器的控制权委托给另一个生成器。 123456789101112def sub_generator(): yield 1 yield 2def main_generator(): yield &#x27;Start&#x27; yield from sub_generator() yield &#x27;End&#x27;# 使用生成器for value in main_generator(): print(value) 输出： 1234Start12End yield from 可以简化生成器的嵌套调用。 yield 与 return 的区别 特性 yield return 返回值 每次生成一个值，函数暂停 返回一个值，函数结束 状态保持 函数状态会被保存 函数状态不会被保存 适用场景 生成器函数 普通函数 内存占用 惰性求值，节省内存 一次性返回所有结果，占用内存 总结 yield 是 Python 中实现生成器的关键，适合处理大量数据或需要惰性求值的场景。 生成器函数通过 yield 逐步返回值，并保持函数状态，直到生成所有值。 yield from 可以简化生成器的嵌套调用。 assert assert 是 Python 中的一个关键字，用于调试和测试代码。它的作用是检查某个条件是否为真，如果条件为假，则会触发 AssertionError 异常。assert 通常用于确保程序在某个关键点的状态符合预期，如果不符合，则立即停止程序并抛出错误。 assert 的基本语法 1assert condition, message condition：需要检查的条件表达式。如果为 True，程序继续执行；如果为 False，则抛出 AssertionError。 message（可选）：当条件为 False 时，抛出的异常信息。如果未提供，则使用默认的 AssertionError。 assert 的作用 调试工具： 用于在开发阶段检查代码逻辑是否正确。 如果条件不满足，程序会立即停止，方便定位问题。 测试工具： 在单元测试中，用于验证函数的输出是否符合预期。 文档工具： 通过 assert 可以清晰地表达代码的预期行为。 assert 的示例 示例 1：简单的 assert 用法 12x = 10assert x == 10, &quot;x 应该等于 10&quot; 如果 x == 10 为 True，程序继续执行。 如果 x == 10 为 False，则抛出 AssertionError，并显示消息 &quot;x 应该等于 10&quot;。 示例 2：检查函数返回值 123456def divide(a, b): assert b != 0, &quot;除数不能为 0&quot; return a / bprint(divide(10, 2)) # 输出: 5.0print(divide(10, 0)) # 触发 AssertionError: 除数不能为 0 在函数中使用 assert 可以确保输入参数的有效性。 示例 3：检查列表是否非空 1234567def process_list(items): assert len(items) &gt; 0, &quot;列表不能为空&quot; for item in items: print(item)process_list([1, 2, 3]) # 正常执行process_list([]) # 触发 AssertionError: 列表不能为空 assert 的注意事项 不要用于数据验证： assert 主要用于调试和测试，不应该用于检查用户输入或外部数据。 因为 Python 可以通过 -O（优化模式）运行，此时所有的 assert 语句会被忽略。 避免副作用： assert 的条件表达式不应该包含有副作用的操作（如修改全局变量、调用函数等），因为在优化模式下这些操作会被跳过。 替代方案： 对于数据验证或输入检查，应该使用 if 语句并手动抛出异常（如 ValueError、TypeError 等）。 assert 与 if 的区别 特性 assert if 用途 调试和测试 通用条件判断 触发异常 触发 AssertionError 需要手动抛出异常 优化模式 在 -O 模式下会被忽略 不受影响 适用场景 检查内部逻辑是否正确 检查用户输入或外部数据 assert 的优化模式 Python 支持以优化模式运行脚本，此时所有的 assert 语句会被忽略。可以通过以下命令启用优化模式： 1python -O script.py 在优化模式下，assert 语句不会被执行，因此不能依赖它来实现关键逻辑。 总结 assert 是一个强大的调试工具，用于检查代码逻辑是否符合预期。 它适合在开发和测试阶段使用，但不适合用于生产环境中的数据验证。 如果需要更健壮的输入检查，应该使用 if 语句并手动抛出异常。","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]}],"categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]}