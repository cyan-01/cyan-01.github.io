{"meta":{"title":"听风的博客","subtitle":"","description":"","author":"听风","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2025-01-25T09:32:33.000Z","updated":"2025-01-25T09:34:16.956Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2025-01-25T09:30:32.000Z","updated":"2025-01-25T09:34:39.972Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"link","date":"2025-01-25T09:31:31.000Z","updated":"2025-01-25T09:34:31.711Z","comments":true,"path":"link/index.html","permalink":"http://example.com/link/index.html","excerpt":"","text":""},{"title":"tags","date":"2025-01-25T09:27:43.000Z","updated":"2025-01-25T09:35:44.869Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"leetcode","slug":"leetcode","date":"2025-03-17T03:03:32.000Z","updated":"2025-03-17T09:18:53.712Z","comments":true,"path":"2025/03/17/leetcode/","permalink":"http://example.com/2025/03/17/leetcode/","excerpt":"","text":"哈希 1.两数之和 快速查找需求 1234567891011121314class Solution&#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums,int target)&#123; unordered_map&lt;int,int&gt; hashtable; for(int i=0;i&lt;nums.size();i++)&#123; auto it = hashtable.find(target-nums[i]); if(it !=hashtable.end())&#123; return &#123;i,it-&gt;second&#125;; &#125; hashtable[nums[i]]=i; &#125; return &#123;&#125;; &#125;&#125;; 12345678class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: hashtable=&#123;&#125; for i in range(len(nums)): if target-nums[i] in hashtable: return [i,hashtable[target-nums[i]]] hashtable[nums[i]] =i return [] 面试题 16.15 珠玑妙算 1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; masterMind(string solution, string guess) &#123; int ri= 0,fr=0; int dic[4][2] = &#123;0&#125;; unordered_map&lt;char,int&gt; char_to_index = &#123;&#123;&#x27;R&#x27;,0&#125;,&#123;&#x27;Y&#x27;,1&#125;,&#123;&#x27;G&#x27;,2&#125;,&#123;&#x27;B&#x27;,3&#125;&#125;; for(int i=0;i&lt;4;i++)&#123; char s=solution[i],g = guess[i]; if(s==g) ri++; else&#123; dic[char_to_index[s]][0]++; dic[char_to_index[g]][1]++; &#125; &#125; for(int i=0;i&lt;4;i++) fr+=min(dic[i][0],dic[i][1]); return &#123;ri,fr&#125;; &#125;&#125;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# 低效class Solution: def masterMind(self, solution: str, guess: str) -&gt; List[int]: hash_sol,hash_gue = defaultdict(int),defaultdict(int) right,fr=0,0 for i in range(4): if solution[i]==guess[i]: right += 1 else: hash_gue[guess[i]]+=1 hash_sol[solution[i]]+=1 for key in hash_gue: if key in hash_sol: fr += min (hash_sol[key],hash_gue[key]) return [right,fr]# 优化from typing import Listclass Solution: def masterMind(self, solution: str, guess: str) -&gt; List[int]: # 初始化猜中次数和伪猜中次数 corr, err = 0, 0 # 使用列表代替字典，索引对应字符： # 0: &#x27;R&#x27;, 1: &#x27;Y&#x27;, 2: &#x27;G&#x27;, 3: &#x27;B&#x27; # dic[char][0]: solution 中未匹配的字符数量 # dic[char][1]: guess 中未匹配的字符数量 dic = [[0, 0] for _ in range(4)] # 字符到索引的映射 char_to_index = &#123;&#x27;R&#x27;: 0, &#x27;Y&#x27;: 1, &#x27;G&#x27;: 2, &#x27;B&#x27;: 3&#125; # 遍历字符串，统计猜中次数和未匹配字符 for i in range(4): s, g = solution[i], guess[i] if s == g: corr += 1 else: # 更新 solution 中未匹配字符的数量 dic[char_to_index[s]][0] += 1 # 更新 guess 中未匹配字符的数量 dic[char_to_index[g]][1] += 1 # 计算伪猜中次数 for count_sol, count_gue in dic: err += min(count_sol, count_gue) return [corr, err] 1941 检查是否所有字符出现次数相同 1234567891011121314class Solution &#123;public: bool areOccurrencesEqual(string s) &#123; unordered_map&lt;char ,int&gt; hashtable; for (char c :s) hashtable[c]++; int n = hashtable[s[0]]; for(char c :s)&#123; if(hashtable[c]!=n) return false; &#125; return true; &#125;&#125;; 123456789101112131415class Solution: def areOccurrencesEqual(self, s: str) -&gt; bool: hashtable = defaultdict(int) for i in s: hashtable[i]+=1 n = hashtable[s[0]] for i in hashtable: if n!=hashtable[i]: return False return True# 优化class Solution: def areOccurrencesEqual(self, s: str) -&gt; bool: c = Counter(s) return len(set(c.values())) == 1 13 罗马数字转整数 12345678910111213141516171819202122232425class Solution &#123;public: int romanToInt(string s) &#123; unordered_map &lt;char,int&gt; dic = &#123;&#123;&#x27;I&#x27;,1&#125;,&#123;&#x27;V&#x27;,5&#125;,&#123;&#x27;X&#x27;,10&#125;,&#123;&#x27;L&#x27;,50&#125;,&#123;&#x27;C&#x27;,100&#125;,&#123;&#x27;D&#x27;,500&#125;,&#123;&#x27;M&#x27;,1000&#125;&#125;; /* // 使用数组代替 unordered_map更快 int dic[256] = &#123;0&#125;; // ASCII 表大小为 256 dic[&#x27;I&#x27;] = 1; dic[&#x27;V&#x27;] = 5; dic[&#x27;X&#x27;] = 10; dic[&#x27;L&#x27;] = 50; dic[&#x27;C&#x27;] = 100; dic[&#x27;D&#x27;] = 500; dic[&#x27;M&#x27;] = 1000; */ int result = 0; for(int i =0;i&lt;s.length();i++)&#123; if(i!=s.length()-1 &amp;&amp; dic[s[i]]&lt;dic[s[i+1]]) result-=dic[s[i]]; else result+=dic[s[i]]; &#125; return result; &#125;&#125;; 12345678910class Solution: def romanToInt(self, s: str) -&gt; int: dic = &#123;&quot;I&quot;:1,&quot;V&quot;:5,&quot;X&quot;:10,&quot;L&quot;:50,&quot;C&quot;:100,&quot;D&quot;:500,&quot;M&quot;:1000&#125; result = 0 for i in range(len(s)): if i !=len(s)-1 and dic[s[i]] &lt; dic[s[i+1]] : result -= dic[s[i]] else: result += dic[s[i]] return result 3.无重复字符的最长子串 123456789101112131415161718class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; unordered_set&lt;char&gt; set; int n=s.length(),r=0,ans=0; for(int l = 0;l&lt;n;l++)&#123; if(l!=0)&#123; set.erase(s[l-1]); &#125; while(r&lt;n &amp;&amp; set.count(s[r])==0)&#123; set.insert(s[r]); r++; &#125; ans = max(ans,r-l); &#125; return ans; &#125;&#125;; 12345678910111213class Solution: def lengthOfLongestSubstring(self, s: str) -&gt; int: occ = set() n = len(s) r,ans=0,0 for l in range(n): if l != 0: occ.remove(s[l-1]) while r&lt;n and s[r] not in occ: occ.add(s[r]) r+=1 ans = max (ans,r-l) return ans","categories":[],"tags":[]},{"title":"算法","slug":"算法","date":"2025-03-10T08:37:46.000Z","updated":"2025-03-17T03:35:59.552Z","comments":true,"path":"2025/03/10/算法/","permalink":"http://example.com/2025/03/10/%E7%AE%97%E6%B3%95/","excerpt":"","text":"哈希 题目特征 快速查找需求 如判断元素是否存在（重复、交集等），或需要快速查询互补值（如两数之和）。 统计频率/次数 统计字符、数字等的出现次数，例如变位词、多数元素问题。 唯一性/去重问题 如找第一个不重复字符、去重后保留特定顺序等。 映射关系维护 需建立元素间映射（如字符串同构），或记录元素的位置信息（如子数组问题）。 前缀和优化 结合哈希表快速计算子数组和、差值等（如和为K的子数组） 常见解题思路 哈希集合（HashSet） 存储唯一元素，用于去重或存在性判断。 示例题：环形链表、快乐数、数组交集。 哈希映射（HashMap） 记录键值对，存储元素及其索引、频率或其他关联信息。 示例题：两数之和、变位词分组、克隆图的深拷贝。 前缀和 + 哈希表 计算前缀和，用哈希表记录和的出现次数或最早出现位置。 示例题：和为K的子数组、连续数组（0和1数量相等的最长子数组）。 滑动窗口 + 哈希表 维护窗口内元素的哈希统计，用于子串/子数组问题。 示例题：无重复字符的最长子串、最小覆盖子串。 频率统计与比较 用哈希表统计频率后比较（如变位词），或用数组替代哈希优化空间（如仅小写字母的场景）。 优化技巧 数组替代哈希表：若元素范围有限（如字母、固定范围的数字），使用数组更高效。 双向映射：处理同构问题时，需双向检查两个哈希表的映射关系。 延迟更新：在滑动窗口中，可延迟删除哈希表中的元素以简化逻辑（如某些子串问题）。 典型例题 两数之和（HashMap记录值与索引） 无重复字符的最长子串（滑动窗口 + HashMap记录字符最新位置） 字母异位词分组（HashMap以排序后的字符串为Key） 和为K的子数组（前缀和 + HashMap统计和出现次数） 最长连续序列（HashSet快速查找连续元素）","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"软件测试","slug":"软件测试","date":"2025-03-10T06:38:09.000Z","updated":"2025-03-16T09:23:21.043Z","comments":true,"path":"2025/03/10/软件测试/","permalink":"http://example.com/2025/03/10/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/","excerpt":"","text":"基础 问题报告单样式 测试计划文档组成 测试工作流程 掌握需求 -&gt;测试计划-&gt;测试用例-&gt;测试执行-&gt;测试报告-&gt;回归测试 测试开始时，须有：1.系统需求说明书文档 2.BUG管理工具的地址和账户 单元测试：在开发阶段进行，验证单个代码单元的正确性。 集成测试：在单元测试之后进行，验证多个模块的协同工作。 系统测试：在集成测试之后进行，验证整个系统的功能和性能。 验收测试：在系统测试之后进行，由客户或最终用户确认系统是否满足需求 名词解释 123456789101112131415161718192021222324252627282930313233343536373839404142434445黑盒测试：不关心代码，只测输入输出。白盒测试：基于代码结构设计测试。结构测试：通过代码结构设计测试用例。功能测试：验证功能是否符合需求。路径测试：覆盖代码中的所有路径。增量测试：逐步集成和测试新模块。崩溃测试：测试系统在极端条件下的稳定性。性能测试：评估系统在不同负载下的性能。回归测试：确保修改后原有功能不受影响。单元测试：测试最小可测试单元。集成测试：测试多个模块的组合。系统测试：测试整个系统。验收测试：由客户确认系统是否满足需求。负载测试：模拟高负载测试性能。压力测试：测试系统的极限能力。安全测试：评估系统安全性。兼容性测试：测试系统在不同环境下的兼容性。冒烟测试：快速测试主要功能。探索性测试：无预设用例，通过探索发现问题。α测试：由内部人员在开发环境中进行β测试：是软件发布前的最终测试阶段，通常在α测试之后进行。它由真实用户在实际环境中执行，目的是发现开发团队未察觉的问题。用户验收测试（UAT）：由客户确认软件是否满足需求，β测试更侧重于广泛用户反馈。迭代测试：是敏捷开发中的一种测试方法，随着每个开发迭代的进行，测试活动也同步展开。每次迭代都会进行完整的测试循环，包括单元测试、集成测试、系统测试等，以确保新增功能和现有功能都符合需求。特点：持续进行：测试贯穿整个开发周期，而非仅在开发完成后进行。增量式：每次迭代只测试新增或修改的部分，同时进行回归测试以确保原有功能不受影响。快速反馈：通过频繁测试，开发团队能快速发现并修复问题。能都经过充分测试。 面试 测试流程与规范 偶现bug怎么处理？ 截图、保留证据，根据操作路径进⾏重现，提交禅道，上线前继续跟踪，上线后再跟踪⼀两个版本，最后作为遗留bug写到测试报告⾥⾯ 没有需求⽂档，如何开展测试？ 1、与相关⼈员沟通，产品或开发 2、参考同⾏业竞品，总结梳理需求 3、根据⽤户习惯和⾏业规范，总结梳理 线上出现bug怎么办？ ⾸先评估严重程度和产⽣原因， 1、如果是影响⾯⽐较⼤的功能性问题，且短时间内不好定位具体原因，⾸先考虑做代码回滚，恢复到上 ⼀个稳定版本，然后在测试环境进⾏重现，定位问题原因 2、如果是能快速定位问题原因，就让开发做紧急修复，测试后进⾏上线 3、如果是性能问题，⼀般会进⾏扩容，或重启尝试解决，然后开发会做进⼀步的问题定位和优化 4、如果是⼀些优化性问题，会先进⾏记录，然后在下个版本解决 最后，线上bug解决后，要对问题进⾏复盘，分析和总结，避免后续再出现类似问题 临近上线发现了bug要怎么处理？ ⾸先与相关⼈员（开发、产品）评估bug的严重程度和影响范围， 如果是轻微的bug，可以考虑先上线，后续版本迭代中修复， 如果是⽐较严重的bug，找开发沟通，能否快速修复，并且有⾜够的时间去做下测试 如果时间不⾜了，那就得和相关⼈员后台，是否可以延期上线，避免上线后造成严重的后果 参加⼈员：测试⼈员、开发⼈员、产品⼈员 会议评审 ⽤例评审都有哪些⼈参加？怎么做的？有什么标准？ 参加⼈员：测试⼈员、开发⼈员、产品⼈员 会议评审 标准： ⽤例设计的结构安排是否清晰、合理，是否利于⾼效对需求进⾏覆盖。 优先极安排是否合理。 是否覆盖测试需求上的所有功能点。 ⽤例是否具有很好可执⾏性。例如⽤例的前提条件、执⾏步骤、输⼊数据和期待结果是否清晰、正确； 期待结果是否有明显的验证⽅法。 是否已经删除了冗余的⽤例 迭代测试发现不了问题，怎么办？ 1)必要的业务培训 结合业务流程图、系统架构图，对业务系统有个整体的感知。知道业务系统的整体业务流向及涉及的系统架构，这样有助于测试⼈员从⼤的⽅向去拉通测试场景，不⾄于陷⼊细节中⽽⽆法顾及全貌。 2)制定明确地测试策略 即明确两个问题：测什么？怎么测？“减少缺陷的出现”可以通过测试前移等⽅法来解决，在进⾏软件需求分析和架构设计的时候发现 缺陷； 3)严格执⾏测试流程 设计测试⽤例、⽤例评审、开发⾃测等 4)建⽴质量意识和责任感 出现问题时，测试应该有责任和能⼒去探查问题的根源并加以改进 5)定期回顾和总结 缺陷分析，在某个迭代或者版本的周期内（或者更⻓时间），对BUG产⽣的原因、修复周期、累 积趋势进⾏分析。总结分析bug和测试过程问题，形成的质量报告不仅能准确评估过去产品质量，还能为未来产品提出改进建议，持续推进产品质量的不断提⾼和完善 接口测试 什么时候会做接⼝测试 回归测试 前后端联调阶段（开发进⾏⾃测） 验证⼀些后端接⼝是否有限制的场景（资⾦相关） 怎么做接⼝测试的 1、获取到接⼝⽂档、熟悉单接⼝的业务、连接接⼝业务，包括接⼝地址，请求⽅式，鉴权，⼊参，出 参，错误码等 加密，签名等 2、编写接⼝⽤例并评审 正例：单接⼝，链接接⼝ 反例：鉴权（过期的场景、不正确） 参数（类型异常、⻓度异常）， 错误码（-1 系统繁忙、不同公司不⼀样）， ⿊名单（⿊名单⽤户是否还允许访问） 禁⽤ 调⽤次数（⼿续费） 分⻚（每⻚10条，每⻚是否都有数据，总数据是否正确，边界值） 兼容性（不同调⽤⽅式下（如app版本不⼀样时），接⼝返回的数据是否相同） 3、执⾏⽤例 举出具体的接⼝案例以及⼀些特定场景，如：接⼝串联（token传递）、环境变量、全局变量、随机数获 取（⽐如第三⽅单号） 4、持续集成 钉钉群通知、电⼦邮件 如果⼀个接⼝请求不通，那么你会考虑哪些⽅⾯的问题？ 1、检查请求四要素：请求⽅式、域名、请求头、请求参数、有没有空格 2、⽹络情况 3、项⽬迭代过程中是否有部署好 4、服务器的防⽕墙 5、查看后台⽇志是否有报错 6、访问权限是否到位 7、⼀边打开fiddler（打开代理服务器，证书有问题）⼀遍做接⼝测试（基于https） 8、检查是否绑定了错误的hosts 接⼝测试的作⽤ 1、接⼝测试是⽆⻚⾯的功能测试，设计⽤例思路跟功能测试⼀样（只是⼀个注重的是测前端⻚⾯，⼀个注重的是测后端接⼝） 2、接⼝测试可以绕开前端 3、接⼝测试可以校验并发的情况 4、可以核对接⼝请求资源⼤⼩ 5、可以进⾏弱⽹测试 接⼝测试的主要关注点？ （1）业务逻辑（业务逻辑覆盖） （2）响应结构 （3）数据格式 （4）数据正确性（依据来源：查数据库与服务器和接⼝返回值⽐较） Cooike、session、token的区别 相同点：三者都⽤于鉴权，都是服务器⽣成 不同点： Cooike：保存在浏览器，不安全 session：保存在服务器的内存，并且它⼀般是通过cooike传输sessionid，它⽐cooike更安全，当访问量⼤的时候影响服务器的性能 token 存储在服务器的数据库，通常是通过登录或者⼀个特定的接⼝传⼊appid和appsect来获取，后续所有的接⼝都必须带上token 才能请求成功，有些项⽬toekn也是通过cookie传输的 特定接⼝：对于需要做RSA加密的接⼝，需要做签名的接⼝在Jmeter/postman要如何处理？ JMeter 使用 JSR223 预处理器 或 BeanShell 预处理器 编写脚本实现 RSA 加密和签名。 将结果存储到 JMeter 变量中，并在请求中使用。 Postman 使用 Pre-request Script 编写脚本实现 RSA 加密和签名。 将结果存储到 Postman 变量中，并在请求中使用。 如何验证接⼝是否返回成功 1、校验状态码是否200（状态断⾔ 只有⼀个） 2、核⼼业务断⾔ 返回结果⽐较短的：key=value 返回结果较⻓的：通过关键信息，数据库校验⻓度 3、XML或JSON：通过正则，jsonpath提取关键的业务字段进⾏断⾔ 接⼝关联怎么做 ⽤⼀个全局变量来处理依赖的数据，⽐如登录后返回 token,其它接⼝都需要这 个 token,那就⽤全局变量来传 token 参数 没有接⼝⽂档如何做接⼝测试 可以使⽤抓包⼯具进⾏抓包看接⼝请求参数，然后不懂的跟开发沟通 常⻅的接⼝请求头 1234AcceptX-Requested-WithUser-AgentContent-Type 接⼝测试常⽤检查点 接口测试检查点（按检查类型分类） 检查类型 检查点 描述 业务测试 正常流程返回数据的正确性 验证接口在正常业务流程下返回的数据内容、格式、逻辑是否符合预期。 接口文档符合性 验证返回值是否按接口文档规定格式（如JSON/XML）、编码（UTF-8）、字段命名（如return_msg）返回。 参数类型传递正确性 验证接口是否正确处理参数类型（如数字、字符串、布尔值等）。 接口依赖关系测试 验证接口依赖的其他服务或数据源异常时，是否能正确处理（如降级、超时）。 异常业务处理逻辑 验证业务异常场景（如余额不足、库存为负）是否返回明确的错误码和描述。 参数测试 参数值全量覆盖验证 对参数所有可能取值（枚举值、布尔值等）进行覆盖测试。 必填参数正确性验证 必填参数传入有效值时，接口返回预期结果。 必填/非必填参数组合验证 测试不同必填与非必填参数组合下的接口行为（如缺少非必填参数是否影响功能）。 参数边界值验证 验证参数在边界值（如最大值、最小值、空值、超长字符串）下的处理逻辑。 异常测试 必填参数缺失 缺失必填参数时是否返回明确错误码（如400 Bad Request）。 非法参数值 传入非法参数（如非数字传入数字字段）是否返回类型错误提示。 超限参数值 参数超过允许范围（如金额超限）是否触发业务规则校验。 性能测试 响应时间 单请求响应时间是否在SLA要求范围内（如≤500ms）。 并发处理能力 高并发场景下接口是否稳定（如100并发用户请求成功率≥99%）。 大数据量处理 处理大量数据时（如万级列表查询）是否返回正确且性能达标。 安全性测试 敏感信息加密 返回的敏感数据（如手机号、身份证号）是否脱敏或加密。 未授权访问防护 未携带Token或权限不足时是否返回401 Unauthorized。 SQL注入防护 传入SQL注入语句（如' OR 1=1 --）是否被拦截并返回错误。 幂等性测试 重复请求一致性 多次提交相同请求（如支付）是否仅产生一次有效结果。 兼容性测试 多版本兼容 新旧版本接口参数格式（如v1/v2）是否能兼容处理。 多客户端兼容 不同客户端（Web/App/第三方）调用接口时返回数据格式是否一致。 功能测试 测试环境没问题，但⽣产/灰度环境有问题，会从哪些原因去定位排查 1、部署原因，⽣产/灰度环境的代码与测试环境验证通过的不⼀致 2、测试数据问题，有些bug需要特殊的数据才能重现出来 3、配置原因，⽣产/灰度环境的配置出问题","categories":[],"tags":[{"name":"测试","slug":"测试","permalink":"http://example.com/tags/%E6%B5%8B%E8%AF%95/"}]},{"title":"力扣hot100python题解","slug":"力扣hot100python题解","date":"2025-03-04T01:25:44.000Z","updated":"2025-03-08T10:10:59.162Z","comments":true,"path":"2025/03/04/力扣hot100python题解/","permalink":"http://example.com/2025/03/04/%E5%8A%9B%E6%89%A3hot100python%E9%A2%98%E8%A7%A3/","excerpt":"","text":"哈希 两数之和 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。 你可以按任意顺序返回答案。 1234567class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: hashtable = &#123;&#125; for index, num in enumerate(nums): if (target-num) in hashtable: return [index, hashtable[target-num]] hashtable[num] = index 字母异位词分组 给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。 字母异位词 是由重新排列源单词的所有字母得到的一个新单词。 12345678910class Solution: def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]: ans = &#123;&#125; for s in strs: key = &#x27;&#x27;.join(sorted(s)) if key not in ans: ans[key] = [s] else: ans[key].append(s) return list(ans.values()) 最长连续序列 给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。 请你设计并实现时间复杂度为 O(n) 的算法解决此问题。 123456789101112class Solution: def longestConsecutive(self, nums: List[int]) -&gt; int: ans = 0 st = set(nums) for x in st: if x-1 in st: continue y = x+1 while y in st: y = y + 1 ans = max(ans,y -x) return ans 双指针 移动0 1234567891011class Solution: def moveZeroes(self, nums: List[int]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify nums in-place instead. &quot;&quot;&quot; left = right = 0 while right &lt; len(nums): if nums[right]!=0: nums[left],nums[right]=nums[right],nums[left] left += 1 right += 1 盛水最多容器 给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 返回容器可以储存的最大水量。 **说明：**你不能倾斜容器。 12345678910111213class Solution: def maxArea(self, height: List[int]) -&gt; int: left = ans = 0 right = len(height) - 1 while left &lt; right : if height[left] &lt; height[right]: ans = max(ans,height[left]*(right-left)) left += 1 else: ans = max(ans,height[right]*(right-left)) right -= 1 return ans 三数之和 给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。 **注意：**答案中不可以包含重复的三元组。 123456789101112131415161718192021222324252627282930class Solution: def threeSum(self, nums: List[int]) -&gt; List[List[int]]: nums.sort() ans = [] n = len(nums) for i in range(n - 2): x = nums[i] if i &gt; 0 and x == nums[i - 1]: # 跳过重复数字 continue if x + nums[i + 1] + nums[i + 2] &gt; 0: # 优化一 break if x + nums[-2] + nums[-1] &lt; 0: # 优化二 continue j = i + 1 k = n - 1 while j &lt; k: s = x + nums[j] + nums[k] if s &gt; 0: k -= 1 elif s &lt; 0: j += 1 else: # 三数之和为 0 ans.append([x, nums[j], nums[k]]) j += 1 while j &lt; k and nums[j] == nums[j - 1]: # 跳过重复数字 j += 1 k -= 1 while k &gt; j and nums[k] == nums[k + 1]: # 跳过重复数字 k -= 1 return ans 接雨水 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 123456789101112131415161718192021222324class Solution: def trap(self, height: List[int]) -&gt; int: if not height: return 0 left, right = 0, len(height) - 1 # 两个指针 left_max, right_max = height[left], height[right] # 左右最大边界 ans = 0 # 结果累加器 while left &lt; right: if height[left] &lt; height[right]: left += 1 if height[left] &gt; left_max: left_max = height[left] else: ans += left_max - height[left] else: right -= 1 if height[right] &gt; right_max: right_max = height[right] else: ans += right_max - height[right] return ans 滑动窗口 无重复字符的最长字串 给定一个字符串 s ，请你找出其中不含有重复字符的 最长 子串 的长度。 123456789101112131415class Solution: def lengthOfLongestSubstring(self, s: str) -&gt; int: d = &#123;&#125; res = 0 start = -1 for index, c in enumerate(s): if c not in d: res = max(res, index-start) else: if d[c] &gt; start: start = d[c] else: res = max(res, index-start) d[c] = index return res 找到字符串中所有字母异位词 给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。 示例 1: 12345输入: s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;输出: [0,6]解释:起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的异位词。起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的异位词。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution: def findAnagrams(self, s: str, p: str) -&gt; List[int]: # 获取字符串 s 和 p 的长度 s_len, p_len = len(s), len(p) # 如果 s 的长度小于 p 的长度，直接返回空列表，因为无法形成异位词子串 if s_len &lt; p_len: return [] # 初始化结果列表，用于存储异位词子串的起始索引 ans = [] # 初始化两个长度为 26 的数组，用于统计字符频率 # s_count 用于统计当前窗口内的字符频率 # p_count 用于统计字符串 p 的字符频率 s_count = [0] * 26 p_count = [0] * 26 # 遍历 p 的前 p_len 个字符，初始化 s_count 和 p_count for i in range(p_len): # 统计 s 的前 p_len 个字符的频率 s_count[ord(s[i]) - 97] += 1 # 统计 p 的前 p_len 个字符的频率 p_count[ord(p[i]) - 97] += 1 # 如果初始窗口的字符频率与 p 的字符频率相等，说明第一个窗口就是异位词 # 将起始索引 0 加入结果列表 if s_count == p_count: ans.append(0) # 滑动窗口遍历 s 的剩余部分 for i in range(s_len - p_len): # 窗口滑动时，移除窗口左侧的字符，将其频率减 1 s_count[ord(s[i]) - 97] -= 1 # 添加窗口右侧的新字符，将其频率加 1 s_count[ord(s[i + p_len]) - 97] += 1 # 检查当前窗口的字符频率是否与 p 的字符频率相等 # 如果相等，说明当前窗口是异位词，将起始索引（i + 1）加入结果列表 if s_count == p_count: ans.append(i + 1) # 返回结果列表 return ans 子串 和为 k的子数组 给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。 子数组是数组中元素的连续非空序列。 12345678910111213141516class Solution: def subarraySum(self, nums: List[int], k: int) -&gt; int: count, pre = 0, 0 hashmap = dict(&#123;0:1&#125;) for num in nums: pre += num if pre - k in hashmap: count += hashmap[pre - k] if pre in hashmap: hashmap[pre] += 1 else: hashmap[pre] = 1 return count 滑动窗口最大值 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。 返回 滑动窗口中的最大值 12345678910111213141516171819202122232425262728293031323334353637383940class Solution: def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]: # 如果数组为空或窗口大小为0，直接返回空列表 if not nums or k == 0: return [] # 使用双端队列来存储当前窗口中的元素索引 deque = collections.deque() # 未形成窗口时的处理 for i in range(k): # 如果队列不为空且队列末尾的元素小于当前元素，则弹出队列末尾的元素 # 这样可以保证队列中的元素是递减的 while deque and deque[-1] &lt; nums[i]: deque.pop() # 将当前元素加入队列 deque.append(nums[i]) # 将当前窗口的最大值（即队列的第一个元素）加入结果列表 res = [deque[0]] # 形成窗口后的处理 for i in range(k, len(nums)): # 如果队列的第一个元素是窗口最左边的元素，则将其从队列中移除 # 因为这个元素即将离开窗口 if deque[0] == nums[i - k]: deque.popleft() # 如果队列不为空且队列末尾的元素小于当前元素，则弹出队列末尾的元素 # 这样可以保证队列中的元素是递减的 while deque and deque[-1] &lt; nums[i]: deque.pop() # 将当前元素加入队列 deque.append(nums[i]) # 将当前窗口的最大值（即队列的第一个元素）加入结果列表 res.append(deque[0]) # 返回结果列表 return res 最小覆盖字串 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 &quot;&quot; 。 1234567891011121314151617181920212223class Solution: def minWindow(self, s: str, t: str) -&gt; str: ans_left, ans_right = -1, len(s) cnt = defaultdict(int) # 比 Counter 更快 for c in t: cnt[c] += 1 less = len(cnt) left = 0 for right, c in enumerate(s): cnt[c] -= 1 if cnt[c] == 0: less -= 1 while less == 0: if right - left &lt; ans_right - ans_left: ans_left, ans_right = left, right x = s[left] if cnt[x] == 0: less += 1 cnt[x] += 1 left += 1 return &quot;&quot; if ans_left &lt; 0 else s[ans_left: ans_right + 1] 普通数组 最大子数组和 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 子数组是数组中的一个连续部分。 123456789101112class Solution: def maxSubArray(self, nums: List[int]) -&gt; int: count = 0 result = -99999 for i in nums: count += i if count &gt; result: result = count if count &lt; 0: count = 0 return result 合并区间 以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。 1234567891011121314class Solution: def merge(self, intervals: List[List[int]]) -&gt; List[List[int]]: intervals.sort(key=lambda x: x[0]) merged = [] for interval in intervals: # 如果列表为空，或者当前区间与上一区间不重合，直接添加 if not merged or merged[-1][1] &lt; interval[0]: merged.append(interval) else: # 否则的话，我们就可以与上一区间进行合并 merged[-1][1] = max(merged[-1][1], interval[1]) return merged 轮转数组 给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。 1234567891011121314class Solution: def rotate(self, nums: List[int], k: int) -&gt; None: def reverse(i: int, j: int) -&gt; None: while i &lt; j: nums[i], nums[j] = nums[j], nums[i] i += 1 j -= 1 n = len(nums) k %= n # 轮转 k 次等于轮转 k % n 次 reverse(0, n - 1) reverse(0, k - 1) reverse(k, n - 1) 除自身以外数组的乘积 给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。 题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在 32 位 整数范围内。 请 **不要使用除法，**且在 O(n) 时间复杂度内完成此题。 12345678910111213import mathclass Solution: def productExceptSelf(self, nums: List[int]) -&gt; List[int]: # 如果有0，可以简化运算 total = math.prod(nums) ans = [] for i, num in enumerate(nums): if num != 0: ans.append(total // num) else: ans.append(math.prod(nums[:i] + nums[i+1:])) return ans 缺失的第一个正数 给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。 请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。 12345678910111213class Solution: def firstMissingPositive(self, nums: List[int]) -&gt; int: N = len(nums) num_list = [0]*(N+1) for num in nums: if num&gt;N or num&lt;=0: continue num_list[num] = 1 for i in range(1,N+1): if num_list[i] == 0: return i return N+1 矩阵 矩阵置零 给定一个 *m* x *n* 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法**。** 123456789101112131415161718class Solution: def setZeroes(self, matrix: List[List[int]]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify matrix in-place instead. &quot;&quot;&quot; m, n = len(matrix), len(matrix[0]) row = [False] * m col = [False] * n for i in range(m): for j in range(n): if matrix[i][j] == 0: row[i], col[j] = True, True for i in range(m): for j in range(n): if row[i] or col[j]: matrix[i][j] = 0 螺旋矩阵 给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。 1234567891011121314151617class Solution: def spiralOrder(self, matrix: List[List[int]]) -&gt; List[int]: result = [] while matrix : result.extend(matrix.pop(0)) if matrix : if matrix[0]: for i in range(len(matrix)): result.append(matrix[i].pop()) if matrix : k = matrix.pop() result.extend(k[::-1]) if matrix : if matrix[0]: for i in range(len(matrix)-1,-1,-1): result.append(matrix[i].pop(0)) return result 旋转图像 给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。 你必须在** 原地** 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。 12345678910class Solution: def rotate(self, matrix: List[List[int]]) -&gt; None: n = len(matrix) # 深拷贝 matrix -&gt; tmp tmp = copy.deepcopy(matrix) # 根据元素旋转公式，遍历修改原矩阵 matrix 的各元素 for i in range(n): for j in range(n): matrix[j][n - 1 - i] = tmp[i][j] 链表 相交链表 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。 1234567class Solution: def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode: A, B = headA, headB while A != B: A = A.next if A else headB B = B.next if B else headA return A 反转链表 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 1234567891011121314# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]: cur ,pre = head, None while cur: temp = cur.next cur.next = pre pre = cur cur = temp return pre 二叉树 二叉树的中序遍历 给定一个二叉树的根节点 root ，返回 它的 中序 遍历 1234567891011121314151617181920class Solution: def inorderTraversal(self, root: TreeNode) -&gt; List[int]: # 初始化栈和结果列表 stack, rst = [root], [] # stack 用于模拟递归调用栈，rst 用于存储遍历结果 # 开始遍历 while stack: # 当栈不为空时，继续遍历 i = stack.pop() # 弹出栈顶元素 # 如果当前元素是 TreeNode 类型 if isinstance(i, TreeNode): # 将右子树、当前节点的值、左子树按顺序压入栈 stack.extend([i.right, i.val, i.left]) # 注意顺序：右 -&gt; 值 -&gt; 左 # 如果当前元素是整数类型（节点的值） elif isinstance(i, int): rst.append(i) # 将节点的值加入结果列表 # 返回结果列表 return rst 二叉树的最大深度 给定一个二叉树 root ，返回其最大深度。二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。 1234class Solution: def maxDepth(self, root: Optional[TreeNode]) -&gt; int: if not root: return 0 return max(self.maxDepth(root.left),self.maxDepth(root.right))+1 图论 岛屿数量 给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。此外，你可以假设该网格的四条边均被水包围。 1234567输入：grid = [ [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]]输出：3 1234567891011121314151617181920212223242526272829303132333435class Solution: def numIslands(self, grid: List[List[str]]) -&gt; int: n_l = 0 # 初始化岛屿数量为 0 # 遍历整个网格 for i in range(len(grid)): for j in range(len(grid[0])): # 如果当前单元格是陆地（&#x27;1&#x27;），则开始 DFS 遍历 if grid[i][j] == &#x27;1&#x27;: self.landpaint(grid, i, j) # 标记当前岛屿的所有陆地 n_l += 1 # 岛屿数量加 1 # 返回岛屿数量 return n_l # DFS 函数：标记当前岛屿的所有陆地 def landpaint(self, grid, x, y): # 将当前陆地标记为已访问（&#x27;2&#x27;） grid[x][y] = &#x27;2&#x27; # 检查下方单元格 if x + 1 &lt; len(grid) and grid[x + 1][y] == &#x27;1&#x27;: self.landpaint(grid, x + 1, y) # 检查右方单元格 if y + 1 &lt; len(grid[0]) and grid[x][y + 1] == &#x27;1&#x27;: self.landpaint(grid, x, y + 1) # 检查上方单元格 if x - 1 &gt;= 0 and grid[x - 1][y] == &#x27;1&#x27;: self.landpaint(grid, x - 1, y) # 检查左方单元格 if y - 1 &gt;= 0 and grid[x][y - 1] == &#x27;1&#x27;: self.landpaint(grid, x, y - 1) 腐烂的橘子 在给定的 m x n 网格 grid 中，每个单元格可以有以下三个值之一：值 0 代表空单元格；值 1 代表新鲜橘子；值 2 代表腐烂的橘子。 每分钟，腐烂的橘子 周围 4 个方向上相邻 的新鲜橘子都会腐烂。返回 直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1 。 123456789101112131415161718192021222324class Solution: def orangesRotting(self, grid: List[List[int]]) -&gt; int: m,n=len(grid),len(grid[0]) fresh=0 q=[] for i,row in enumerate(grid): for j,x in enumerate(row): if x==1: fresh+=1 elif x==2: q.append((i,j)) ans=0 while q and fresh: ans+=1 tmp=q q=[] for x,y in tmp: for i, j in (x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1): # 四方向 if 0 &lt;= i &lt; m and 0 &lt;= j &lt; n and grid[i][j] == 1: # 新鲜橘子 fresh -= 1 grid[i][j] = 2 # 变成腐烂橘子 q.append((i, j)) return -1 if fresh else ans 回溯 全排列 给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。 1234567891011121314151617181920212223242526272829303132333435363738class Solution: def permute(self, nums: List[int]) -&gt; List[List[int]]: # 定义 DFS 函数 def dfs(nums, size, depth, path, used, res): # 如果当前深度等于数组大小，说明找到一个完整排列 if depth == size: res.append(path[:]) # 将当前排列加入结果列表 return # 遍历数组中的每个元素 for i in range(size): # 检查当前元素是否已经被使用过 if not used[i]: # 标记当前元素为已使用 used[i] = True # 将当前元素加入路径 path.append(nums[i]) # 递归调用 DFS，继续生成下一个位置的元素 dfs(nums, size, depth + 1, path, used, res) # 回溯：移除当前元素，恢复状态 path.pop() used[i] = False # 获取数组的长度 size = len(nums) # 如果数组为空，直接返回空列表 if size == 0: return [] # 初始化 used 数组和结果列表 used = [False] * size # 记录元素是否被使用 res = [] # 结果列表，用于存储所有排列 # 调用 DFS 函数，开始生成排列 dfs(nums, size, 0, [], used, res) # 返回结果列表 return res 子集 给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。 1234567891011121314151617181920class Solution: def subsets(self, nums: List[int]) -&gt; List[List[int]]: # 初始化结果列表 res = [] # 获取数组的长度 n = len(nums) # 定义回溯函数 def helper(i, tmp): # 将当前子集加入结果列表 res.append(tmp) # 遍历数组，生成新的子集 for j in range(i, n): # 递归调用，更新子集 helper(j + 1, tmp + [nums[j]]) # 调用回溯函数，从索引 0 和空子集开始 helper(0, []) # 返回结果列表 return res 二分查找 搜索插入位置 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 1234567891011121314class Solution: def searchInsert(self, nums: List[int], target: int) -&gt; int: left, right = 0, len(nums) - 1 while left &lt;= right: mid = (left + right) // 2 if nums[mid] == target: return mid elif nums[mid] &lt; target: left = mid + 1 else: right = mid - 1 return left # left 位置即为插入位置 搜索二维矩阵 给你一个满足下述两条属性的 m x n 整数矩阵：每行中的整数从左到右按非严格递增顺序排列。每行的第一个整数大于前一行的最后一个整数。给你一个整数 target ，如果 target 在矩阵中，返回 true ；否则，返回 false 。 12345678910111213141516171819202122232425class Solution: def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool: # 获取矩阵的行数和列数 m, n = len(matrix), len(matrix[0]) # 初始化二分查找的左右边界 l, r = 0, m * n # 将二维矩阵视为一维数组 # 开始二分查找 while l &lt; r: # 计算中间位置 mid = (l + r) &gt;&gt; 1 # 等价于 (l + r) // 2 # 将一维索引 mid 转换为二维索引 x = matrix[mid // n][mid % n] # 判断中间元素与目标值的关系 if x == target: return True # 找到目标值，返回 True if x &lt; target: l = mid + 1 # 目标值在右半部分 else: r = mid # 目标值在左半部分 # 未找到目标值，返回 False return False 栈 有效的括号 给定一个只包括 '('，')'，'&#123;'，'&#125;'，'['，']' 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 每个右括号都有一个对应的相同类型的左括号。 1234567891011class Solution: def isValid(self, s: str) -&gt; bool: dic = &#123;&#x27;)&#x27;:&#x27;(&#x27;,&#x27;]&#x27;:&#x27;[&#x27;,&#x27;&#125;&#x27;:&#x27;&#123;&#x27;&#125; stack = [] for i in s: if stack and i in dic: if stack[-1] == dic[i]: stack.pop() else: return False else: stack.append(i) return not stack 最小栈 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。实现 MinStack 类: 12345- `MinStack()` 初始化堆栈对象。- `void push(int val)` 将元素val推入堆栈。- `void pop()` 删除堆栈顶部的元素。- `int top()` 获取堆栈顶部的元素。- `int getMin()` 获取堆栈中的最小元素。 12345678910111213141516171819class MinStack: def __init__(self): self.stack = [] self.min_stack = [math.inf] def push(self, val: int) -&gt; None: self.stack.append(val) self.min_stack.append(min(val,self.min_stack[-1])) def pop(self) -&gt; None: self.stack.pop() self.min_stack.pop() def top(self) -&gt; int: return self.stack[-1] def getMin(self) -&gt; int: return self.min_stack[-1] 堆 数组中的第k个最大元素 给定整数数组 nums 和整数 k，请返回数组中第 **k** 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。 1234567891011121314151617181920212223242526272829303132333435class Solution: def findKthLargest(self, nums: List[int], k: int) -&gt; int: # 定义快速选择函数 def quick_select(nums, k): # 随机选择一个基准元素（pivot） pivot = random.choice(nums) # 初始化三个列表/变量： # - big：存储比 pivot 大的元素 # - equal：记录与 pivot 相等的元素个数 # - small：存储比 pivot 小的元素 big, equal, small = [], 0, [] # 遍历数组，将元素分类 for num in nums: if num &gt; pivot: big.append(num) # 比 pivot 大的元素放入 big elif num &lt; pivot: small.append(num) # 比 pivot 小的元素放入 small else: equal += 1 # 与 pivot 相等的元素计数 # 如果 k 小于等于 big 的长度，说明第 k 个最大元素在 big 中 if k &lt;= len(big): return quick_select(big, k) # 递归在 big 中查找 # 如果 k 大于 big 和 equal 的总长度，说明第 k 个最大元素在 small 中 if len(big) + equal &lt; k: return quick_select(small, k - len(big) - equal) # 递归在 small 中查找 # 如果以上条件都不满足，说明第 k 个最大元素就是 pivot return pivot # 调用快速选择函数，返回第 k 个最大元素 return quick_select(nums, k) 前k个高频元素 给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。 1234class Solution: def topKFrequent(self, nums: List[int], k: int) -&gt; List[int]: count = collections.Counter(nums) return [item[0] for item in count.most_common(k)] 贪心算法 买卖股票的最佳时期 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。 123456789101112class Solution: def maxProfit(self, prices: List[int]) -&gt; int: profit = 0 low=high=prices[0] for p in prices: if p &lt; low: #对每个新的最低点来说，之前的最高点不再有效，需要结利 profit = max(profit, high-low) low=high=p elif p &gt; high: high=p profit = max(profit, high-low) return profit 跳跃游戏 给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。 123456789class Solution: def canJump(self, nums: List[int]) -&gt; bool: if not nums :return False maxlong,n= 0,len(nums) for i in range(n): if i&gt;maxlong: return False maxlong= max(i+nums[i],maxlong) return True 动态规划 爬楼梯 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 123456class Solution: def climbStairs(self, n: int) -&gt; int: a, b = 1, 1 for _ in range(n - 1): a, b = b, a + b return b 杨辉三角 给定一个非负整数 *numRows，*生成「杨辉三角」的前 numRows 行。 12345678class Solution: def generate(self, numRows: int) -&gt; List[List[int]]: c = [[1] * (i + 1) for i in range(numRows)] for i in range(2, numRows): for j in range(1, i): # 左上方的数 + 正上方的数 c[i][j] = c[i - 1][j - 1] + c[i - 1][j] return c 多维动态规划 不同路径 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。问总共有多少条不同的路径？ 1234567class Solution: def uniquePaths(self, m: int, n: int) -&gt; int: f = [1] * n for i in range(1, m): for j in range(1, n): f[j] += f[j - 1] return f[n - 1] 最小路径和 给定一个包含非负整数的 *m* x *n* 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。**说明：**每次只能向下或者向右移动一步。 12345678910111213141516171819202122232425262728293031class Solution: def minPathSum(self, grid: List[List[int]]) -&gt; int: # 如果网格为空，返回 0 if not grid or not grid[0]: return 0 # 获取网格的行数和列数 rows, columns = len(grid), len(grid[0]) # 初始化动态规划数组 dp dp = [[0] * columns for _ in range(rows)] # 起点的最小路径和就是 grid[0][0] dp[0][0] = grid[0][0] # 初始化第一列的最小路径和 for i in range(1, rows): dp[i][0] = dp[i - 1][0] + grid[i][0] # 初始化第一行的最小路径和 for j in range(1, columns): dp[0][j] = dp[0][j - 1] + grid[0][j] # 填充 dp 数组的其余部分 for i in range(1, rows): for j in range(1, columns): # 当前点的最小路径和等于上方或左方的最小路径和加上当前点的值 dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] # 返回右下角的最小路径和 return dp[rows - 1][columns - 1]","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"Python 基础","slug":"Python-基础","date":"2025-02-04T08:29:02.000Z","updated":"2025-02-04T09:51:57.109Z","comments":true,"path":"2025/02/04/Python-基础/","permalink":"http://example.com/2025/02/04/Python-%E5%9F%BA%E7%A1%80/","excerpt":"","text":"关键字 yield yield 是 Python 中的一个关键字，用于定义生成器函数（generator function）。生成器函数是一种特殊的函数，它可以逐步产生值，而不是一次性返回所有结果。yield 的作用是将函数变成一个生成器，每次调用生成器的 __next__() 方法时，函数会执行到 yield 语句并返回一个值，然后暂停执行，直到下一次调用。 yield 的基本用法 示例 1：简单的生成器函数 12345678910def simple_generator(): yield 1 yield 2 yield 3# 使用生成器gen = simple_generator()print(next(gen)) # 输出: 1print(next(gen)) # 输出: 2print(next(gen)) # 输出: 3 每次调用 next(gen)，函数会从上次暂停的地方继续执行，直到遇到下一个 yield。 当没有更多的值可以生成时，会抛出 StopIteration 异常。 示例 2：使用 for 循环遍历生成器 12345678def simple_generator(): yield 1 yield 2 yield 3# 使用 for 循环遍历生成器for value in simple_generator(): print(value) 输出： 123123 for 循环会自动处理 StopIteration 异常，因此不需要手动调用 next()。 yield 的优势 惰性求值： 生成器不会一次性生成所有值，而是按需生成，节省内存。 适合处理大量数据或无限序列。 代码简洁： 使用 yield 可以避免手动实现迭代器协议（__iter__ 和 __next__）。 状态保持： 生成器函数会记住上次执行的状态，下次调用时从上次暂停的地方继续。 yield 的高级用法 示例 3：生成无限序列 123456789101112def infinite_sequence(): num = 0 while True: yield num num += 1# 使用生成器gen = infinite_sequence()print(next(gen)) # 输出: 0print(next(gen)) # 输出: 1print(next(gen)) # 输出: 2# 可以无限调用 next(gen) 这个生成器会无限生成递增的整数。 示例 4：使用 yield 实现斐波那契数列 12345678910def fibonacci(): a, b = 0, 1 while True: yield a a, b = b, a + b# 使用生成器gen = fibonacci()for _ in range(10): print(next(gen)) 输出： 123456789100112358132134 这个生成器会无限生成斐波那契数列的值。 示例 5：yield from（委托生成器） yield from 用于将生成器的控制权委托给另一个生成器。 123456789101112def sub_generator(): yield 1 yield 2def main_generator(): yield &#x27;Start&#x27; yield from sub_generator() yield &#x27;End&#x27;# 使用生成器for value in main_generator(): print(value) 输出： 1234Start12End yield from 可以简化生成器的嵌套调用。 yield 与 return 的区别 特性 yield return 返回值 每次生成一个值，函数暂停 返回一个值，函数结束 状态保持 函数状态会被保存 函数状态不会被保存 适用场景 生成器函数 普通函数 内存占用 惰性求值，节省内存 一次性返回所有结果，占用内存 总结 yield 是 Python 中实现生成器的关键，适合处理大量数据或需要惰性求值的场景。 生成器函数通过 yield 逐步返回值，并保持函数状态，直到生成所有值。 yield from 可以简化生成器的嵌套调用。 assert assert 是 Python 中的一个关键字，用于调试和测试代码。它的作用是检查某个条件是否为真，如果条件为假，则会触发 AssertionError 异常。assert 通常用于确保程序在某个关键点的状态符合预期，如果不符合，则立即停止程序并抛出错误。 assert 的基本语法 1assert condition, message condition：需要检查的条件表达式。如果为 True，程序继续执行；如果为 False，则抛出 AssertionError。 message（可选）：当条件为 False 时，抛出的异常信息。如果未提供，则使用默认的 AssertionError。 assert 的作用 调试工具： 用于在开发阶段检查代码逻辑是否正确。 如果条件不满足，程序会立即停止，方便定位问题。 测试工具： 在单元测试中，用于验证函数的输出是否符合预期。 文档工具： 通过 assert 可以清晰地表达代码的预期行为。 assert 的示例 示例 1：简单的 assert 用法 12x = 10assert x == 10, &quot;x 应该等于 10&quot; 如果 x == 10 为 True，程序继续执行。 如果 x == 10 为 False，则抛出 AssertionError，并显示消息 &quot;x 应该等于 10&quot;。 示例 2：检查函数返回值 123456def divide(a, b): assert b != 0, &quot;除数不能为 0&quot; return a / bprint(divide(10, 2)) # 输出: 5.0print(divide(10, 0)) # 触发 AssertionError: 除数不能为 0 在函数中使用 assert 可以确保输入参数的有效性。 示例 3：检查列表是否非空 1234567def process_list(items): assert len(items) &gt; 0, &quot;列表不能为空&quot; for item in items: print(item)process_list([1, 2, 3]) # 正常执行process_list([]) # 触发 AssertionError: 列表不能为空 assert 的注意事项 不要用于数据验证： assert 主要用于调试和测试，不应该用于检查用户输入或外部数据。 因为 Python 可以通过 -O（优化模式）运行，此时所有的 assert 语句会被忽略。 避免副作用： assert 的条件表达式不应该包含有副作用的操作（如修改全局变量、调用函数等），因为在优化模式下这些操作会被跳过。 替代方案： 对于数据验证或输入检查，应该使用 if 语句并手动抛出异常（如 ValueError、TypeError 等）。 assert 与 if 的区别 特性 assert if 用途 调试和测试 通用条件判断 触发异常 触发 AssertionError 需要手动抛出异常 优化模式 在 -O 模式下会被忽略 不受影响 适用场景 检查内部逻辑是否正确 检查用户输入或外部数据 assert 的优化模式 Python 支持以优化模式运行脚本，此时所有的 assert 语句会被忽略。可以通过以下命令启用优化模式： 1python -O script.py 在优化模式下，assert 语句不会被执行，因此不能依赖它来实现关键逻辑。 总结 assert 是一个强大的调试工具，用于检查代码逻辑是否符合预期。 它适合在开发和测试阶段使用，但不适合用于生产环境中的数据验证。 如果需要更健壮的输入检查，应该使用 if 语句并手动抛出异常。","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]}],"categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"测试","slug":"测试","permalink":"http://example.com/tags/%E6%B5%8B%E8%AF%95/"},{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]}