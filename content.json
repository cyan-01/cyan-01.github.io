{"meta":{"title":"听风的博客","subtitle":"","description":"","author":"听风","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2025-01-25T09:32:33.000Z","updated":"2025-01-25T09:34:16.956Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2025-01-25T09:30:32.000Z","updated":"2025-01-25T09:34:39.972Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"link","date":"2025-01-25T09:31:31.000Z","updated":"2025-01-25T09:34:31.711Z","comments":true,"path":"link/index.html","permalink":"http://example.com/link/index.html","excerpt":"","text":""},{"title":"tags","date":"2025-01-25T09:27:43.000Z","updated":"2025-01-25T09:35:44.869Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"渗透测试","slug":"渗透测试","date":"2025-04-30T12:41:44.000Z","updated":"2025-05-11T11:18:23.392Z","comments":true,"path":"2025/04/30/渗透测试/","permalink":"http://example.com/2025/04/30/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/","excerpt":"","text":"123456789网络适配器-&gt;WLAN点下拉geng&#x27;d-&gt;共享clash verge: 打开系统代理和Tun 端口号7897ip: VMnet8的IPv4地址git 全局代理： 添加：git config --global http.proxy http://IP:7897 git config --global https.proxy http://IP:7897 取消：git config --global --unset http.proxy git config --global --unset https.proxy 查看：git config --global -l 信息收集 需收集的信息： 域名信息(whois.、备案信息、子域名) 服务器信息（端口、服务、真实IP) 网站信息（网站架构、操作系统、中间件、数据库、编程语言、指纹信息、W八F、敏感目录、敏感文件、源码泄露、旁站、C段) 管理员信息（姓名、职务、生日、联系电话、邮件地址） 域名信息 whois 域名查询whois 根据已知域名反查,获取:注册人邮箱;注册人姓名;注册人手机;注册更新时间等信息 脚本 12cd yjtoolspython whois_check.py 命令行 1whois [域名] 接口 https://whois.aliyun.com/ https://www.whois365.com/cn/ http://whois.chinaz.com/ whois反查域名 根据已知域名WHOIS中的信息来反查其它与此信息相同的域名列表,但可能是代理商 接口 https://whois.chinaz.com/ 查询到的邮箱名前几位隐蔽 https://whois.aizhan.com/reverse-whois/ 备案号 网页最下方通常有备案号,通过备案号查询该公司旗下其他域名或资产 接口 https://beian.miit.gov.cn/ https://icp.chinaz.com/ https://icp.chinaz.com/ 子域名 google hacking 语法 字符 注释 例子 注释 intext 寻找正文中含有关 键字的网页 intext：后台登录 将只返回正文中包含“后台登录”的网页 intitle 寻找标题中含有关 键字的网页 intitle：后台登录 将只返回标题中包含“后台 登录”的网页，intitle：后台登录密码将返回标题中 包含“后台登录而正文中包 含密码的网页 allinitle 用法和intitle类 似，只不过可以指 定多个词 alltitle：后台登录 管理员 将返回标题中包含“后台登录”和“管理员”的网页 inurl 将返回ur中含有关 键词的网页 inurl:Login 将返回ur1中含有Login 的网页 allinurl 用法和inurl类似， 只不过可以指定多 个词 n allinurl:Login admin 将返回ur1中含有Login 和admin的网页 site 指定访问的站点 site:baidu.com inurl:Login 将只在baidu.com中查找 urI中含有Login的网页 filetype 指定访问的文件类 型 site:baidu.com filetype:pdf 将只返回baidu.com站点 上文件类型为pdf的网页 link 指定链接的网页 link:www.baidu.com 将返回所有包含指向 www.baidu.com的网页 related 相似类型的网页 related:www.xjtu.edu.cn 将返回与 www.xjtu.edu.cn相似的 页面，相似指的是网页的布局相似 info 返回站点的指定信 意 info:www.baidu.com corn 将返回百度的一些信息 define 返回某个词语的定 发 define:Hacker 将返回关于 Hacker的定义 cache 网页快照，谷歌将 返回给你它存储下 莱的房使货 cache:www.hackingspirits.com guest 将返回指定网站的缓存，并 且正文中含有guest 示例 语法 注释 inurl://admin/login.php 查找管理员登录页面 inurl:/phpmyadmin/index.php 查找后台数据库管理页面 site:baidu.com inurl:Login 只在baidu.com中查找url 中含有Login的网页 site:baidu.com filetype:pdf ed 只返回baidu.com站点上 文件类型为pdf的网页 link:www.baidu.com 返回所有包含指向 www.baidu.com的网页 related:www.1lhc.edu.cn 返回与 www.11hc.edu.cn网页 布局相似的页面 site:xx.comintext:管理site:xx.cominurl:login site:xx.comintitle:后台 查找网站后台 site:xx.com filetype:php site:xx.com filetype:asp site:xx.com filetype:jsp site:xx.com filetype:aspx 查看服务器使用的程序 site:xx.com inurl:file site:xx.com inurl:load 查看上传漏洞 Index of目录发现 1234567891011index of /adminindex of /passwdindex of /passwordindex of /mail&quot;index of /&quot; +passwd&quot;index of /&quot; +password.txt&quot;index of /&quot; +.htaccess&quot;index of /root&quot;&quot;index of /cgi-bin&quot;&quot;index of /logs&quot;&quot;index of /config&quot; 子域名查询 1site:[域名] 接口查询 https://dnsdumpster.com/ https://www.dnsgrep.cn/ https://developers.virustotal.com/reference/domains-relationships http://tool.chinaz.com/subdomain https://www.nmmapper.com/sys/tools/subdomainfinder/ 网络空间测绘工具 工具名称 网址 语法 FOFA https://fofa.info/ domain=“[域名]” 鹰图 https://hunter.qianxin.com/ domain=“[域名]” 钟馗之眼 https://www.zoomeye.org/ site:“[域名]” shodan https://www.shodan.io/ hostname:[域名] SSL证书查询 https://crt.sh/ https://developers.facebook.com/tools/ct/search/ JS文件发现 脚本 12cd JSFinderpython JSFinder.py -u http://[域名] 聚合工具 OneForAll 12345conda active py39\\cd OneForAll/python oneforall.py --target [域名] run(谷歌联网)(查看 ./results/[域名].csv) 爆破 子域名挖掘机(主机D://渗透) 服务器信息 IP收集 IP反查域名 http://stool.chinaz.com/same https://tools.ipip.net/ipdomain.php https://www.dnsgrep.cn/ https://site.ip138.com/ 域名查IP http://ip.tool.chinaz.com/ https://ipchaxun.com/ https://site.ip138.com/ C段存活主机探测 先旁注 后C段 查找与目标服务器P处于同一个C段的服务器IP 域名显示运营商是阿里云不是xxx机房之类，不用查 nmap 只能查出有没有开机 12nmap -sP www.example.com/24nmap -sP 192.168.1.* 脚本 1./TxPortMap -i www.example.com/24 -p 80 CDN 多地ping 123http://ping.chinaz.com/https://ping.aizhan.com/http://www.webkaka.com/Ping.aspx 用各种多地ping的服务，查看对应P地址是否唯一 国外访问 https://ping.sx/ping 有些网站设置CDN可能没有把国外的访问包含进去，所以可以这么绕过 查询子域名IP MX记录邮件服务 ​ MX记录是一种常见的查找IP的方式。如果网站在与wb相同的服务器和IP上托管自己的邮件服务器，那么原始服务器P将在MX记录中。 查询历史DNS记录 https://viewdns.info/iphistory/ https://www.ip138.com/ 真实ip可能是买DNS的前一个 端口收集 一个电脑最多65525个端口,常见端口总结 https://edu.yijinglab.com/post/280 nmap 123456789101112131415161718192021222324252627282930nmap -A -T4 192.168.1.1A：全面扫描\\综合扫描T4：扫描速度，共有6级，T0-T5不加端口则扫描默认端口，1-1024 + nmap-service单一主机扫描：nmap 192.168.1.2子网扫描：nmap 192.168.1.1/24多主机扫描：nmap 192.168.1.1 192.168.1.10主机范围扫描：nmap 192.168.1.1-100IP地址列表扫描：nmap –iL target.txt扫描除指定IP外的所有子网主机：nmap 192.168.1.1/24 --exclude 192.168.1.1扫描除文件中IP外的子网主机：nmap 192.168.1.1/24 --excludefile xxx.txt扫描特定主机上的80,21,23端口：nmap –p 80,21,23 192.168.1.1 12345678910nmap -sS -v -T4 -Pn -p 0-65535 -oN FullTCP -iL liveHosts.txt-sS：SYN扫描,又称为半开放扫描，它不打开一个完全的TCP连接，执行得很快，效率高（一个完整的tcp连接需要3次握手，而-sS选项不需要3次握手）优点：Nmap发送SYN包到远程主机，但是它不会产生任何会话，目标主机几乎不会把连接记入系统日志。（防止对方判断为扫描攻击），扫描速度快，效率高，在工作中使用频率最高缺点：它需要root/administrator权限执行-Pn：扫描之前不需要用ping命令，有些防火墙禁止ping命令。可以使用此选项进行扫描-iL：导入需要扫描的列表 网站信息 操作系统 ping判断：windows的TTL值一般为128，Linux则为64。 TTL大于100的一般为windows,几十的一般为linux。 nmap -o [ip/域名] windows大小写不敏感，1inux则区分大小写 网站服务、容器类型 F12查看响应头Server字段 whatweb 1whateweb -v -a 3 [ip] wappalyzer插件 apache,nginx,tomcat,IIS 通过容器类型、版本可考虑对应容器存在的漏洞（解析漏洞） 脚本类型 1.php 2.jsp 3.asp/aspx 4.python 知道是什么语言才可以针对性的进行文件扫描、文件上传 数据库类型 https://edu.yijinglab.com/post/298 CMS识别 内容管理系统，用于网站内容文章管理。常见CMS:WordPress、Joomla、.Drupal、dedecms(织梦)、Discuz、phpcms等。 CMS检测识别工具 CMSeeK: 123cd CMSeekpython TPscan.py1 joomscan识别Joomla： 1joomscan -u http://192.168.233.187/ wpscan识别WordPress： 1234567891011121314151617181、刺探基础信息：wpscan --url http://www.example.com2、猜解后台用户名wpscan --url http://www.example.com --enumerate u3、使用字典暴破用户名admin的密码wpscan --url http://www.example.com -P password.txt -U admin 4、扫描插件wpscan --url http://www.example.com --enumerate p5、扫描易受攻击的插件wpscan --url http://www.example.com --enumerate vp6、扫描所有插件wpscan --url http://www.example.com --enumerate ap TPscan识别thinkphp： 12cd TPscanpython TPscan.py 敏感文件 .git泄漏 若存在.git泄漏，打开githack网站 https://githack.com/ 在网站上方的文本框中输入目标Git存储库的URL，例如https://example.com/.git/ 点击Generate link按钮生成可下载存储库的链接。 将生成的链接复制到浏览器地址栏中并打开。 从打开的页面中下载压缩的Git存储库文件。 .svn泄漏 1234cd SvnExploitpython SvnExploit.py -u http://192.168.27.128/.svn# 下载python SvnExploit.py -u http://192.168.27.128/.svn --dump 目录扫描 dirsearch -u [url] dir [url] /usr/share/wordlists/dirb/common.txt 7kbscan(windows) waf wafw00f 1wafw00f [url] nmap 123nmap –p80,443 --script http-waf-detect ipnmap –p80,443 --script http-waf-fingerprint ip 自动化集成工具 灯塔 123456cd LinuxEnvConfigsudo bash LinuxEnvConfig.sh8docker0的inet EHole 123456789cd D:\\渗透\\EHole\\EHole_windows_amd64EHole_windows_amd64.exe -h# URL地址需带上协议,每行一个EHole_windows_amd64.exe finger -l url.txt# 支持单IP或IP段EHole_windows_amd64.exe finger -f 192.168.1.1/24# 结果输出至export.json文件EHole_windows_amd64.exe finger -l url.txt -json export.json","categories":[],"tags":[]},{"title":"Git","slug":"Git","date":"2025-04-25T06:03:36.000Z","updated":"2025-04-25T06:03:37.001Z","comments":true,"path":"2025/04/25/Git/","permalink":"http://example.com/2025/04/25/Git/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"leetcode","slug":"leetcode","date":"2025-03-17T03:03:32.000Z","updated":"2025-03-19T11:17:22.707Z","comments":true,"path":"2025/03/17/leetcode/","permalink":"http://example.com/2025/03/17/leetcode/","excerpt":"","text":"哈希 1.两数之和 快速查找需求 1234567891011121314class Solution&#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums,int target)&#123; unordered_map&lt;int,int&gt; hashtable; for(int i=0;i&lt;nums.size();i++)&#123; auto it = hashtable.find(target-nums[i]); if(it !=hashtable.end())&#123; return &#123;i,it-&gt;second&#125;; &#125; hashtable[nums[i]]=i; &#125; return &#123;&#125;; &#125;&#125;; 12345678class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: hashtable=&#123;&#125; for i in range(len(nums)): if target-nums[i] in hashtable: return [i,hashtable[target-nums[i]]] hashtable[nums[i]] =i return [] 面试题 16.15 珠玑妙算 1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; masterMind(string solution, string guess) &#123; int ri= 0,fr=0; int dic[4][2] = &#123;0&#125;; unordered_map&lt;char,int&gt; char_to_index = &#123;&#123;&#x27;R&#x27;,0&#125;,&#123;&#x27;Y&#x27;,1&#125;,&#123;&#x27;G&#x27;,2&#125;,&#123;&#x27;B&#x27;,3&#125;&#125;; for(int i=0;i&lt;4;i++)&#123; char s=solution[i],g = guess[i]; if(s==g) ri++; else&#123; dic[char_to_index[s]][0]++; dic[char_to_index[g]][1]++; &#125; &#125; for(int i=0;i&lt;4;i++) fr+=min(dic[i][0],dic[i][1]); return &#123;ri,fr&#125;; &#125;&#125;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# 低效class Solution: def masterMind(self, solution: str, guess: str) -&gt; List[int]: hash_sol,hash_gue = defaultdict(int),defaultdict(int) right,fr=0,0 for i in range(4): if solution[i]==guess[i]: right += 1 else: hash_gue[guess[i]]+=1 hash_sol[solution[i]]+=1 for key in hash_gue: if key in hash_sol: fr += min (hash_sol[key],hash_gue[key]) return [right,fr]# 优化from typing import Listclass Solution: def masterMind(self, solution: str, guess: str) -&gt; List[int]: # 初始化猜中次数和伪猜中次数 corr, err = 0, 0 # 使用列表代替字典，索引对应字符： # 0: &#x27;R&#x27;, 1: &#x27;Y&#x27;, 2: &#x27;G&#x27;, 3: &#x27;B&#x27; # dic[char][0]: solution 中未匹配的字符数量 # dic[char][1]: guess 中未匹配的字符数量 dic = [[0, 0] for _ in range(4)] # 字符到索引的映射 char_to_index = &#123;&#x27;R&#x27;: 0, &#x27;Y&#x27;: 1, &#x27;G&#x27;: 2, &#x27;B&#x27;: 3&#125; # 遍历字符串，统计猜中次数和未匹配字符 for i in range(4): s, g = solution[i], guess[i] if s == g: corr += 1 else: # 更新 solution 中未匹配字符的数量 dic[char_to_index[s]][0] += 1 # 更新 guess 中未匹配字符的数量 dic[char_to_index[g]][1] += 1 # 计算伪猜中次数 for count_sol, count_gue in dic: err += min(count_sol, count_gue) return [corr, err] 1941 检查是否所有字符出现次数相同 1234567891011121314class Solution &#123;public: bool areOccurrencesEqual(string s) &#123; unordered_map&lt;char ,int&gt; hashtable; for (char c :s) hashtable[c]++; int n = hashtable[s[0]]; for(char c :s)&#123; if(hashtable[c]!=n) return false; &#125; return true; &#125;&#125;; 123456789101112131415class Solution: def areOccurrencesEqual(self, s: str) -&gt; bool: hashtable = defaultdict(int) for i in s: hashtable[i]+=1 n = hashtable[s[0]] for i in hashtable: if n!=hashtable[i]: return False return True# 优化class Solution: def areOccurrencesEqual(self, s: str) -&gt; bool: c = Counter(s) return len(set(c.values())) == 1 13 罗马数字转整数 12345678910111213141516171819202122232425class Solution &#123;public: int romanToInt(string s) &#123; unordered_map &lt;char,int&gt; dic = &#123;&#123;&#x27;I&#x27;,1&#125;,&#123;&#x27;V&#x27;,5&#125;,&#123;&#x27;X&#x27;,10&#125;,&#123;&#x27;L&#x27;,50&#125;,&#123;&#x27;C&#x27;,100&#125;,&#123;&#x27;D&#x27;,500&#125;,&#123;&#x27;M&#x27;,1000&#125;&#125;; /* // 使用数组代替 unordered_map更快 int dic[256] = &#123;0&#125;; // ASCII 表大小为 256 dic[&#x27;I&#x27;] = 1; dic[&#x27;V&#x27;] = 5; dic[&#x27;X&#x27;] = 10; dic[&#x27;L&#x27;] = 50; dic[&#x27;C&#x27;] = 100; dic[&#x27;D&#x27;] = 500; dic[&#x27;M&#x27;] = 1000; */ int result = 0; for(int i =0;i&lt;s.length();i++)&#123; if(i!=s.length()-1 &amp;&amp; dic[s[i]]&lt;dic[s[i+1]]) result-=dic[s[i]]; else result+=dic[s[i]]; &#125; return result; &#125;&#125;; 12345678910class Solution: def romanToInt(self, s: str) -&gt; int: dic = &#123;&quot;I&quot;:1,&quot;V&quot;:5,&quot;X&quot;:10,&quot;L&quot;:50,&quot;C&quot;:100,&quot;D&quot;:500,&quot;M&quot;:1000&#125; result = 0 for i in range(len(s)): if i !=len(s)-1 and dic[s[i]] &lt; dic[s[i+1]] : result -= dic[s[i]] else: result += dic[s[i]] return result 3.无重复字符的最长子串 123456789101112131415161718class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; unordered_set&lt;char&gt; set; int n=s.length(),r=0,ans=0; for(int l = 0;l&lt;n;l++)&#123; if(l!=0)&#123; set.erase(s[l-1]); &#125; while(r&lt;n &amp;&amp; set.count(s[r])==0)&#123; set.insert(s[r]); r++; &#125; ans = max(ans,r-l); &#125; return ans; &#125;&#125;; 12345678910111213class Solution: def lengthOfLongestSubstring(self, s: str) -&gt; int: occ = set() n = len(s) r,ans=0,0 for l in range(n): if l != 0: occ.remove(s[l-1]) while r&lt;n and s[r] not in occ: occ.add(s[r]) r+=1 ans = max (ans,r-l) return ans 动态规划 5.最长回文子串 12345678910111213141516171819class Solution &#123;public: string longestPalindrome(string s) &#123; string result = &quot;&quot;,odd,even; for(int i=0;i&lt;s.length();i++)&#123; odd = expand(s,i,i); even = expand(s,i,i+1); if(odd.length()&gt;result.length()) result = odd; if(even.length()&gt;result.length()) result = even; &#125; return result; &#125; string expand(string s,int l,int r)&#123; while(l&gt;=0 &amp;&amp; r&lt;s.length() &amp;&amp; s[l]==s[r])&#123; l--,r++; &#125; return s.substr(l+1,r-l-1); &#125;&#125;; 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution: def longestPalindrome(self, s: str) -&gt; str: n = len(s) if n &lt; 2: return s dp = [[False] * n for _ in range(n)] # 初始化 dp 数组 start, end = 0, 0 # 记录最长回文子串的起始和结束位置 # 单个字符一定是回文 for i in range(n): dp[i][i] = True # 检查长度为 2 的子串 for i in range(n - 1): if s[i] == s[i + 1]: dp[i][i + 1] = True start, end = i, i + 1 # 检查长度大于 2 的子串 for length in range(3, n + 1): # 子串长度从 3 到 n for i in range(n - length + 1): # 子串起始位置 j = i + length - 1 # 子串结束位置 if s[i] == s[j] and dp[i + 1][j - 1]: # 状态转移 dp[i][j] = True if length &gt; (end - start + 1): # 更新最长回文子串 start, end = i, j return s[start:end + 1] # 返回最长回文子串//优化class Solution: def longestPalindrome(self, s: str) -&gt; str: def max_hw(l:int, r:int) -&gt; str : while l&gt;=0 and r&lt;len(s) and s[l] == s[r]: l -= 1 r += 1 return s[l+1:r] result = s[0] for i in range(len(s)): odd = max_hw(i,i) even = max_hw(i,i+1) result = max(result,odd,even,key=len) return result 509.斐波那契数 1234567891011121314class Solution &#123;public: int fib(int n) &#123; int f1=0,f2 =1,temp; if(n==0) return 0; for(int i=0;i&lt;n-1;i++)&#123; temp = f1+f2; f1 = f2; f2 = temp; &#125; return f2; &#125;&#125;; 12345678class Solution: def fib(self, n: int) -&gt; int: f1 ,f2 ,fn = 0,1,1 if n ==0 :return 0 for i in range(n-1): fn = f1 + f2 f1, f2 = f2, fn return fn 300.最长增长子序列 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n==0) return 0; vector&lt;int&gt; dp(n,1); for(int i=1;i&lt;n;i++)&#123; for(int j=0;j&lt;i;j++)&#123; if(nums[j]&lt;nums[i])&#123; dp[i] = max(dp[i],dp[j]+1); &#125; &#125; &#125; return *max_element(dp.begin(),dp.end()); &#125;&#125;;//优化class Solution &#123;public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return 0; vector&lt;int&gt; dp; for(int num:nums)&#123; auto it = lower_bound(dp.begin(),dp.end(),num); if(it == dp.end())&#123; dp.push_back(num); &#125; else&#123; *it = num; &#125; &#125; return dp.size(); &#125;&#125;; 1234567891011121314151617181920212223242526class Solution: def lengthOfLIS(self, nums: List[int]) -&gt; int: if not nums: return 0 n = len(nums) dp = [1]*n for i in range(1,n): for j in range(i): if nums[j]&lt;nums[i]: dp[i] = max(dp[i],dp[j]+1) return max(dp)# 优化：二分查找class Solution: def lengthOfLIS(self, nums: List[int]) -&gt; int: if not nums: return 0 dp = [] # 用于存储递增子序列 for num in nums: # 使用二分查找找到插入位置 pos = bisect.bisect_left(dp, num) if pos == len(dp): dp.append(num) # 如果 num 大于所有元素，直接添加到末尾 else: dp[pos] = num # 否则替换掉第一个大于等于 num 的元素 return len(dp) # dp 的长度即为最长递增子序列的长度 72.编辑距离 123456789101112131415161718192021class Solution &#123;public: int minDistance(string word1, string word2) &#123; int n1 = word1.length(), n2 = word2.length(); if(n1*n2==0) return n1+n2; vector&lt;vector&lt;int&gt;&gt; dp(n1+1,vector&lt;int&gt;(n2+1)); for(int i=0;i&lt;n1+1;i++) dp[i][0] = i; for(int j=0;j&lt;n2+1;j++) dp[0][j] = j; for(int i=1;i&lt;n1+1;i++)&#123; for(int j=1;j&lt;n2+1;j++)&#123; if(word1[i-1]==word2[j-1]) dp[i][j]=dp[i-1][j-1]; else dp[i][j]=1+min(&#123;dp[i-1][j],dp[i][j-1],dp[i-1][j-1]&#125;); &#125; &#125; return dp[n1][n2]; &#125;&#125;; 1234567891011121314151617class Solution: def minDistance(self, word1: str, word2: str) -&gt; int: n1, n2 = len(word1), len(word2) if n1*n2 == 0: return n1+n2 dp = [[0]*(n2+1) for _ in range(n1+1)] for i in range(n1+1): dp[i][0]=i for j in range(n2+1): dp[0][j]=j for i in range(1,n1+1): for j in range(1,n2+1): if word1[i-1] == word2[j-1]: dp[i][j] = dp [i-1][j-1] else: dp[i][j] = min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1 return dp[n1][n2] 198.打家劫舍 12345678910111213class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return 0; int n = nums.size(),dp0=0,dp1=nums[0],temp; for(int i=1;i&lt;n;i++)&#123; temp = max(dp0,dp1); dp1 = dp0 + nums[i]; dp0 = temp; &#125; return max(dp0,dp1); &#125;&#125;; 1234567891011class Solution: def rob(self, nums: List[int]) -&gt; int: n = len(nums) if n ==0 : return 0 dp = [[0]*2 for _ in range(n)] dp[0][1] = nums[0] for i in range(1,n): dp[i][0] = max(dp[i-1][0],dp[i-1][1]) dp[i][1] = dp[i-1][0]+nums[i] return max(dp[n-1][0],dp[n-1][1]) 贪心算法","categories":[],"tags":[]},{"title":"算法","slug":"算法","date":"2025-03-10T08:37:46.000Z","updated":"2025-03-19T10:47:16.534Z","comments":true,"path":"2025/03/10/算法/","permalink":"http://example.com/2025/03/10/%E7%AE%97%E6%B3%95/","excerpt":"","text":"哈希 题目特征 快速查找需求 如判断元素是否存在（重复、交集等），或需要快速查询互补值（如两数之和）。 统计频率/次数 统计字符、数字等的出现次数，例如变位词、多数元素问题。 唯一性/去重问题 如找第一个不重复字符、去重后保留特定顺序等。 映射关系维护 需建立元素间映射（如字符串同构），或记录元素的位置信息（如子数组问题）。 前缀和优化 结合哈希表快速计算子数组和、差值等（如和为K的子数组） 常见解题思路 哈希集合（HashSet） 存储唯一元素，用于去重或存在性判断。 示例题：环形链表、快乐数、数组交集。 哈希映射（HashMap） 记录键值对，存储元素及其索引、频率或其他关联信息。 示例题：两数之和、变位词分组、克隆图的深拷贝。 前缀和 + 哈希表 计算前缀和，用哈希表记录和的出现次数或最早出现位置。 示例题：和为K的子数组、连续数组（0和1数量相等的最长子数组）。 滑动窗口 + 哈希表 维护窗口内元素的哈希统计，用于子串/子数组问题。 示例题：无重复字符的最长子串、最小覆盖子串。 频率统计与比较 用哈希表统计频率后比较（如变位词），或用数组替代哈希优化空间（如仅小写字母的场景）。 优化技巧 数组替代哈希表：若元素范围有限（如字母、固定范围的数字），使用数组更高效。 双向映射：处理同构问题时，需双向检查两个哈希表的映射关系。 延迟更新：在滑动窗口中，可延迟删除哈希表中的元素以简化逻辑（如某些子串问题）。 典型例题 两数之和（HashMap记录值与索引） 无重复字符的最长子串（滑动窗口 + HashMap记录字符最新位置） 字母异位词分组（HashMap以排序后的字符串为Key） 和为K的子数组（前缀和 + HashMap统计和出现次数） 最长连续序列（HashSet快速查找连续元素） 动态规划（DP） 题目特征 最优化问题 如求最大值、最小值、最长/最短路径等。 重叠子问题 问题可以分解为多个子问题，且子问题之间存在重叠（重复计算）。 无后效性 当前状态只与之前的状态有关，而与之后的状态无关。 状态转移 问题可以通过状态转移方程描述，即当前状态由之前的状态推导而来。 常见解题思路 定义状态 明确问题的状态表示，通常用 dp[i] 或 dp[i][j] 表示某种条件下的最优解。 示例： dp[i]：以第 i 个元素结尾的子问题的解（如最长递增子序列）。 dp[i][j]：从位置 (0,0) 到 (i,j) 的解（如网格路径问题）。 状态转移方程 根据问题的逻辑，推导出状态之间的关系。 示例： 斐波那契数列：dp[i] = dp[i-1] + dp[i-2] 最长递增子序列：dp[i] = max(dp[i], dp[j] + 1)，其中 j &lt; i 且 nums[j] &lt; nums[i] 背包问题：dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i]) 初始化 确定初始状态的值，通常为边界条件。 示例： dp[0] = 0 或 dp[0] = 1（根据问题需求）。 二维 DP 问题中，通常需要初始化第一行和第一列。 计算顺序 按照状态转移方程的逻辑，确定计算顺序（如从左到右、从下到上等）。 返回结果 根据问题需求，返回 dp 数组中的某个值或最大值/最小值。 常见动态规划问题类型 线性 DP 状态定义为一维数组，如斐波那契数列、最长递增子序列、最大子数组和。 二维 DP 状态定义为二维数组，如网格路径问题、编辑距离、最长公共子序列。 背包问题 0-1 背包、完全背包、多重背包等，状态转移涉及容量和物品选择。 区间 DP 状态定义为区间，如石子合并、最长回文子串。 树形 DP 在树结构上进行状态转移，如二叉树中的最大路径和。 状态压缩 DP 通过位运算等技巧压缩状态，减少空间复杂度（如旅行商问题）。 解题步骤总结 分析问题是否满足动态规划的特征（最优化、重叠子问题、无后效性）。 定义状态，明确 dp 数组的含义。 推导状态转移方程，确定如何从子问题推导出当前问题。 初始化 dp 数组，处理边界条件。 按顺序计算 dp 数组，并返回最终结果。 考虑空间优化（如滚动数组）。 优化技巧 空间优化 如果状态转移只依赖于前几个状态，可以用滚动数组或变量代替整个 dp 数组。 示例：斐波那契数列中，只需两个变量 prev 和 curr。 记忆化搜索 在递归中缓存子问题的解，避免重复计算（如自顶向下的 DP）。 预处理 对输入数据进行预处理（如排序），简化状态转移逻辑。 边界条件处理 注意处理边界条件，避免数组越界或逻辑错误。 典型例题 斐波那契数列（线性 DP） 最长递增子序列（线性 DP） 最大子数组和（线性 DP） 编辑距离（二维 DP） 0-1 背包问题（背包 DP） 最长回文子串（区间 DP） 打家劫舍（线性 DP + 空间优化） 三角形最小路径和（二维 DP + 空间优化） 贪心算法 题目特征 1. 明显的局部最优可推导全局最优 问题可以通过每一步选择当前最优解，最终得到全局最优解。 典型场景：最少操作次数、最大收益、最短时间等最优化问题。 2. 无后效性 当前选择不会影响后续子问题的结构，后续状态仅依赖当前状态。 3. 常见问题类型 区间调度：如最多不重叠活动、合并区间。 分配问题：分糖果、任务调度。 跳跃覆盖：能否到达终点、最少跳跃次数。 数学规律：找零钱（特定面值）、加油站问题。 压缩编码：哈夫曼编码、字符串重构。 常见解题思路 1. 排序 + 贪心遍历 核心：通过排序预处理，使数据满足贪心选择的顺序。 典型例题： 合并区间：按左端点排序，合并右端点连续的区间。 最多不重叠活动：按结束时间排序，选择最早结束的活动。 2. 优先队列（堆）维护当前最优 核心：动态选择当前最优解（如最大值、最小值）。 典型例题： 合并K个有序链表：用小根堆每次取最小节点。 任务调度器：优先处理剩余次数最多的任务，避免冷却时间。 3. 数学性质推导 核心：利用问题中隐藏的数学规律直接决策。 典型例题： 跳跃游戏：维护当前能到达的最远距离，不回溯。 加油站问题：总油量≥0时，必存在解；遍历找到剩余油量最低点的下一个站点。 4. 双向贪心或多次遍历 核心：通过左右两次遍历或前后双指针满足不同条件。 典型例题： 分发糖果：左遍历保证右分高者多，右遍历保证左分高者多。 接雨水：双指针从两端向中间逼近，计算局部凹陷。 优化技巧 1. 排序优化 若问题只需局部有序，可用计数排序或桶排序降低时间复杂度。 示例：任务调度器中按任务频率排序。 2. 空间压缩 用变量替代数组，减少空间复杂度。 示例：跳跃游戏中用 max_reach 替代DP数组。 3. 剪枝策略 提前终止无效遍历。 示例：加油站问题中，若当前油量不足则直接跳到下一个起点。 4. 数学替换 将问题转化为数学公式，避免复杂逻辑。 示例：柠檬水找零问题中，优先用10元找零，减少5元消耗。 易错点与注意事项 贪心策略的证明：必须验证局部最优能推导全局最优（可通过反证法或数学归纳）。 边界条件：如空输入、全零、单元素等情况需特殊处理。 排序规则：区间问题按左端点还是右端点排序，影响贪心逻辑。","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"软件测试","slug":"软件测试","date":"2025-03-10T06:38:09.000Z","updated":"2025-03-16T09:23:21.043Z","comments":true,"path":"2025/03/10/软件测试/","permalink":"http://example.com/2025/03/10/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/","excerpt":"","text":"基础 问题报告单样式 测试计划文档组成 测试工作流程 掌握需求 -&gt;测试计划-&gt;测试用例-&gt;测试执行-&gt;测试报告-&gt;回归测试 测试开始时，须有：1.系统需求说明书文档 2.BUG管理工具的地址和账户 单元测试：在开发阶段进行，验证单个代码单元的正确性。 集成测试：在单元测试之后进行，验证多个模块的协同工作。 系统测试：在集成测试之后进行，验证整个系统的功能和性能。 验收测试：在系统测试之后进行，由客户或最终用户确认系统是否满足需求 名词解释 123456789101112131415161718192021222324252627282930313233343536373839404142434445黑盒测试：不关心代码，只测输入输出。白盒测试：基于代码结构设计测试。结构测试：通过代码结构设计测试用例。功能测试：验证功能是否符合需求。路径测试：覆盖代码中的所有路径。增量测试：逐步集成和测试新模块。崩溃测试：测试系统在极端条件下的稳定性。性能测试：评估系统在不同负载下的性能。回归测试：确保修改后原有功能不受影响。单元测试：测试最小可测试单元。集成测试：测试多个模块的组合。系统测试：测试整个系统。验收测试：由客户确认系统是否满足需求。负载测试：模拟高负载测试性能。压力测试：测试系统的极限能力。安全测试：评估系统安全性。兼容性测试：测试系统在不同环境下的兼容性。冒烟测试：快速测试主要功能。探索性测试：无预设用例，通过探索发现问题。α测试：由内部人员在开发环境中进行β测试：是软件发布前的最终测试阶段，通常在α测试之后进行。它由真实用户在实际环境中执行，目的是发现开发团队未察觉的问题。用户验收测试（UAT）：由客户确认软件是否满足需求，β测试更侧重于广泛用户反馈。迭代测试：是敏捷开发中的一种测试方法，随着每个开发迭代的进行，测试活动也同步展开。每次迭代都会进行完整的测试循环，包括单元测试、集成测试、系统测试等，以确保新增功能和现有功能都符合需求。特点：持续进行：测试贯穿整个开发周期，而非仅在开发完成后进行。增量式：每次迭代只测试新增或修改的部分，同时进行回归测试以确保原有功能不受影响。快速反馈：通过频繁测试，开发团队能快速发现并修复问题。能都经过充分测试。 面试 测试流程与规范 偶现bug怎么处理？ 截图、保留证据，根据操作路径进⾏重现，提交禅道，上线前继续跟踪，上线后再跟踪⼀两个版本，最后作为遗留bug写到测试报告⾥⾯ 没有需求⽂档，如何开展测试？ 1、与相关⼈员沟通，产品或开发 2、参考同⾏业竞品，总结梳理需求 3、根据⽤户习惯和⾏业规范，总结梳理 线上出现bug怎么办？ ⾸先评估严重程度和产⽣原因， 1、如果是影响⾯⽐较⼤的功能性问题，且短时间内不好定位具体原因，⾸先考虑做代码回滚，恢复到上 ⼀个稳定版本，然后在测试环境进⾏重现，定位问题原因 2、如果是能快速定位问题原因，就让开发做紧急修复，测试后进⾏上线 3、如果是性能问题，⼀般会进⾏扩容，或重启尝试解决，然后开发会做进⼀步的问题定位和优化 4、如果是⼀些优化性问题，会先进⾏记录，然后在下个版本解决 最后，线上bug解决后，要对问题进⾏复盘，分析和总结，避免后续再出现类似问题 临近上线发现了bug要怎么处理？ ⾸先与相关⼈员（开发、产品）评估bug的严重程度和影响范围， 如果是轻微的bug，可以考虑先上线，后续版本迭代中修复， 如果是⽐较严重的bug，找开发沟通，能否快速修复，并且有⾜够的时间去做下测试 如果时间不⾜了，那就得和相关⼈员后台，是否可以延期上线，避免上线后造成严重的后果 参加⼈员：测试⼈员、开发⼈员、产品⼈员 会议评审 ⽤例评审都有哪些⼈参加？怎么做的？有什么标准？ 参加⼈员：测试⼈员、开发⼈员、产品⼈员 会议评审 标准： ⽤例设计的结构安排是否清晰、合理，是否利于⾼效对需求进⾏覆盖。 优先极安排是否合理。 是否覆盖测试需求上的所有功能点。 ⽤例是否具有很好可执⾏性。例如⽤例的前提条件、执⾏步骤、输⼊数据和期待结果是否清晰、正确； 期待结果是否有明显的验证⽅法。 是否已经删除了冗余的⽤例 迭代测试发现不了问题，怎么办？ 1)必要的业务培训 结合业务流程图、系统架构图，对业务系统有个整体的感知。知道业务系统的整体业务流向及涉及的系统架构，这样有助于测试⼈员从⼤的⽅向去拉通测试场景，不⾄于陷⼊细节中⽽⽆法顾及全貌。 2)制定明确地测试策略 即明确两个问题：测什么？怎么测？“减少缺陷的出现”可以通过测试前移等⽅法来解决，在进⾏软件需求分析和架构设计的时候发现 缺陷； 3)严格执⾏测试流程 设计测试⽤例、⽤例评审、开发⾃测等 4)建⽴质量意识和责任感 出现问题时，测试应该有责任和能⼒去探查问题的根源并加以改进 5)定期回顾和总结 缺陷分析，在某个迭代或者版本的周期内（或者更⻓时间），对BUG产⽣的原因、修复周期、累 积趋势进⾏分析。总结分析bug和测试过程问题，形成的质量报告不仅能准确评估过去产品质量，还能为未来产品提出改进建议，持续推进产品质量的不断提⾼和完善 接口测试 什么时候会做接⼝测试 回归测试 前后端联调阶段（开发进⾏⾃测） 验证⼀些后端接⼝是否有限制的场景（资⾦相关） 怎么做接⼝测试的 1、获取到接⼝⽂档、熟悉单接⼝的业务、连接接⼝业务，包括接⼝地址，请求⽅式，鉴权，⼊参，出 参，错误码等 加密，签名等 2、编写接⼝⽤例并评审 正例：单接⼝，链接接⼝ 反例：鉴权（过期的场景、不正确） 参数（类型异常、⻓度异常）， 错误码（-1 系统繁忙、不同公司不⼀样）， ⿊名单（⿊名单⽤户是否还允许访问） 禁⽤ 调⽤次数（⼿续费） 分⻚（每⻚10条，每⻚是否都有数据，总数据是否正确，边界值） 兼容性（不同调⽤⽅式下（如app版本不⼀样时），接⼝返回的数据是否相同） 3、执⾏⽤例 举出具体的接⼝案例以及⼀些特定场景，如：接⼝串联（token传递）、环境变量、全局变量、随机数获 取（⽐如第三⽅单号） 4、持续集成 钉钉群通知、电⼦邮件 如果⼀个接⼝请求不通，那么你会考虑哪些⽅⾯的问题？ 1、检查请求四要素：请求⽅式、域名、请求头、请求参数、有没有空格 2、⽹络情况 3、项⽬迭代过程中是否有部署好 4、服务器的防⽕墙 5、查看后台⽇志是否有报错 6、访问权限是否到位 7、⼀边打开fiddler（打开代理服务器，证书有问题）⼀遍做接⼝测试（基于https） 8、检查是否绑定了错误的hosts 接⼝测试的作⽤ 1、接⼝测试是⽆⻚⾯的功能测试，设计⽤例思路跟功能测试⼀样（只是⼀个注重的是测前端⻚⾯，⼀个注重的是测后端接⼝） 2、接⼝测试可以绕开前端 3、接⼝测试可以校验并发的情况 4、可以核对接⼝请求资源⼤⼩ 5、可以进⾏弱⽹测试 接⼝测试的主要关注点？ （1）业务逻辑（业务逻辑覆盖） （2）响应结构 （3）数据格式 （4）数据正确性（依据来源：查数据库与服务器和接⼝返回值⽐较） Cooike、session、token的区别 相同点：三者都⽤于鉴权，都是服务器⽣成 不同点： Cooike：保存在浏览器，不安全 session：保存在服务器的内存，并且它⼀般是通过cooike传输sessionid，它⽐cooike更安全，当访问量⼤的时候影响服务器的性能 token 存储在服务器的数据库，通常是通过登录或者⼀个特定的接⼝传⼊appid和appsect来获取，后续所有的接⼝都必须带上token 才能请求成功，有些项⽬toekn也是通过cookie传输的 特定接⼝：对于需要做RSA加密的接⼝，需要做签名的接⼝在Jmeter/postman要如何处理？ JMeter 使用 JSR223 预处理器 或 BeanShell 预处理器 编写脚本实现 RSA 加密和签名。 将结果存储到 JMeter 变量中，并在请求中使用。 Postman 使用 Pre-request Script 编写脚本实现 RSA 加密和签名。 将结果存储到 Postman 变量中，并在请求中使用。 如何验证接⼝是否返回成功 1、校验状态码是否200（状态断⾔ 只有⼀个） 2、核⼼业务断⾔ 返回结果⽐较短的：key=value 返回结果较⻓的：通过关键信息，数据库校验⻓度 3、XML或JSON：通过正则，jsonpath提取关键的业务字段进⾏断⾔ 接⼝关联怎么做 ⽤⼀个全局变量来处理依赖的数据，⽐如登录后返回 token,其它接⼝都需要这 个 token,那就⽤全局变量来传 token 参数 没有接⼝⽂档如何做接⼝测试 可以使⽤抓包⼯具进⾏抓包看接⼝请求参数，然后不懂的跟开发沟通 常⻅的接⼝请求头 1234AcceptX-Requested-WithUser-AgentContent-Type 接⼝测试常⽤检查点 接口测试检查点（按检查类型分类） 检查类型 检查点 描述 业务测试 正常流程返回数据的正确性 验证接口在正常业务流程下返回的数据内容、格式、逻辑是否符合预期。 接口文档符合性 验证返回值是否按接口文档规定格式（如JSON/XML）、编码（UTF-8）、字段命名（如return_msg）返回。 参数类型传递正确性 验证接口是否正确处理参数类型（如数字、字符串、布尔值等）。 接口依赖关系测试 验证接口依赖的其他服务或数据源异常时，是否能正确处理（如降级、超时）。 异常业务处理逻辑 验证业务异常场景（如余额不足、库存为负）是否返回明确的错误码和描述。 参数测试 参数值全量覆盖验证 对参数所有可能取值（枚举值、布尔值等）进行覆盖测试。 必填参数正确性验证 必填参数传入有效值时，接口返回预期结果。 必填/非必填参数组合验证 测试不同必填与非必填参数组合下的接口行为（如缺少非必填参数是否影响功能）。 参数边界值验证 验证参数在边界值（如最大值、最小值、空值、超长字符串）下的处理逻辑。 异常测试 必填参数缺失 缺失必填参数时是否返回明确错误码（如400 Bad Request）。 非法参数值 传入非法参数（如非数字传入数字字段）是否返回类型错误提示。 超限参数值 参数超过允许范围（如金额超限）是否触发业务规则校验。 性能测试 响应时间 单请求响应时间是否在SLA要求范围内（如≤500ms）。 并发处理能力 高并发场景下接口是否稳定（如100并发用户请求成功率≥99%）。 大数据量处理 处理大量数据时（如万级列表查询）是否返回正确且性能达标。 安全性测试 敏感信息加密 返回的敏感数据（如手机号、身份证号）是否脱敏或加密。 未授权访问防护 未携带Token或权限不足时是否返回401 Unauthorized。 SQL注入防护 传入SQL注入语句（如' OR 1=1 --）是否被拦截并返回错误。 幂等性测试 重复请求一致性 多次提交相同请求（如支付）是否仅产生一次有效结果。 兼容性测试 多版本兼容 新旧版本接口参数格式（如v1/v2）是否能兼容处理。 多客户端兼容 不同客户端（Web/App/第三方）调用接口时返回数据格式是否一致。 功能测试 测试环境没问题，但⽣产/灰度环境有问题，会从哪些原因去定位排查 1、部署原因，⽣产/灰度环境的代码与测试环境验证通过的不⼀致 2、测试数据问题，有些bug需要特殊的数据才能重现出来 3、配置原因，⽣产/灰度环境的配置出问题","categories":[],"tags":[{"name":"测试","slug":"测试","permalink":"http://example.com/tags/%E6%B5%8B%E8%AF%95/"}]},{"title":"力扣hot100python题解","slug":"力扣hot100python题解","date":"2025-03-04T01:25:44.000Z","updated":"2025-03-08T10:10:59.162Z","comments":true,"path":"2025/03/04/力扣hot100python题解/","permalink":"http://example.com/2025/03/04/%E5%8A%9B%E6%89%A3hot100python%E9%A2%98%E8%A7%A3/","excerpt":"","text":"哈希 两数之和 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。 你可以按任意顺序返回答案。 1234567class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: hashtable = &#123;&#125; for index, num in enumerate(nums): if (target-num) in hashtable: return [index, hashtable[target-num]] hashtable[num] = index 字母异位词分组 给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。 字母异位词 是由重新排列源单词的所有字母得到的一个新单词。 12345678910class Solution: def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]: ans = &#123;&#125; for s in strs: key = &#x27;&#x27;.join(sorted(s)) if key not in ans: ans[key] = [s] else: ans[key].append(s) return list(ans.values()) 最长连续序列 给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。 请你设计并实现时间复杂度为 O(n) 的算法解决此问题。 123456789101112class Solution: def longestConsecutive(self, nums: List[int]) -&gt; int: ans = 0 st = set(nums) for x in st: if x-1 in st: continue y = x+1 while y in st: y = y + 1 ans = max(ans,y -x) return ans 双指针 移动0 1234567891011class Solution: def moveZeroes(self, nums: List[int]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify nums in-place instead. &quot;&quot;&quot; left = right = 0 while right &lt; len(nums): if nums[right]!=0: nums[left],nums[right]=nums[right],nums[left] left += 1 right += 1 盛水最多容器 给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 返回容器可以储存的最大水量。 **说明：**你不能倾斜容器。 12345678910111213class Solution: def maxArea(self, height: List[int]) -&gt; int: left = ans = 0 right = len(height) - 1 while left &lt; right : if height[left] &lt; height[right]: ans = max(ans,height[left]*(right-left)) left += 1 else: ans = max(ans,height[right]*(right-left)) right -= 1 return ans 三数之和 给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。 **注意：**答案中不可以包含重复的三元组。 123456789101112131415161718192021222324252627282930class Solution: def threeSum(self, nums: List[int]) -&gt; List[List[int]]: nums.sort() ans = [] n = len(nums) for i in range(n - 2): x = nums[i] if i &gt; 0 and x == nums[i - 1]: # 跳过重复数字 continue if x + nums[i + 1] + nums[i + 2] &gt; 0: # 优化一 break if x + nums[-2] + nums[-1] &lt; 0: # 优化二 continue j = i + 1 k = n - 1 while j &lt; k: s = x + nums[j] + nums[k] if s &gt; 0: k -= 1 elif s &lt; 0: j += 1 else: # 三数之和为 0 ans.append([x, nums[j], nums[k]]) j += 1 while j &lt; k and nums[j] == nums[j - 1]: # 跳过重复数字 j += 1 k -= 1 while k &gt; j and nums[k] == nums[k + 1]: # 跳过重复数字 k -= 1 return ans 接雨水 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 123456789101112131415161718192021222324class Solution: def trap(self, height: List[int]) -&gt; int: if not height: return 0 left, right = 0, len(height) - 1 # 两个指针 left_max, right_max = height[left], height[right] # 左右最大边界 ans = 0 # 结果累加器 while left &lt; right: if height[left] &lt; height[right]: left += 1 if height[left] &gt; left_max: left_max = height[left] else: ans += left_max - height[left] else: right -= 1 if height[right] &gt; right_max: right_max = height[right] else: ans += right_max - height[right] return ans 滑动窗口 无重复字符的最长字串 给定一个字符串 s ，请你找出其中不含有重复字符的 最长 子串 的长度。 123456789101112131415class Solution: def lengthOfLongestSubstring(self, s: str) -&gt; int: d = &#123;&#125; res = 0 start = -1 for index, c in enumerate(s): if c not in d: res = max(res, index-start) else: if d[c] &gt; start: start = d[c] else: res = max(res, index-start) d[c] = index return res 找到字符串中所有字母异位词 给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。 示例 1: 12345输入: s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;输出: [0,6]解释:起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的异位词。起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的异位词。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution: def findAnagrams(self, s: str, p: str) -&gt; List[int]: # 获取字符串 s 和 p 的长度 s_len, p_len = len(s), len(p) # 如果 s 的长度小于 p 的长度，直接返回空列表，因为无法形成异位词子串 if s_len &lt; p_len: return [] # 初始化结果列表，用于存储异位词子串的起始索引 ans = [] # 初始化两个长度为 26 的数组，用于统计字符频率 # s_count 用于统计当前窗口内的字符频率 # p_count 用于统计字符串 p 的字符频率 s_count = [0] * 26 p_count = [0] * 26 # 遍历 p 的前 p_len 个字符，初始化 s_count 和 p_count for i in range(p_len): # 统计 s 的前 p_len 个字符的频率 s_count[ord(s[i]) - 97] += 1 # 统计 p 的前 p_len 个字符的频率 p_count[ord(p[i]) - 97] += 1 # 如果初始窗口的字符频率与 p 的字符频率相等，说明第一个窗口就是异位词 # 将起始索引 0 加入结果列表 if s_count == p_count: ans.append(0) # 滑动窗口遍历 s 的剩余部分 for i in range(s_len - p_len): # 窗口滑动时，移除窗口左侧的字符，将其频率减 1 s_count[ord(s[i]) - 97] -= 1 # 添加窗口右侧的新字符，将其频率加 1 s_count[ord(s[i + p_len]) - 97] += 1 # 检查当前窗口的字符频率是否与 p 的字符频率相等 # 如果相等，说明当前窗口是异位词，将起始索引（i + 1）加入结果列表 if s_count == p_count: ans.append(i + 1) # 返回结果列表 return ans 子串 和为 k的子数组 给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。 子数组是数组中元素的连续非空序列。 12345678910111213141516class Solution: def subarraySum(self, nums: List[int], k: int) -&gt; int: count, pre = 0, 0 hashmap = dict(&#123;0:1&#125;) for num in nums: pre += num if pre - k in hashmap: count += hashmap[pre - k] if pre in hashmap: hashmap[pre] += 1 else: hashmap[pre] = 1 return count 滑动窗口最大值 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。 返回 滑动窗口中的最大值 12345678910111213141516171819202122232425262728293031323334353637383940class Solution: def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]: # 如果数组为空或窗口大小为0，直接返回空列表 if not nums or k == 0: return [] # 使用双端队列来存储当前窗口中的元素索引 deque = collections.deque() # 未形成窗口时的处理 for i in range(k): # 如果队列不为空且队列末尾的元素小于当前元素，则弹出队列末尾的元素 # 这样可以保证队列中的元素是递减的 while deque and deque[-1] &lt; nums[i]: deque.pop() # 将当前元素加入队列 deque.append(nums[i]) # 将当前窗口的最大值（即队列的第一个元素）加入结果列表 res = [deque[0]] # 形成窗口后的处理 for i in range(k, len(nums)): # 如果队列的第一个元素是窗口最左边的元素，则将其从队列中移除 # 因为这个元素即将离开窗口 if deque[0] == nums[i - k]: deque.popleft() # 如果队列不为空且队列末尾的元素小于当前元素，则弹出队列末尾的元素 # 这样可以保证队列中的元素是递减的 while deque and deque[-1] &lt; nums[i]: deque.pop() # 将当前元素加入队列 deque.append(nums[i]) # 将当前窗口的最大值（即队列的第一个元素）加入结果列表 res.append(deque[0]) # 返回结果列表 return res 最小覆盖字串 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 &quot;&quot; 。 1234567891011121314151617181920212223class Solution: def minWindow(self, s: str, t: str) -&gt; str: ans_left, ans_right = -1, len(s) cnt = defaultdict(int) # 比 Counter 更快 for c in t: cnt[c] += 1 less = len(cnt) left = 0 for right, c in enumerate(s): cnt[c] -= 1 if cnt[c] == 0: less -= 1 while less == 0: if right - left &lt; ans_right - ans_left: ans_left, ans_right = left, right x = s[left] if cnt[x] == 0: less += 1 cnt[x] += 1 left += 1 return &quot;&quot; if ans_left &lt; 0 else s[ans_left: ans_right + 1] 普通数组 最大子数组和 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 子数组是数组中的一个连续部分。 123456789101112class Solution: def maxSubArray(self, nums: List[int]) -&gt; int: count = 0 result = -99999 for i in nums: count += i if count &gt; result: result = count if count &lt; 0: count = 0 return result 合并区间 以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。 1234567891011121314class Solution: def merge(self, intervals: List[List[int]]) -&gt; List[List[int]]: intervals.sort(key=lambda x: x[0]) merged = [] for interval in intervals: # 如果列表为空，或者当前区间与上一区间不重合，直接添加 if not merged or merged[-1][1] &lt; interval[0]: merged.append(interval) else: # 否则的话，我们就可以与上一区间进行合并 merged[-1][1] = max(merged[-1][1], interval[1]) return merged 轮转数组 给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。 1234567891011121314class Solution: def rotate(self, nums: List[int], k: int) -&gt; None: def reverse(i: int, j: int) -&gt; None: while i &lt; j: nums[i], nums[j] = nums[j], nums[i] i += 1 j -= 1 n = len(nums) k %= n # 轮转 k 次等于轮转 k % n 次 reverse(0, n - 1) reverse(0, k - 1) reverse(k, n - 1) 除自身以外数组的乘积 给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。 题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在 32 位 整数范围内。 请 **不要使用除法，**且在 O(n) 时间复杂度内完成此题。 12345678910111213import mathclass Solution: def productExceptSelf(self, nums: List[int]) -&gt; List[int]: # 如果有0，可以简化运算 total = math.prod(nums) ans = [] for i, num in enumerate(nums): if num != 0: ans.append(total // num) else: ans.append(math.prod(nums[:i] + nums[i+1:])) return ans 缺失的第一个正数 给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。 请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。 12345678910111213class Solution: def firstMissingPositive(self, nums: List[int]) -&gt; int: N = len(nums) num_list = [0]*(N+1) for num in nums: if num&gt;N or num&lt;=0: continue num_list[num] = 1 for i in range(1,N+1): if num_list[i] == 0: return i return N+1 矩阵 矩阵置零 给定一个 *m* x *n* 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法**。** 123456789101112131415161718class Solution: def setZeroes(self, matrix: List[List[int]]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify matrix in-place instead. &quot;&quot;&quot; m, n = len(matrix), len(matrix[0]) row = [False] * m col = [False] * n for i in range(m): for j in range(n): if matrix[i][j] == 0: row[i], col[j] = True, True for i in range(m): for j in range(n): if row[i] or col[j]: matrix[i][j] = 0 螺旋矩阵 给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。 1234567891011121314151617class Solution: def spiralOrder(self, matrix: List[List[int]]) -&gt; List[int]: result = [] while matrix : result.extend(matrix.pop(0)) if matrix : if matrix[0]: for i in range(len(matrix)): result.append(matrix[i].pop()) if matrix : k = matrix.pop() result.extend(k[::-1]) if matrix : if matrix[0]: for i in range(len(matrix)-1,-1,-1): result.append(matrix[i].pop(0)) return result 旋转图像 给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。 你必须在** 原地** 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。 12345678910class Solution: def rotate(self, matrix: List[List[int]]) -&gt; None: n = len(matrix) # 深拷贝 matrix -&gt; tmp tmp = copy.deepcopy(matrix) # 根据元素旋转公式，遍历修改原矩阵 matrix 的各元素 for i in range(n): for j in range(n): matrix[j][n - 1 - i] = tmp[i][j] 链表 相交链表 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。 1234567class Solution: def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode: A, B = headA, headB while A != B: A = A.next if A else headB B = B.next if B else headA return A 反转链表 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 1234567891011121314# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]: cur ,pre = head, None while cur: temp = cur.next cur.next = pre pre = cur cur = temp return pre 二叉树 二叉树的中序遍历 给定一个二叉树的根节点 root ，返回 它的 中序 遍历 1234567891011121314151617181920class Solution: def inorderTraversal(self, root: TreeNode) -&gt; List[int]: # 初始化栈和结果列表 stack, rst = [root], [] # stack 用于模拟递归调用栈，rst 用于存储遍历结果 # 开始遍历 while stack: # 当栈不为空时，继续遍历 i = stack.pop() # 弹出栈顶元素 # 如果当前元素是 TreeNode 类型 if isinstance(i, TreeNode): # 将右子树、当前节点的值、左子树按顺序压入栈 stack.extend([i.right, i.val, i.left]) # 注意顺序：右 -&gt; 值 -&gt; 左 # 如果当前元素是整数类型（节点的值） elif isinstance(i, int): rst.append(i) # 将节点的值加入结果列表 # 返回结果列表 return rst 二叉树的最大深度 给定一个二叉树 root ，返回其最大深度。二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。 1234class Solution: def maxDepth(self, root: Optional[TreeNode]) -&gt; int: if not root: return 0 return max(self.maxDepth(root.left),self.maxDepth(root.right))+1 图论 岛屿数量 给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。此外，你可以假设该网格的四条边均被水包围。 1234567输入：grid = [ [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]]输出：3 1234567891011121314151617181920212223242526272829303132333435class Solution: def numIslands(self, grid: List[List[str]]) -&gt; int: n_l = 0 # 初始化岛屿数量为 0 # 遍历整个网格 for i in range(len(grid)): for j in range(len(grid[0])): # 如果当前单元格是陆地（&#x27;1&#x27;），则开始 DFS 遍历 if grid[i][j] == &#x27;1&#x27;: self.landpaint(grid, i, j) # 标记当前岛屿的所有陆地 n_l += 1 # 岛屿数量加 1 # 返回岛屿数量 return n_l # DFS 函数：标记当前岛屿的所有陆地 def landpaint(self, grid, x, y): # 将当前陆地标记为已访问（&#x27;2&#x27;） grid[x][y] = &#x27;2&#x27; # 检查下方单元格 if x + 1 &lt; len(grid) and grid[x + 1][y] == &#x27;1&#x27;: self.landpaint(grid, x + 1, y) # 检查右方单元格 if y + 1 &lt; len(grid[0]) and grid[x][y + 1] == &#x27;1&#x27;: self.landpaint(grid, x, y + 1) # 检查上方单元格 if x - 1 &gt;= 0 and grid[x - 1][y] == &#x27;1&#x27;: self.landpaint(grid, x - 1, y) # 检查左方单元格 if y - 1 &gt;= 0 and grid[x][y - 1] == &#x27;1&#x27;: self.landpaint(grid, x, y - 1) 腐烂的橘子 在给定的 m x n 网格 grid 中，每个单元格可以有以下三个值之一：值 0 代表空单元格；值 1 代表新鲜橘子；值 2 代表腐烂的橘子。 每分钟，腐烂的橘子 周围 4 个方向上相邻 的新鲜橘子都会腐烂。返回 直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1 。 123456789101112131415161718192021222324class Solution: def orangesRotting(self, grid: List[List[int]]) -&gt; int: m,n=len(grid),len(grid[0]) fresh=0 q=[] for i,row in enumerate(grid): for j,x in enumerate(row): if x==1: fresh+=1 elif x==2: q.append((i,j)) ans=0 while q and fresh: ans+=1 tmp=q q=[] for x,y in tmp: for i, j in (x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1): # 四方向 if 0 &lt;= i &lt; m and 0 &lt;= j &lt; n and grid[i][j] == 1: # 新鲜橘子 fresh -= 1 grid[i][j] = 2 # 变成腐烂橘子 q.append((i, j)) return -1 if fresh else ans 回溯 全排列 给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。 1234567891011121314151617181920212223242526272829303132333435363738class Solution: def permute(self, nums: List[int]) -&gt; List[List[int]]: # 定义 DFS 函数 def dfs(nums, size, depth, path, used, res): # 如果当前深度等于数组大小，说明找到一个完整排列 if depth == size: res.append(path[:]) # 将当前排列加入结果列表 return # 遍历数组中的每个元素 for i in range(size): # 检查当前元素是否已经被使用过 if not used[i]: # 标记当前元素为已使用 used[i] = True # 将当前元素加入路径 path.append(nums[i]) # 递归调用 DFS，继续生成下一个位置的元素 dfs(nums, size, depth + 1, path, used, res) # 回溯：移除当前元素，恢复状态 path.pop() used[i] = False # 获取数组的长度 size = len(nums) # 如果数组为空，直接返回空列表 if size == 0: return [] # 初始化 used 数组和结果列表 used = [False] * size # 记录元素是否被使用 res = [] # 结果列表，用于存储所有排列 # 调用 DFS 函数，开始生成排列 dfs(nums, size, 0, [], used, res) # 返回结果列表 return res 子集 给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。 1234567891011121314151617181920class Solution: def subsets(self, nums: List[int]) -&gt; List[List[int]]: # 初始化结果列表 res = [] # 获取数组的长度 n = len(nums) # 定义回溯函数 def helper(i, tmp): # 将当前子集加入结果列表 res.append(tmp) # 遍历数组，生成新的子集 for j in range(i, n): # 递归调用，更新子集 helper(j + 1, tmp + [nums[j]]) # 调用回溯函数，从索引 0 和空子集开始 helper(0, []) # 返回结果列表 return res 二分查找 搜索插入位置 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 1234567891011121314class Solution: def searchInsert(self, nums: List[int], target: int) -&gt; int: left, right = 0, len(nums) - 1 while left &lt;= right: mid = (left + right) // 2 if nums[mid] == target: return mid elif nums[mid] &lt; target: left = mid + 1 else: right = mid - 1 return left # left 位置即为插入位置 搜索二维矩阵 给你一个满足下述两条属性的 m x n 整数矩阵：每行中的整数从左到右按非严格递增顺序排列。每行的第一个整数大于前一行的最后一个整数。给你一个整数 target ，如果 target 在矩阵中，返回 true ；否则，返回 false 。 12345678910111213141516171819202122232425class Solution: def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool: # 获取矩阵的行数和列数 m, n = len(matrix), len(matrix[0]) # 初始化二分查找的左右边界 l, r = 0, m * n # 将二维矩阵视为一维数组 # 开始二分查找 while l &lt; r: # 计算中间位置 mid = (l + r) &gt;&gt; 1 # 等价于 (l + r) // 2 # 将一维索引 mid 转换为二维索引 x = matrix[mid // n][mid % n] # 判断中间元素与目标值的关系 if x == target: return True # 找到目标值，返回 True if x &lt; target: l = mid + 1 # 目标值在右半部分 else: r = mid # 目标值在左半部分 # 未找到目标值，返回 False return False 栈 有效的括号 给定一个只包括 '('，')'，'&#123;'，'&#125;'，'['，']' 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 每个右括号都有一个对应的相同类型的左括号。 1234567891011class Solution: def isValid(self, s: str) -&gt; bool: dic = &#123;&#x27;)&#x27;:&#x27;(&#x27;,&#x27;]&#x27;:&#x27;[&#x27;,&#x27;&#125;&#x27;:&#x27;&#123;&#x27;&#125; stack = [] for i in s: if stack and i in dic: if stack[-1] == dic[i]: stack.pop() else: return False else: stack.append(i) return not stack 最小栈 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。实现 MinStack 类: 12345- `MinStack()` 初始化堆栈对象。- `void push(int val)` 将元素val推入堆栈。- `void pop()` 删除堆栈顶部的元素。- `int top()` 获取堆栈顶部的元素。- `int getMin()` 获取堆栈中的最小元素。 12345678910111213141516171819class MinStack: def __init__(self): self.stack = [] self.min_stack = [math.inf] def push(self, val: int) -&gt; None: self.stack.append(val) self.min_stack.append(min(val,self.min_stack[-1])) def pop(self) -&gt; None: self.stack.pop() self.min_stack.pop() def top(self) -&gt; int: return self.stack[-1] def getMin(self) -&gt; int: return self.min_stack[-1] 堆 数组中的第k个最大元素 给定整数数组 nums 和整数 k，请返回数组中第 **k** 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。 1234567891011121314151617181920212223242526272829303132333435class Solution: def findKthLargest(self, nums: List[int], k: int) -&gt; int: # 定义快速选择函数 def quick_select(nums, k): # 随机选择一个基准元素（pivot） pivot = random.choice(nums) # 初始化三个列表/变量： # - big：存储比 pivot 大的元素 # - equal：记录与 pivot 相等的元素个数 # - small：存储比 pivot 小的元素 big, equal, small = [], 0, [] # 遍历数组，将元素分类 for num in nums: if num &gt; pivot: big.append(num) # 比 pivot 大的元素放入 big elif num &lt; pivot: small.append(num) # 比 pivot 小的元素放入 small else: equal += 1 # 与 pivot 相等的元素计数 # 如果 k 小于等于 big 的长度，说明第 k 个最大元素在 big 中 if k &lt;= len(big): return quick_select(big, k) # 递归在 big 中查找 # 如果 k 大于 big 和 equal 的总长度，说明第 k 个最大元素在 small 中 if len(big) + equal &lt; k: return quick_select(small, k - len(big) - equal) # 递归在 small 中查找 # 如果以上条件都不满足，说明第 k 个最大元素就是 pivot return pivot # 调用快速选择函数，返回第 k 个最大元素 return quick_select(nums, k) 前k个高频元素 给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。 1234class Solution: def topKFrequent(self, nums: List[int], k: int) -&gt; List[int]: count = collections.Counter(nums) return [item[0] for item in count.most_common(k)] 贪心算法 买卖股票的最佳时期 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。 123456789101112class Solution: def maxProfit(self, prices: List[int]) -&gt; int: profit = 0 low=high=prices[0] for p in prices: if p &lt; low: #对每个新的最低点来说，之前的最高点不再有效，需要结利 profit = max(profit, high-low) low=high=p elif p &gt; high: high=p profit = max(profit, high-low) return profit 跳跃游戏 给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。 123456789class Solution: def canJump(self, nums: List[int]) -&gt; bool: if not nums :return False maxlong,n= 0,len(nums) for i in range(n): if i&gt;maxlong: return False maxlong= max(i+nums[i],maxlong) return True 动态规划 爬楼梯 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 123456class Solution: def climbStairs(self, n: int) -&gt; int: a, b = 1, 1 for _ in range(n - 1): a, b = b, a + b return b 杨辉三角 给定一个非负整数 *numRows，*生成「杨辉三角」的前 numRows 行。 12345678class Solution: def generate(self, numRows: int) -&gt; List[List[int]]: c = [[1] * (i + 1) for i in range(numRows)] for i in range(2, numRows): for j in range(1, i): # 左上方的数 + 正上方的数 c[i][j] = c[i - 1][j - 1] + c[i - 1][j] return c 多维动态规划 不同路径 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。问总共有多少条不同的路径？ 1234567class Solution: def uniquePaths(self, m: int, n: int) -&gt; int: f = [1] * n for i in range(1, m): for j in range(1, n): f[j] += f[j - 1] return f[n - 1] 最小路径和 给定一个包含非负整数的 *m* x *n* 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。**说明：**每次只能向下或者向右移动一步。 12345678910111213141516171819202122232425262728293031class Solution: def minPathSum(self, grid: List[List[int]]) -&gt; int: # 如果网格为空，返回 0 if not grid or not grid[0]: return 0 # 获取网格的行数和列数 rows, columns = len(grid), len(grid[0]) # 初始化动态规划数组 dp dp = [[0] * columns for _ in range(rows)] # 起点的最小路径和就是 grid[0][0] dp[0][0] = grid[0][0] # 初始化第一列的最小路径和 for i in range(1, rows): dp[i][0] = dp[i - 1][0] + grid[i][0] # 初始化第一行的最小路径和 for j in range(1, columns): dp[0][j] = dp[0][j - 1] + grid[0][j] # 填充 dp 数组的其余部分 for i in range(1, rows): for j in range(1, columns): # 当前点的最小路径和等于上方或左方的最小路径和加上当前点的值 dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] # 返回右下角的最小路径和 return dp[rows - 1][columns - 1]","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"Python 基础","slug":"Python-基础","date":"2025-02-04T08:29:02.000Z","updated":"2025-02-04T09:51:57.109Z","comments":true,"path":"2025/02/04/Python-基础/","permalink":"http://example.com/2025/02/04/Python-%E5%9F%BA%E7%A1%80/","excerpt":"","text":"关键字 yield yield 是 Python 中的一个关键字，用于定义生成器函数（generator function）。生成器函数是一种特殊的函数，它可以逐步产生值，而不是一次性返回所有结果。yield 的作用是将函数变成一个生成器，每次调用生成器的 __next__() 方法时，函数会执行到 yield 语句并返回一个值，然后暂停执行，直到下一次调用。 yield 的基本用法 示例 1：简单的生成器函数 12345678910def simple_generator(): yield 1 yield 2 yield 3# 使用生成器gen = simple_generator()print(next(gen)) # 输出: 1print(next(gen)) # 输出: 2print(next(gen)) # 输出: 3 每次调用 next(gen)，函数会从上次暂停的地方继续执行，直到遇到下一个 yield。 当没有更多的值可以生成时，会抛出 StopIteration 异常。 示例 2：使用 for 循环遍历生成器 12345678def simple_generator(): yield 1 yield 2 yield 3# 使用 for 循环遍历生成器for value in simple_generator(): print(value) 输出： 123123 for 循环会自动处理 StopIteration 异常，因此不需要手动调用 next()。 yield 的优势 惰性求值： 生成器不会一次性生成所有值，而是按需生成，节省内存。 适合处理大量数据或无限序列。 代码简洁： 使用 yield 可以避免手动实现迭代器协议（__iter__ 和 __next__）。 状态保持： 生成器函数会记住上次执行的状态，下次调用时从上次暂停的地方继续。 yield 的高级用法 示例 3：生成无限序列 123456789101112def infinite_sequence(): num = 0 while True: yield num num += 1# 使用生成器gen = infinite_sequence()print(next(gen)) # 输出: 0print(next(gen)) # 输出: 1print(next(gen)) # 输出: 2# 可以无限调用 next(gen) 这个生成器会无限生成递增的整数。 示例 4：使用 yield 实现斐波那契数列 12345678910def fibonacci(): a, b = 0, 1 while True: yield a a, b = b, a + b# 使用生成器gen = fibonacci()for _ in range(10): print(next(gen)) 输出： 123456789100112358132134 这个生成器会无限生成斐波那契数列的值。 示例 5：yield from（委托生成器） yield from 用于将生成器的控制权委托给另一个生成器。 123456789101112def sub_generator(): yield 1 yield 2def main_generator(): yield &#x27;Start&#x27; yield from sub_generator() yield &#x27;End&#x27;# 使用生成器for value in main_generator(): print(value) 输出： 1234Start12End yield from 可以简化生成器的嵌套调用。 yield 与 return 的区别 特性 yield return 返回值 每次生成一个值，函数暂停 返回一个值，函数结束 状态保持 函数状态会被保存 函数状态不会被保存 适用场景 生成器函数 普通函数 内存占用 惰性求值，节省内存 一次性返回所有结果，占用内存 总结 yield 是 Python 中实现生成器的关键，适合处理大量数据或需要惰性求值的场景。 生成器函数通过 yield 逐步返回值，并保持函数状态，直到生成所有值。 yield from 可以简化生成器的嵌套调用。 assert assert 是 Python 中的一个关键字，用于调试和测试代码。它的作用是检查某个条件是否为真，如果条件为假，则会触发 AssertionError 异常。assert 通常用于确保程序在某个关键点的状态符合预期，如果不符合，则立即停止程序并抛出错误。 assert 的基本语法 1assert condition, message condition：需要检查的条件表达式。如果为 True，程序继续执行；如果为 False，则抛出 AssertionError。 message（可选）：当条件为 False 时，抛出的异常信息。如果未提供，则使用默认的 AssertionError。 assert 的作用 调试工具： 用于在开发阶段检查代码逻辑是否正确。 如果条件不满足，程序会立即停止，方便定位问题。 测试工具： 在单元测试中，用于验证函数的输出是否符合预期。 文档工具： 通过 assert 可以清晰地表达代码的预期行为。 assert 的示例 示例 1：简单的 assert 用法 12x = 10assert x == 10, &quot;x 应该等于 10&quot; 如果 x == 10 为 True，程序继续执行。 如果 x == 10 为 False，则抛出 AssertionError，并显示消息 &quot;x 应该等于 10&quot;。 示例 2：检查函数返回值 123456def divide(a, b): assert b != 0, &quot;除数不能为 0&quot; return a / bprint(divide(10, 2)) # 输出: 5.0print(divide(10, 0)) # 触发 AssertionError: 除数不能为 0 在函数中使用 assert 可以确保输入参数的有效性。 示例 3：检查列表是否非空 1234567def process_list(items): assert len(items) &gt; 0, &quot;列表不能为空&quot; for item in items: print(item)process_list([1, 2, 3]) # 正常执行process_list([]) # 触发 AssertionError: 列表不能为空 assert 的注意事项 不要用于数据验证： assert 主要用于调试和测试，不应该用于检查用户输入或外部数据。 因为 Python 可以通过 -O（优化模式）运行，此时所有的 assert 语句会被忽略。 避免副作用： assert 的条件表达式不应该包含有副作用的操作（如修改全局变量、调用函数等），因为在优化模式下这些操作会被跳过。 替代方案： 对于数据验证或输入检查，应该使用 if 语句并手动抛出异常（如 ValueError、TypeError 等）。 assert 与 if 的区别 特性 assert if 用途 调试和测试 通用条件判断 触发异常 触发 AssertionError 需要手动抛出异常 优化模式 在 -O 模式下会被忽略 不受影响 适用场景 检查内部逻辑是否正确 检查用户输入或外部数据 assert 的优化模式 Python 支持以优化模式运行脚本，此时所有的 assert 语句会被忽略。可以通过以下命令启用优化模式： 1python -O script.py 在优化模式下，assert 语句不会被执行，因此不能依赖它来实现关键逻辑。 总结 assert 是一个强大的调试工具，用于检查代码逻辑是否符合预期。 它适合在开发和测试阶段使用，但不适合用于生产环境中的数据验证。 如果需要更健壮的输入检查，应该使用 if 语句并手动抛出异常。","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]}],"categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"测试","slug":"测试","permalink":"http://example.com/tags/%E6%B5%8B%E8%AF%95/"},{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]}